nextjs分为app router和文件系统路由




JavaScript中为什么需要异步函数**async await**？

因为对于一些函数由于执行需要一段时间（操作是异步的，比如网络请求，在先执行后会返回一个未解析的对象，然后等待网络请求的反应，反应结束后才返回这个函数预期的结果），如果不添加异步操作，会导致获取未解析对象后就立马向下执行。


# 路由
默认情况下app文件夹下的组件是服务端组件，

文件夹路径下有page.js才可以被访问，否则这个页面不显示。

定义路由
链接
错误处理
重定向
导航

# 数据获取

#### 服务端 fetch

支持缓存、重新验证数据
```tsx
async function getData() {
  const res = await fetch('https://api.example.com/...')
  // The return value is *not* serialized
  // You can return Date, Map, Set, etc.
 
  if (!res.ok) {
    // This will activate the closest `error.js` Error Boundary
    throw new Error('Failed to fetch data')
  }
 
  return res.json()
}
 
export default async function Page() {
  const data = await getData()
 
  return <main></main>
}
```

#### 使用第三方库在服务器上获取数据
```ts
import { cache } from 'react'
 
export const getItem = cache(async (id: string) => {
  const item = await db.item.findUnique({ id })
  return item
})
```

#### 使用路由处理器在客户端上获取数据
如果需要在客户端组件中获取数据，可以从客户端调用路由处理程序。路由处理程序在服务器上执行并将数据返回给客户端。当您不想向客户端公开敏感信息（例如 API 令牌）时，这很有用。

#### 使用第三方库在客户端上获取数据
您也可以使用第三方库（如SWR或TanStack Query）在客户端上获取数据。这些库提供自己的 API，用于记忆请求、缓存、重新验证和更改数据。

# 渲染
将编写的代码转换为页面显示内容。

应用程序代码在其中执行的环境：服务器和客户端
用户访问程序或与程序交互时启动的请求-响应生命周期
分隔服务器代码和客户端代码的网络边界


曾经开发客户端和服务端的人员必须使用不同的代码，但是在React项目中，可以都使用JavaScript。

混合应用程序

在这些环境中工作时，将应用程序中的代码流视为单向流会很有帮助。换言之，在响应期间，应用程序代码沿一个方向流动：从服务器到客户端。

如果需要从客户端访问服务器，请向服务器发送新请求，而不是重复使用相同的请求。这样可以更轻松地了解渲染组件的位置以及放置网络边界的位置。

在实践中，此模型鼓励开发人员首先考虑他们想要在服务器上执行的内容，然后再将结果发送到客户端并使应用程序具有交互性。

## 服务器组件
服务器渲染策略
### 静态
使用静态渲染时，路由在构建时渲染，或在数据重新验证后在后台渲染。结果将被缓存，并可以推送到内容分发网络 （CDN）。此优化允许您在用户和服务器请求之间共享渲染工作的结果。
### 动态
对不同用户有个性化需求，




## 客户端组件












文件系统路由，即页面路径是根据文件夹目录`pages/`决定的
### 动态路由的页面
如果有`pages/posts/[id].js`的文件，那么可以通过`posts/1`、`posts/2`来访问路径。

### 预渲染
#### 静态生成
构建时就已经生成HTML文件了，比如在项目中直接`build`得到的文件。

静态生成得到的页面，可以分为带有或不带有数据。

不带有数据的，直接生成！

带有数据的，分为内容取决于外部数据或页面路径取决于外部数据。
1. 页面**内容**取决于外部数据
使用 `getStaticProps`
```jsx
// TODO: 需要获取 `posts`（通过调用 API ）
//       在此页面被预渲染之前
function Blog({ posts }) {
  return (
    <ul>
      {posts.map((post) => (
        <li>{post.title}</li>
      ))}
    </ul>
  )
}

// 此函数在构建时被调用
export async function getStaticProps() {
  // 调用外部 API 获取博文列表
  const res = await fetch('https://.../posts')
  const posts = await res.json()

  // 通过返回 { props: { posts } } 对象，Blog 组件
  // 在构建时将接收到 `posts` 参数
  return {
    props: {
      posts,
    },
  }
}


export default Blog
```



2. 页面**路径**取决于外部数据
使用 `getStaticPaths` （通常还要同时使用 `getStaticProps`）
Next.js 允许你创建具有 **动态路由** 的页面。例如，你可以创建一个名为 `pages/posts/[id].js` 的文件用以展示以 `id` 标识的单篇博客文章。当你访问 `posts/1` 路径时将展示 `id: 1` 的博客文章。

```jsx
function Post({post}){
	//renders post
}
// 此函数在构建时被调用
export async function getStaticPaths() {
  // 调用外部 API 获取博文列表
  const res = await fetch('https://.../posts')
  const posts = await res.json()

  // 据博文列表生成所有需要预渲染的路径
  const paths = posts.map((post) => ({
    params: { id: post.id },
  }))

  // We'll pre-render only these paths at build time.
  // { fallback: false } means other routes should 404.
  return { paths, fallback: false }
}

// 在构建时也会被调用
export async function getStaticProps({ params }) {
  // params 包含此片博文的 `id` 信息。
  // 如果路由是 /posts/1，那么 params.id 就是 1
  const res = await fetch(`https://.../posts/${params.id}`)
  const post = await res.json()

  // 通过 props 参数向页面传递博文的数据
  return { props: { post } }
}

export default Post
```

#### 什么时候使用静态生成？
我们建议您尽可能使用 **静态生成** （带有或不带数据），因为你的所有 page（页面）都可以只构建一次并托管到 CDN 上，这比让服务器根据每个页面请求来渲染页面快得多。

您应该问问自己：“我可以在用户请求之前预先渲染此页面吗？” 如果答案是肯定的，则应选择“静态生成”。

### 服务器端渲染 SSR或动态渲染
如果页面使用的是服务端渲染，那么每次页面请求都会重新生成HTML。

要对 page（页面）使用服务器端渲染，你需要 `export` 一个名为 `getServerSideProps` 的 `async` 函数。服务器将在每次页面请求时调用此函数。

例如，假设你的某个页面需要预渲染频繁更新的数据（从外部 API 获取）。你就可以编写 `getServerSideProps` 获取该数据并将其传递给 `Page` ，如下所示：

```jsx
function Page({ data }) {
  // Render data...
}

// This gets called on every request
export async function getServerSideProps() {
  // Fetch data from external API
  const res = await fetch(`https://.../data`)
  const data = await res.json()

  // Pass data to the page via props
  return { props: { data } }
}

export default Page
```

更推荐**静态生成**

## 获取数据

### 静态生成 getStaticProps
```js
export async function getStaticProps(context) {
  const res = await fetch(`https://.../data`)
  const data = await res.json()

  if (!data) {
    return {
      notFound: true,
    }
  }

  return {
    props: { data }, // will be passed to the page component as props
  }
}
```

## 身份验证


设置 参照VSCode  悬浮于页面
首导航栏 选项内容
设置页面 