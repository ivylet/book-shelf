[{"id":0,"href":"/docs/chapter01/cpp-stl-argo/","title":"STL中常用算法","section":"第一章|基础知识储备","content":" STL中常用算法 # STL中定义了常用的一些算法，比如遍历，查找，排序等一些算法。\n遍历 # for_each 查找 # count_if # 函数原型为count_if(v.begin(),v.end(),comp)\nv.begin()为开始，v.end()为结束，comp为自定义判断函数。\n举个例子：\n排序 # 复制与拷贝 # 算术生成 # 集合算法 # "},{"id":1,"href":"/docs/chapter01/cpp/","title":"STL中常用算法1","section":"第一章|基础知识储备","content":" STL 中常用算法 # STL 中定义了常用的一些算法，比如遍历，查找，排序等一些算法。\n遍历 # for_each 查找 # count_if # 函数原型为count_if(v.begin(),v.end(),comp)\nv.begin()为开始，v.end()为结束，comp为自定义判断函数。\n举个例子：\n排序 # 复制与拷贝 # 算术生成 # 集合算法 # "},{"id":2,"href":"/docs/chapter01/datastru/","title":"常用算法储备知识","section":"第一章|基础知识储备","content":" 时间复杂度 # 对数 ： 每轮排除一半情况 常用于二分法 指数：每轮分别出两倍情况 线性对数：一般为两层循环相互独立，一层为n一层为对数 常常出现在快速排序 空间复杂度 # 位运算 # 位运算有（\u0026amp;、|、^、~、\u0026raquo;、\u0026laquo;）这几种方法，以下为正且位数相同的二进制数进行的位运算，但是还会有其他特殊情况，比如二进制数非正，位数不同的情况。\n符号 描述 运算规则 \u0026amp; 与 两个位都为1时，结果才为1 | 或 两个位都为0时，结果才为0 ^ 异或 两个位相同为0，相异为1 ~ 取反 0变1，1变0 \u0026laquo; 左移 各二进位全部左移若干位，高位丢弃，低位补0 \u0026raquo; 右移 各二进位全部右移若干位，对无符号数，高位补0，有符号数，各编译器处理方法不同 按位与运算符（\u0026amp;） # 定义：参加运算的两个数据，按二进制位进行\u0026quot;与\u0026quot;运算。\n运算规则：同时为1才为1，\n0\u0026amp;0=0 0\u0026amp;1=0 1\u0026amp;0=0 1\u0026amp;1=1 //两位同时为1，结果才为1，否则结果为0。 例如：5\u0026amp;7 即 0000 0101\u0026amp; 0000 0111 = 0000 0101，因此 5\u0026amp;7 的值为5。\n注意：负数按补码形式参加按位与运算。\n与运算的用途：\n清零 如果想将一个单元清零，即使其全部二进制位为0，只要与一个各位都为零的数值相与，结果为零。 取一个数的指定位 比如取数 X=1011 1001 的低4位，只需要另找一个数Y，令Y的低4位为1，其余位为0，即Y=0000 1111，然后将X与Y进行按位与运算（X\u0026amp;Y=0000 1001）即可得到X的指定位。 判断奇偶 二进制的奇偶数只需要根据最未位是0还是1来决定，为0就是偶数，为1就是奇数。因此可以用if ((a \u0026amp; 1) == 0)代替if (a % 2 == 0)来判断a是不是偶数。 按位或运算符（|） # 定义：参加运算的两个对象，按二进制位进行\u0026quot;或\u0026quot;运算。\n运算规则：有1就为1，\n0|0=0 0|1=1 1|0=1 1|1=1 //参加运算的两个对象只要有一个为1，其值为1。 例如：5|7即 0000 0101| 0000 0111 = 0000 0111，因此，5|7的值得7。　注意：负数按补码形式参加按位或运算。\n或运算的用途：\n常用来对一个数据的某些位设置为1 比如将数 X=1010 1001 的低4位设置为1，只需要另找一个数Y，令Y的低4位为1，其余位为0，即Y=0000 1111，然后将X与Y进行按位或运算（X|Y=1010 1001）即可得到。 异或运算符（^） # 定义：参加运算的两个数据，按二进制位进行\u0026quot;异或\u0026quot;运算。\n运算规则：不同为1，相同为0\n0^0=0 0^1=1 1^0=1 1^1=0 //参加运算的两个对象，如果两个相应位相同为0，相异为1。 异或的几条性质:\n1、交换律 2、结合律 (a^b)^c == a^(b^c) 3、对于任何数x，都有 x^x=0，x^0=x 4、自反性: a^b^b=a^0=a; 异或运算的用途：\n翻转指定位 比如将数 X=1010 1110 的低4位进行翻转，只需要另找一个数Y，令Y的低4位为1，其余位为0，即Y=0000 1111，然后将X与Y进行异或运算（X^Y=1010 0001）即可得到。\n与0相异或值不变 例如：1010 1110 ^ 0000 0000 = 1010 1110\n交换两个数 例：(不使用中间变量，但是只能只能交换整型)\nvoid Swap(int \u0026amp;a, int \u0026amp;b){ if (a != b){ a ^= b; b ^= a; a ^= b; } } 取反运算符 (~) # 定义：参加运算的一个数据，按二进制进行\u0026quot;取反\u0026quot;运算。\n运算规则：　直接取反\n~1=0 ~0=1 //对一个二进制数按位取反，即将0变1，1变0。 异或运算的用途：\n使一个数的最低位为零 使a的最低位为0，可以表示为：a \u0026amp; ~1。~1的值为 1111 1111 1111 1110，再按\u0026quot;与\u0026quot;运算，最低位一定为0。 因为\u0026quot; ~\u0026ldquo;运算符的优先级比算术运算符、关系运算符、逻辑运算符和其他运算符都高。 左移运算符（\u0026laquo;） # 定义：将一个运算对象的各二进制位全部左移若干位（左边的二进制位丢弃，右边补0）。\n设 a=1010 1110，a = a\u0026laquo; 2 将a的二进制位左移2位、右补0，即得a=1011 1000。\n若左移时舍弃的高位不包含1，则每左移一位，相当于该数乘以2。\n右移运算符（\u0026raquo;） # 定义：将一个数的各二进制位全部右移若干位，正数左补0，负数左补1，右边丢弃。\n例如：a=a\u0026raquo;2 将a的二进制位右移2位，左补0 或者 左补1得看被移数是正还是负。\n操作数每右移一位，相当于该数除以2。\n复合赋值运算符 # 位运算符与赋值运算符结合，组成新的复合赋值运算符，它们是：\n\u0026amp;= 例：a\u0026amp;=b 相当于 a=a\u0026amp;b |= 例：a|=b 相当于 a=a|b \u0026gt;\u0026gt;= 例：a\u0026gt;\u0026gt;=b 相当于 a=a\u0026gt;\u0026gt;b \u0026lt;\u0026lt;= 例：a\u0026lt;\u0026lt;=b 相当于 a=a\u0026lt;\u0026lt;b ^= 例：a^=b 相当于 a=a^b 运算规则：和前面讲的复合赋值运算符的运算规则相似。\n不同长度的数据进行位运算：如果两个不同长度的数据进行位运算时，系统会将二者按右端对齐，然后进行位运算。\n"},{"id":3,"href":"/docs/notes/other/00001/","title":"无意识？！","section":"暂时没名字","content":"无意识是什么？ 自动机 循环运动\n怎么计组这么多东西？ 还有两门课没学呢!\n"},{"id":4,"href":"/docs/notes/thinknote/00001/","title":"暂且第一记","section":"小记","content":"不是为了个文凭吧，还是要自己想要去做什么东西？\n不要焦虑\n进一步学习 当前国内计算机现状，\n如何成神？ 做大佬 所谓大佬 都是努力\n知道努力很重要的人，并为之努力的人。\n超越别人努力就行了。\n焦虑来源：看错书，走弯路。我要学习，考研是顺带的东西。 拖延症，今天事情今天做完。\n专注，有事情 就只考研。\n考研没时间玩\n化压力为动力\n成神\n别想着抄底！\n别估分洗脑自己\n说自己考70 70 130 130 想着想着以为自己真能考那么多？\n复试焦虑？初试过了担心？ 初试有信心能过，复试为什么不能？\n找研友，适当玩一小会，放空大脑 出去逛逛，有个兴趣爱好，\n如何高效学习 正确的心态 瞄准目标使劲打 终身学习 培养自己 平复自己 任务拆解能力 整体任务 暑期任务 周报 日报 月报 时间管理能力 合理的学习计划 有学习梯度， 定一下计划吧，比如高数强化，是不是赶得有点紧了， 这也是一门学问。 做完之后能给自己带来多少收益。 学习技巧 给别人讲解 模拟考对自己狠一点 模拟考就是要严格考自己。该扣分就扣， 复习范围大于考试范围 自拍复习法 外接的支持 后期重要 前期准备好，后期才不慌。 对自己狠点\n引用西游记中： 如果三心二意 就去看西游记。\n得之泰然，\n失之淡然，\n争其必然，\n顺其自然。\n费曼学习法 我有学习动力，掌握方法工具。 及时输出。总结也是一种学习，备周！\n2023年6月26日 22:33:39 # 不知道在搞什么 害!认真复习！\n2023年7月9日 00:20:09 # 或许在朋友圈看到了曾经高三同学的生活近况，想起来过往高三复读的正确性和当下自己问题。或许自己当前的问题，如果踏入了没有复读而是跟高中同学报考同一所学校，然后今年毕业自己当下的问题（心理问题）或许就消散了，我觉得是这样的。或许我复读出省是为了选择更好的学业上的成就，但是我确实暂时也没获得什么成就，也就只有考研这条路。。 两条线，事（学）业线和感情线，当前是在事（学）业线上，还是着眼当下吧，即使没有错过，也会遇到新的问题，起码现在在事业线上，先让这条路开花\n续：\n"},{"id":5,"href":"/docs/chapter01/cpp-stl-intro/","title":"C++ STL","section":"第一章|基础知识储备","content":" 什么是C++标准模板库（STL）？ # 标准模板库 STL（Standard Template Library），是 C++ 标准库的一部分，不需要单独安装，只需要#include 头文件。\nC++ 对模板（Template）支持得很好，STL 就是借助模板把常用的数据结构及其算法都实现了一遍，并且做到了数据结构和算法的分离。\nC++ 语言的核心优势之一就是便于软件的复用。\nC++ 语言有两个方面体现了复用：\n面向对象的继承和多态机制 通过模板的概念实现了对泛型程序设计的支持 C++中的模板，就好比英语作文的模板，只换主题，不换句式和结构。对应到C++模板，就是只换类型，不换方法。\nSTL有什么优势？ # STL封装了很多实用的容器，省时省力，能够让你将更多心思放到解决问题的步骤上，而非费力去实现数据结构诸多细节上，像极了用python时候的酣畅淋漓。\nSTL到底有什么？ # 六大部件:\n容器 分配器 算法 迭代器 适配器 仿函数 自定义 # vector 矢量 # 定义 # 使用前需添加头文件\n#include\u0026lt;vector\u0026gt; using namespace std; 像定义变量一样定义vector变量：\nvector\u0026lt;类型名\u0026gt; 变量名; 类型名可以是int、double、char、struct，也可以是STL容器：vector、set、queue。\nvector\u0026lt;int\u0026gt; name; vector\u0026lt;double\u0026gt; name; vector\u0026lt;char\u0026gt; name; vector\u0026lt;struct node\u0026gt; name; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; name; vector数组就是一个一维数组,如果定义成vector数组的数组，那就是二维数组**。**\nvector\u0026lt;int\u0026gt; array[SZIE]; //二维变长数组 在此，我送你一句话非常受用的话：低维是高维的地址。\n二维数组中，它的一维形式就是地址。例如：\n#include \u0026lt;iostream\u0026gt; using namespace std; int main(){ int arr[3][2];//定义一个3行2列的地址 cout\u0026lt;\u0026lt;arr[0]\u0026lt;\u0026lt;endl; //输出arr第1行的地址 cout\u0026lt;\u0026lt;arr[1]\u0026lt;\u0026lt;endl; //输出arr第2行的地址 cout\u0026lt;\u0026lt;arr[2]\u0026lt;\u0026lt;endl; //输出arr第3行的地址 return 0; } 输出：\n0x61fe00 //arr第1行的地址 0x61fe08 //arr第2行的地址 0x61fe10 //arr第3行的地址 所以，vector容器也可以这样理解。\n常用函数 # 1.构造函数 # vector():创建一个空vector vector(int nSize):创建一个vector,元素个数为nSize vector(int nSize,const t\u0026amp; t):创建一个vector，元素个数为nSize,且值均为t vector(const vector\u0026amp;):复制构造函数 vector(begin,end):复制[begin,end)区间内另一个数组的元素到vector中 2.增加函数 # void push_back(const T\u0026amp; x):向量尾部增加一个元素X iterator insert(iterator it,const T\u0026amp; x):向量中迭代器指向元素前增加一个元素x iterator insert(iterator it,int n,const T\u0026amp; x):向量中迭代器指向元素前增加n个相同的元素x iterator insert(iterator it,const_iterator first,const_iterator last):向量中迭代器指向元素前插入另一个相同类型向量的[first,last)间的数据 3.删除函数 # iterator erase(iterator it):删除向量中迭代器指向元素 iterator erase(iterator first,iterator last):删除向量中[first,last)中元素 void pop_back():删除向量中最后一个元素 void clear():清空向量中所有元素 4.遍历函数 # reference at(int pos):返回pos位置元素的引用 reference front():返回首元素的引用 reference back():返回尾元素的引用 iterator begin():返回向量头指针，指向第一个元素 iterator end():返回向量尾指针，指向向量最后一个元素的下一个位置 reverse_iterator rbegin():反向迭代器，指向最后一个元素 reverse_iterator rend():反向迭代器，指向第一个元素之前的位置 5.判断函数 # bool empty() const:判断向量是否为空，若为空，则向量中无元素 6.大小函数 # int size() const:返回向量中元素的个数 int capacity() const:返回当前向量所能容纳的最大元素值 int max_size() const:返回最大可允许的vector元素数量值 7.其他函数 # void swap(vector\u0026amp;):交换两个同类型向量的数据 void assign(int n,const T\u0026amp; x):设置向量中前n个元素的值为x void assign(const_iterator first,const_iterator last):向量中[first,last)中元素设置成当前向量元素 访问容器内元素 # vector一般有两种访问方式：\n（1）通过下标访问\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; int main(){ vector\u0026lt;int\u0026gt; vi; vi.push_back(1); cout\u0026lt;\u0026lt;vi[0]\u0026lt;\u0026lt;endl; return 0; } 输出：\n1 （2）通过迭代器访问\n迭代器（iterator）可以理解为指针：\nvector\u0026lt;类型名\u0026gt;::iterator 变量名; 例如：\nvector\u0026lt;int\u0026gt;::iterator it; vector\u0026lt;double\u0026gt;::iterator it; 举个例子：\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; int main(){ vector\u0026lt;int\u0026gt; v; for (int i = 0; i \u0026lt; 5; i++) { v.push_back(i); } //v.begin()返回v的首元素地址 vector\u0026lt;int\u0026gt;::iterator it=v.begin(); for (int i = 0; i \u0026lt; v.size(); i++) { cout\u0026lt;\u0026lt;it[i]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } return 0; } 输出：\n0 1 2 3 4 for循环迭代部分也可以写成：\nvector\u0026lt;int\u0026gt;::iterator it=v.begin(); for (int i = 0; i \u0026lt; v.size(); i++) { cout\u0026lt;\u0026lt;*(it+i)\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } 也即是\nit[i] = *(it+i) //这两个写法等价 这是简单的常识，以后不再提及。\n与此同时，迭代器与for循环还有一种优雅的写法。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; int main(){ vector\u0026lt;int\u0026gt; v; for (int i = 0; i \u0026lt; 5; i++) { v.push_back(i); } //vector的迭代器不支持it\u0026lt;v.end()的写法，因此循环条件只能it!=v.end() for (vector\u0026lt;int\u0026gt;::iterator it=v.begin(); it!=v.end();it++) { cout\u0026lt;\u0026lt;*it\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } return 0; } 此种写法与遍历字符串有异曲同工之妙：\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; int main(){ string str; str=\u0026#34;Hello World\u0026#34;; for (int i = 0; str[i]!=\u0026#39;\\0\u0026#39;; i++) { cout\u0026lt;\u0026lt;str[i]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } return 0; } 输出：\nH e l l o W o r l d vector常用函数实例解析 # push_back() pop_back() size() clear() insert() erase() （1）push_back()\nvoid std::vector\u0026lt;int\u0026gt;::push_back(const int \u0026amp;__x) 见名知意，push_back(item)就是在vector后面添加一个元素item。\n用例：\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; int main(){ vector\u0026lt;int\u0026gt; v; for (int i = 0; i \u0026lt; 5; i++) { v.push_back(i); } for (int i = 0; i \u0026lt; v.size(); i++) { cout\u0026lt;\u0026lt;v[i]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } return 0; } 以前还要为定长数组内存分配而苦恼时，现在只需要无脑push_back()就好了。\n（2）pop_back()\nvoid std::vector\u0026lt;int\u0026gt;::pop_back() push和pop时一对反义词，学过数据结构的人都知道，栈元素的压入和弹出就是push和pop。\n须知，pop_back()一次弹出一个元素，vector容器就会减少一个预算。\n之所以叫容器，就是能往里面装一个一个的元素。\n用例：\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; int main(){ vector\u0026lt;int\u0026gt; v; for (int i = 0; i \u0026lt; 5; i++) { v.push_back(i); } cout\u0026lt;\u0026lt;\u0026#34;pop_back前:\u0026#34;\u0026lt;\u0026lt;endl; for (int i = 0; i \u0026lt; v.size(); i++) { cout\u0026lt;\u0026lt;v[i]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } cout\u0026lt;\u0026lt;endl; v.pop_back(); cout\u0026lt;\u0026lt;\u0026#34;pop_back后:\u0026#34;\u0026lt;\u0026lt;endl; for (int i = 0; i \u0026lt; v.size(); i++) { cout\u0026lt;\u0026lt;v[i]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } return 0; } 输出：\npop_back前: 0 1 2 3 4 pop_back后: 0 1 2 3 （3）size()\nstd::size_t std::vector\u0026lt;int\u0026gt;::size() szie()返回vector中所含元素的个数，时间复杂度为O(1)。\n用例：\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; int main(){ vector\u0026lt;int\u0026gt; v; for (int i = 0; i \u0026lt; 5; i++) { v.push_back(i); } cout\u0026lt;\u0026lt;v.size()\u0026lt;\u0026lt;endl; return 0; } 输出：\n5 （4）clear()\nvoid std::vector\u0026lt;int\u0026gt;::clear() clear()用于一键清空vector中的所有元素，时间复杂度为O(N)，其中N为vector中原属和元素的个数。\n用例：\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; int main(){ vector\u0026lt;int\u0026gt; v; for (int i = 0; i \u0026lt; 5; i++) { v.push_back(i); } for (int i = 0; i \u0026lt; v.size(); i++) { cout\u0026lt;\u0026lt;v[i]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } v.clear(); cout\u0026lt;\u0026lt;endl; cout\u0026lt;\u0026lt;\u0026#34;size = \u0026#34;\u0026lt;\u0026lt;v.size()\u0026lt;\u0026lt;endl; return 0; } 输出：\n0 1 2 3 4 size = 0 （5）insert()\ninsert(__position,__x); insert(要插入的地址，要插入的元素); 参数： __position：– A const_iterator into the %vector. __x:– Data to be inserted. 与push_back()无脑在尾部添加元素不同的是，insert()是根据指定位置在vector中插入元素。\n用例：\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; int main(){ vector\u0026lt;int\u0026gt; v; for (int i = 0; i \u0026lt; 5; i++) { v.push_back(i); } for (int i = 0; i \u0026lt; v.size(); i++) { cout\u0026lt;\u0026lt;v[i]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } v.insert(v.begin()+2,-1); //将-1插入v[2]的位置 cout\u0026lt;\u0026lt;endl; for (int i = 0; i \u0026lt; v.size(); i++) { cout\u0026lt;\u0026lt;v[i]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } return 0; } 输出：\n0 1 2 3 4 0 1 -1 2 3 4 （6）erase()\nerase(__position); 同样，与clear()简单粗暴清空vector不同的是erase()，删除指定位置的元素。\nerase()有两种用法：\n删除一个元素 删除一个区间内的元素 1.删除一个元素\nerase(__position); 用例：\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; int main(){ vector\u0026lt;int\u0026gt; v; for (int i = 0; i \u0026lt; 5; i++) { v.push_back(i); } for (int i = 0; i \u0026lt; v.size(); i++) { cout\u0026lt;\u0026lt;v[i]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } //删除v[3] v.erase(v.begin()+3); cout\u0026lt;\u0026lt;endl; for (int i = 0; i \u0026lt; v.size(); i++) { cout\u0026lt;\u0026lt;v[i]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } return 0; } 输出：\n0 1 2 3 4 0 1 2 4 2.删除一个区间内的元素\nerase(__positionBegin,__positionEnd); 即是删除[__positionBegin, __positionEnd)区间内的元素，注意：是左闭右开！\n用例：\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; int main(){ vector\u0026lt;int\u0026gt; v; for (int i = 0; i \u0026lt; 5; i++) { v.push_back(i); } for (int i = 0; i \u0026lt; v.size(); i++) { cout\u0026lt;\u0026lt;v[i]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } //删除v[1]到v[4]的元素 v.erase(v.begin()+1,v.begin()+4); cout\u0026lt;\u0026lt;endl; for (int i = 0; i \u0026lt; v.size(); i++) { cout\u0026lt;\u0026lt;v[i]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } return 0; } 输出：\n0 1 2 3 4 0 4 vector常见用途 # （1）储存数据\nvector本身可以作为数组使用，而且在一些元素个数不确定的场合可以很好地节省空间。\n（2）用邻接表存储图\n使用vector实现邻接表，更为简单。\nset # set（集合），是一个内部自动有序且不含重复元素的容器。\nset可以在需要去重复元素的情况大放异彩，节省时间，减少思维量。\n要使用set，需要添加头文件：\n#include \u0026lt;set\u0026gt; using namespace std; 定义 # 像定义变量一样定义set变量：\nset\u0026lt;类型名\u0026gt; 变量名; 类型名可以是int、double、char、struct，也可以是STL容器：vector、set、queue。\n用例：\nset\u0026lt;int\u0026gt; name; set\u0026lt;double\u0026gt; name; set\u0026lt;char\u0026gt; name; set\u0026lt;struct node\u0026gt; name; set\u0026lt;set\u0026lt;int\u0026gt;\u0026gt; name; set数组的定义和vector相同：\nset\u0026lt;类型名\u0026gt; array[SIZE]; 例如：\nset\u0026lt;int\u0026gt; arr[10]; 访问set容器内的元素 # set只能通过迭代器(iterator)访问：\nset\u0026lt;int\u0026gt;::iterator it; set\u0026lt;char\u0026gt;::iterator it; 这样，就得到了迭代器it，并且可以通过*it来访问set里的元素。\n注意：\n除了vector和string之外的STL容器都不支持*(it+i)的访问方式，因此只能按照如下方式枚举：\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;set\u0026gt; using namespace std; int main() { set\u0026lt;int\u0026gt; st; st.insert(5); st.insert(2); st.insert(6); for (set\u0026lt;int\u0026gt;::iterator it = st.begin(); it != st.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; endl; } return 0; } 输出：\n2 5 6 我们可以看到，原本无序的元素，被插入set集合后，set内部的元素自动递增排序，并且自动去除了重复元素。\nset常用函数实例解析 # （1）insert()\n插入元素十分简单。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;set\u0026gt; using namespace std; int main() { set\u0026lt;char\u0026gt; st; st.insert(\u0026#39;C\u0026#39;); st.insert(\u0026#39;B\u0026#39;); st.insert(\u0026#39;A\u0026#39;); for (set\u0026lt;char\u0026gt;::iterator it = st.begin(); it != st.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; endl; } return 0; } （2）find()\nfind(value)返回的是set中value所对应的迭代器，也就是value的指针（地址）。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;set\u0026gt; using namespace std; int main() { set\u0026lt;int\u0026gt; st; for (int i = 1; i \u0026lt;= 3; i++) { st.insert(i); } set\u0026lt;int\u0026gt;::iterator it = st.find(2); //在set中查找2，返回其迭代器 cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; endl; // 以上可以直接x携程 cout \u0026lt;\u0026lt; *(st.find(2)) \u0026lt;\u0026lt; endl; return 0; } 输出：\n2 2 （3）erase()\nerase()有两种用法：删除单个元素、删除一个区间内的所有元素。\n1.删除单个元素\n删除单个元素有两种方法：\nst.erase(it)，其中it为所需要删除元素的迭代器。时间复杂度为O(1)。可以结合find()函数来使用。 #include \u0026lt;iostream\u0026gt; #include \u0026lt;set\u0026gt; using namespace std; int main() { set\u0026lt;int\u0026gt; st; st.insert(100); st.insert(200); st.insert(100); st.insert(300); // 删除单个元素 st.erase(st.find(100)); //利用find()函数找到100,然后用erase删除它 st.erase(st.find(200)); for (set\u0026lt;int\u0026gt;::iterator it = st.begin(); it != st.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; endl; } return 0; } 输出：\n300 st.erase(value)，value为所需要删除元素的值。其时间复杂度为O(logN)，N为set内的元素个数。 #include \u0026lt;iostream\u0026gt; #include \u0026lt;set\u0026gt; using namespace std; int main() { set\u0026lt;int\u0026gt; st; st.insert(100); st.insert(200); st.insert(100); st.insert(300); // 删除单个元素 st.erase(100); for (set\u0026lt;int\u0026gt;::iterator it = st.begin(); it != st.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; endl; } return 0; } 输出：\n200 300 2.删除一个区间内的所有元素\nst.erase(iteratorBegin , iteratorEnd)可以删除一个区间内的所有元素。\n其中iteratorBegin为所需要删除区间的起始迭代器\niteratorEnd为所需要删除区间的结束迭代器的下一个地址\n也即是**[iteratorBegin,iteratorEnd)**\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;set\u0026gt; using namespace std; //2.删除一个区间内的所有元素 int main() { set\u0026lt;int\u0026gt; st; st.insert(100); st.insert(200); st.insert(100); st.insert(300); set\u0026lt;int\u0026gt;::iterator it = st.find(200); st.erase(it, st.end()); for (it = st.begin(); it != st.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; endl; } return 0; } 输出：\n100 （4）size()\n不难理解，szie()用来实时获得set内元素的个数，时间复杂度为O(1)。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;set\u0026gt; using namespace std; int main() { set\u0026lt;int\u0026gt; st; st.insert(2); st.insert(5); st.insert(4); cout \u0026lt;\u0026lt; st.size() \u0026lt;\u0026lt; endl; return 0; } 输出：\n3 string # map # 定义 # map # map\u0026lt;int,int\u0026gt; maps; 相关函数 # maps.insert() 插入 maps[key] = value;数组方式插入 maps.find(num) 查找一个元素 maps.clear()清空 maps.szie()长度 maps.begin()返回指向map头部的迭代器 maps.end()返回指向map末尾的迭代器 maps.erase(num)删除一个元素。 unordered_map # 与map容器仅有一点不同的是，unordered_map是无序的。其底层采用的是哈希表存储，不会自动对存储的键值对进行排序。\nqueue # priority # stack # pair # algorithm # "},{"id":6,"href":"/docs/chapter03/CO/cpt02/","title":"第二章|数据的表示与运算","section":"计算机组成原理","content":" 移位运算 # 移位：通过改变各个数码位和小数点的相对位置，从而改变各数码位的位权。可用移位运算实现乘法、除法。 注意：由于原、反、补码位数有限，因此某些时候算数移位不能精确等效乘法、除法\n算数移位 # 原码 # 原码的算数移位 符号位保持不变，仅对数值位进行移位。 右移：高位补0，低位舍弃。 若舍弃的位=0，则相当于÷2；若舍弃的位≠0，则会丢失精度。 左移：低位补0，高位舍弃。 若舍弃的位=0，则相当于×2；若舍弃的位≠0，则会出现严重误差。\n反码 # 反码的算数移位 正数的反码与原码相同， 因此对正数反码的移位运算也和原码相同。\n右移：高位补0，低位舍弃。 左移：低位补0，高位舍弃。 负数的反码数值位与原 码相反，因此负数反码的移位运算规则如下， 右移：高位补1，低位舍弃。 左移：低位补1，高位舍弃。 补码 # 补码的算数移位 正数的补码与原码相同， 因此对正数补码的移位运算也和原码相同。\n右移：高位补0，低位舍弃。 左移：低位补0，高位舍弃。 负数补码的算数移位规则如下： 右移（同反码）：高位补1，低位舍弃。 左移（同原码）：低位补0，高位舍弃。 总结 # 逻辑移位 # 逻辑右移：高位补0，低位舍弃。 逻辑左移：低位补0，高位舍弃。 可以把逻辑移位看作是对“无符号数”的算数移位。\n循环移位 # 分为两种情况： 不带进位位：用移出的位补充到添补位。 带进位位：移出的位放到进位位，原进位位放到添补位。\n运算器 # ACC： 累加器，用于存放操作数，或运算结果。 MQ： 乘商寄存器，在乘、除运算时，用于存放操作数或运算结果。 X： 通用的操作数寄存器，用于存放操作数 ALU：算术逻辑单元，通过内部复杂的电路实现算数运算、逻辑运算\n加 减 乘 除 ACC 被加数、和 被减数、差 乘积高位 被除数、余数 MQ 乘积、乘积低位 商 X 加 减 被乘数 除数 定点数的表示 # 定点数的运算 # 定点数的小数点一般是固定的。\n原码的除法 # 符号位单独处理，即对除数与被除数的符号位进行异或运算。\n恢复余数法 # 数值位取绝对值进行除法运算，符号位单独处理（进行异或运算）。 先默认商1，如果余数为负数即首位为1，则修正为商0。\n举例 # 设机器字长为5位（含1位符号位，n=4） x=0.1011，y=0.1101，采用原码恢复余数法求x/y |x|=0.1011，|y|=0.1101，[|y|]补=0.1101，[−|y|]补=1.0011 计算机很傻，会先默认上商1，如果 搞错了再改上商0。并“恢复余数”。\n整体流程 # 商先上1，即MQ的最后一位先赋为1 求余数： ACC中的内容 减去 除数即通用寄存器中的内容。 ACC 的内容 传入ALU 然后加上除数相反数的补码，完成减法运算，再返回ACC ACC + [−|y|]补 \u0026ndash;\u0026gt; ACC 判断！ 若ACC的值为正数，则商1正确。 若ACC的值为负数，即第一位为1，则判定应该商0而非商1。 此时应该恢复余数，即ACC加上除数的补码，恢复余数。 ACC + [|y|]补 \u0026ndash;\u0026gt; ACC 逻辑左移 ACC与MQ中的数整体逻辑左移， ACC中的余数丢去最高位，末尾补0。 MQ中的商左移，末尾补上新的待计算位。 一般5位机器数中MQ5位，则最后的商就只有5位，ACC中最终余数5位。 手算模拟 # 总结 # 左移动n位确定n位商\n加减交替法（不恢复余数法） # 前边同恢复余数法，就是在发现余数为负时，如何处理。 恢复余数法的方法是先加上[|y|]补，然后左移，然后处理下一位时再加上[-|y|]补，然后商1，再判断余数正负。\n记a为当前需要恢复余数的余数（为负数，因为负数才需要恢复） b为除数绝对值的补码。 则操作为 a、a + b、2(a+b)、2(a+b) - b = 2a + b 则以上操作可以直接简化为，发现余数为负，则直接先左移一位然后加上[|y|]补，可以达到同样的效果，还少了一步操作。 注意！ 如果最后一个数得到的结果为负，则需要加上|y|]补来恢复余数！ 加/减 n + 1次，先减 减完如果为余数正则确定一位商，否则需要一次加法运算才可以确定。如果最后结果余数为负数，则需要再加一次，固为n + 2 次。 移位 n 次，每次得到商都需要左移。\n补码的除法 # 加减交替法 # 与加减交替法有点类似。补码运算一般采用双符号位运算，符号位也参与运算。 补码除法：\n符号位参与运算。 被除数/余数、除数采用双符号位 余数和除数同号，商1，余数 左移一位减去除数； 余数和除数异号，商0，余数 左移一位加上除数。 重复n次\n举例 # 设机器字长为5位(含1位符号位，n=4)，x = +0.1000，y = - 0.1011，采用补码加减交替除法求x/y。 [x]补 = 00.1000，[y]补 = 11.0101，[-y]补 = 00.1010\n主要步骤 # 余数和除数同号，商1，余数 左移一位减去除数； 余数和除数异号，商0，余数 左移一位加上除数。 重复n次\n除法总结 # 数据的存储与排列 # 大小端模式 # 一般数字分为最高有效字节MSB和最低有效字节LSB 例如： 4字节的int 存储 01 23 45 67H其十进制数为19088743D 其中01为最高有效字节，67为最低有效字节。\n大端模式 # 大端模式一般适合人类正常阅读。 按照地址从左往右排列，绝大部分人类阅读一般是从左往右，比如你看这个数字42316，都会认为4的位权是最大的，表示4万，然后是2千，3百等等。这就是大端模式，地址低位存数据高位。\n小端模式 # 小端模式适合机器读取数据。 机器读取数据时，一般是从低地址往高地址读取对应地址上的数据。然后CPU对数据处理时一般是进行加法运算，那么首先读取某个数据的低地址位更好，因为加法都是从低位开始加，不断加到高位。这就是小端模式，地址低位存数据低位。 边界对齐 # 一句话：K字节大小的数据必须要存储在K的整数倍的地址上 现代计算机通常是按字节编址，即每个字节对应一个地址。通常也支持按字，按半字，按字节寻址。 假设存储字长为32位，则1个字为32bit，半字为16bit。每次访存只能读/写1个字。 所谓按字节寻址是，每次往后1B，即8bit；所谓按半字寻址是，每次往后2B，即16bit；寻找第几号编址就是往后几次，不同编址方式也可以转换，例如按字寻址2号位的地址就相当于按字节编址8号位的地址（逻辑左移2位），一般都是最终转换为按字节编址。 所谓边界对齐，就是4B的数据即4个字节的数据（int，float）只能占用4的整数倍数的地址，2B就只能占用2的整数倍的地址。而计算机每次读取数据都是读一个字或一个半字，也就是2B或1B，如果不使用对齐，在访问图2.11中的半字1时，需要先访问第二个半字的高位，然后再访问第三个半字的低位，需要访问两次，费时间。边界对齐是以空间换时间的。\n浮点数的表示 # 定点数的缺陷：定点数表示的数字范围有限，不能无限制增加范围。 浮点数与科学记数法表示的思想类似。 例如用科学记数法表示的3.026 * 1011，可以转换为+11+3.026。其中11为阶码，3.026表示尾数。 阶码反映数据范围，以及小数点的位。 尾数反映数值部分的位数，与数值的精度。 例如其中的b = 0 10 0 01001 实际表示的数据应为+1.001，但是b丢失了最后一位，导数b最终的数为+ 1.000。但是为了避免精度损失最少，并且表示的范围尽量大，那就应该对浮点数进行规格化！\n浮点数规格 # 与科学记数法类似，保证尾数部分的最高位不是无效位（不表示数据信息的位），以上图中的b为例，若b = 0 01 0 1001，即b = 21 * (2-1 + 2-4) = +1.001 正确表示出了数据。这种情况为左规，尾数算数左移一位，阶码减1。同理当用当前的方法表示时，进行运算后，尾数部分溢出，则需要右规，即尾数算数右移，阶码加1。 规格化 # 浮点数表示的范围也有限，对浮点数规格化一般称对尾数的规格化，注意补码表示最高位和符号位是不同的。 所以有没有一种规格，能够确定阶码，尾数用原码还是补码，各多少位呢？下面就来了1\nIEEE754表示 # IEEE754就是一种标准！\n浮点数的加减运算 # "},{"id":7,"href":"/docs/notes/thinknote/00002/","title":"一些话","section":"小记","content":"2023-07-03 01:02:34+08:00 感觉自己还是没有十分投入吧，有点自己骗自己的感觉。学习考研没那么容易，明天再接再厉，找回状态。\n"},{"id":8,"href":"/docs/chapter03/CO/cpt03/","title":"第三章|存储系统","section":"计算机组成原理","content":" 存储器概述 # 存储器的层次结构 # 寄存器 Cache(高速缓冲存储器) 主存(内存) 磁盘(辅存) 磁带、光盘。\n主存-辅存：实现了虚拟存储系统，结果主存容量不够的问题。辅存与主存内容交换一般是由硬件和操作系统完成，涉及到操作系统中的页面置换算法。\nCache-主存：解决了主存与CPU速度不匹配的问题。是由硬件自动完成的。计算机组成原理主要关注这部分。\n辅存的数据必须调入主存后才能被CPU访问。\n频繁被访问的数据可以复制一份到Cache中，更方便CPU读取。\nCPU进行一些加减运算时，操作数就存在寄存器，寄存器访问更快，但是其价格贵，数量更少。 存储器的分类 # 按层次分类 # 高速缓存\n主存储器\n辅助存储器\n按存储介质分类 # 半导体存储器：主存、Cache\n磁表面存储器：磁盘、磁带\n光存储器：光盘\n按存取方式分类 # 随机存取存储器（Random Acess Memory）： 读写任何一个存储单元所需时间都一样，与物理位置无关。 顺序存取存储器（Sequential Acess Memory）： 读写每一个存储单元所需的时间取决于存储单元所在的物理位置。 直接存取存储器（Direct Acess Memory）： 既有随机读取的特性，又有顺序读取的特性，先随机选取目标数据扇区，再顺序方式读取数据。\n顺序存取和直接读取都是串行访问存储器，读写某个存储单元所需时间与存储器单元的物理位置有关。 相联存储器（Associative Memory）： 即可以按内容访问的存储器，也可以按照内容检索到存储位置进行读写，“快表”就是一种。 按信息的更改性分类 # 读写存取器：可读可写（磁盘，内存，Cache等） 只读存储器（Read Only Memory）：只能读，不能写。（BIOS写到ROM上，实体音乐专辑存储到CD-ROM上）\n按信息的可保存性分类 # 易失性存储器：断电后存储信息消失，（Cache、主存） 非易失性存储器：断电后存储信息依旧保存，（磁盘、光盘） 破坏性读出：信息读出后，原存储信息被破坏。（DRAM芯片，读出数据后要进行重写） 非破坏性读出：信息读出后，原存储信息不被破坏。（SRAM、磁盘、光盘）\n存储器的性能指标 # 存储容量：存储字数 * 字长（如1M*8位) MDR位数反映存储字长，MAR位数反映存储字数。\n单位成本：每位(bit)价格 = 总成本 / 总容量\n存储速度：数据传输率=数据的宽度/存储周期。 数据宽度位存储字长。\n存储周期包括存取时间和恢复时间。\n存取时间是从一次启动存储器操作到完成该操作所经历的时间，分为读出时间和写入时间。\n存储周期也被称为读写周期或访问周期。指存储器进行一次完整的读写操作所需的全部时间，即连续两次独立地访问存储器操作之间所需的最小时间间隔。\n主存带宽又称为数据传输率。表示每秒从主存进出信息的最大数量。单位为字、字节Byte、位bit 每秒。\n主存储器 # 主存储器的基本组成 # 基本半导体元件 # MOS管：施加的电压达到某个阈值，MOS管就可以连通。\nMOS管接通后，电容与外部导线连接。\n电容如果存储的电荷在放电后电荷流出，外部导线监测到高电平即信号1，若电容不存储电荷，则外部导线监测到低电平即信号0。\n存储芯片的结构 # 存储字长与每个存储体设计有关。\n与CPU相连的地址总线连通MAR，然后通过译码器连接存储的单元的字选线来选择。字选线 与CPU与相连的数据总线宽度未存储字长，即图中绿线。位选线。 存储体总容量为 存储单元个数 * 存储字长。 控制电路 片选线：一个内存条可能包含多个存储芯片，用片选线来判断选择的存储芯片编号。\n读写控制线：可能为两根，一根控制写，一根控制读，或只用一根。向外暴露的引脚个数。 上图中每个线都会对应一个金属引脚。 n位地址 对应 2n的存储单元。 8K * 8位 即213 * 8bit容量，地址线有13位，数据线有8位。\n寻址 # 现代计算机通常按字节编址，即每个字节对应一个地址。\n对于总容量为1KB的存储体。地址线为10条，数据线为8条\n按字节寻址，1K个单元，每个单元存储1B的二进制数据。 按字寻址，将四个连续的字节合并为一个字，一次读取一个字，即256个单元，每个单元4B，字节地址算数左移两位转换为按字寻址的地址。 按半字寻址，将连续的两个字节合并为一个字。总共512个单元，每个单元存储2B的二进制数据。 按双字寻址，将连续的八个字节合并为一个字。总共128个单元，每个单元存储8B的二进制数据。 SRAM与DRAM # 静态RAM与动态RAM DRAM一般用于主存，SRAM一般用于Cache\n存储元件不同而导致的特性差异 # 栅极电容 # 电容放电后，信息会被破坏，是破坏性读出，读出后应该对数据重写。 每个存储元制造成本低，集成度高，功耗低。\n电容中的电荷信息即使不读取也会丢失，一般只能维持2ms，所以需要频繁对电容进行刷新。\n双稳态触发器 # 有两种稳定的状态： 1：A高电平，B低电平。\n0：A低电平，B高电平。\n读出数据后，触发器状态依旧稳定，读数据为非破坏性读出，无需重写。\n每个存储元制造成本高，器件多，集成度低，功耗高。\n两种器件的特性对比： # 两种断电之后信息都会消失，都是易失性读出。\nDRAM的刷新 # 多久需要刷新一次？ # 刷新周期一般为2ms，\n每次刷新多少存储单元？ # 以行为单位，每次刷新一行存储单元。\n简单模型为存储单元按号排序，如果采用20位地址线就，那么就要排0到220 - 1号存储单元，也就是需要出220条线，显然很难实现。\n如果用行列地址来定址，那么只需要一个行地址译码器和一个列地址译码器，每个译码器只需要确定0到1023号，相比来说减少了很多。地址分为行地址和列地址，前半部分为行地址，后半部分为列地址。减少了连通线的数量。 如何刷新？ # 有相关硬件支持，由存储器独立完成，不需要CPU控制。每次读取一行存储单元的信息后，重新写入，占用1个读/写周期。\n在什么时候刷新呢？ # 假设DRAM内部结构排列成128x128的形式，读写周期为0.5us，2ms共2ms/0.5us = 4000个周期。\n分散刷新 每次读写玩都刷新一行，系统的存储周期会变长，前0.5us时间用于正常读写，后0.5us时间用于刷新，系统存储周期变为1us。\n集中刷新 选择2ms集中安排时间全部刷新，系统的存储周期不变，但有一段时间专门用于刷新，此时无法访问存储器，称之为“死区”\n异步刷新 2ms内每行刷新一次即可-\u0026gt; 2ms内需要产生128次刷新请求即，每隔2ms/128 = 15.6us一次，而每15.6us就有0.5us的死时间，相比集中刷新，异步刷新更分散。 DRAM的地址线复用技术 # 由上边可知，DRAM如果存储单元过多，会导致译码器所需连接线过多，所以采用了行列地址来定址，每次刷新都是可以直接刷新一行，根据这个特性，可以在送行列地址时，将地址分为两次发送，一次为行，一次为列，通过相同的引脚输入。这样可以使地址线数减半，芯片引脚中地址引脚数减半。\n关于外接引脚个数 # SRAM 的外部引脚线是片选线和读写控制线，以及地址线和数据线。DRAM的外部引脚线是行选通信号线和列选通信号和线，读写控制线，以及地址线和数据线。\n现在主流主存储器采用SDRAM，DRAM被淘汰了。\n只读存储器ROM # 常见ROM # ROM芯片是非易失性的，即断电后数据不会丢失。\n一般有MROM、PROM、EPROM、闪存、SSD等。\nMROM掩模式只读存储器， 一次写入后，之后任何人不可以重写。可靠性高，集成度高，价格便宜；缺点是灵活性差。 PROM可编程只读存储器， 用户可以用专门的PROM写入器写入信息，写入一次后就不能更改。 EPROM可擦除可编程只读存储器 用户可以通过编程器写入信息，也可以进行多次修改，虽然即可读又可以写，但是编程次数有限，不能替代RAM。\nLIVEPROM 用紫外写照射8-20分钟，可以擦除所有信息。 EEPROM 可以用电擦除的方式，擦除特定的字。 Flash Memory 闪存 由EEPROM发展而来，可用长期保存信息，也可以在线进行快速擦除与重写，既有价格便宜集成度高的特点，断电后可以保存信息，并且可以进行多次快速擦除重写。闪存需要先擦除再写入，因此闪存的“写”速度要比“读”慢。每个存储单元 只需要单个MOS管，位密度比RAM高。 Soil State Drivers 固态硬盘 由控制单元加存储单元（Flash芯片）构成，与Flash核心区别在于控制单元不同，可以进行多次快速擦除重写，速度快，功耗低，价格高。 计算机内重要的ROM # 电脑关机后，RAM不通电，其内部的数据全部丢失，计算机下次开机时需要启动代码，这部分代码存在主板上的一块ROM中（BIOS），逻辑上一般将这一块与主存放到一起。编址时，一般将这块ROM上的内容编写到地址首位。\n双端口RAM和多模块存储器 # 主存的优化技术。\n存取周期 # 如果有多核CPU都要访存，怎么办？CPU读写速度比主存快很多，主存恢复时间太长怎么办？\n双端口RAM（大纲已删） # 主要作用: 优化多核CPU访问同一根内存条的速度。 主存需要有完全两组独立的数据线、地址线、控制线。CPU、RAM中也要有更复杂的控制电路。\n两个端口对同一主存进行操作有4中情况：\n两个端口同时对不同的地址单元存取数据。 允许 两个端口同时对同一的地址单元读出数据。 允许 两个端口同时对同一的地址单元写入数据。 写入错误 两个端口同时对同一的地址单元，一个读入数据，一个写入数据。 读出错误 如果出现3 4的情况，置忙信号，由判断逻辑暂时关闭一个端口（延时接入），另一个端口正常访问。 多模块存储器 # 利用多个结构相同的存储模块的并行工作来提高存储器的吞吐率。\nCPU的速度比存储器快，若同时从存储器中取出n条指令，就可以充分利用CPU资源，提高运行速度。多体交叉存储器就是基于这种思想实现的。\n存储体中存的多数数据是连续存储的，比如数组。\n单体多字存储器 # 单体多字存储器就是，存储器中只有一个存储体，每个存储单元存储m个字，总线宽度也为m个字。一次并行读出m个字，地址必须顺序排列并处于同一存储单元。\n在一个存储周期内，从同一地址取出m条指令，然后将指令逐条送至CPU，即每隔1/m个存取周期，CPU向主存读取一条命令，显然提高了单体存储器的工作速度。但是只有当指令和数据是连续存放的，效果才比较明显。\n多体并行存储器 # 多体并行存储器由多模块组成，每个模块都有相同的容量和存取速度，每个模块都有独立的读写控制电路、地址寄存器、数据寄存器。既能并行工作，也能交叉工作。\n高位交叉编址（顺序方式） # 高位交叉编址其实就还是将多个存储器串行存取，实际上还是顺序存储器。每次读取一次后，需要再等待恢复周期，实际并不能提高效率。\n以连续访问00000-00100地址为例：\n设每个存储体存取周期为T，存取时间为r，T=r + 3r\n则总耗时为5T\n低位交叉编址（交叉方式） # 低位交叉编址是将地址低位设为存储体序号，则CPU读取第一个存储体的内容后，下一个连续地址是下一个存储体的地址，这样可以不用等待前面存储体的恢复周期，从而实现连续读取。 相比高位编址，可以提高效率。 以连续访问00000-00100地址为例：\n设每个存储体存取周期为T，存取时间为r，T=r + 3r 则总耗时为T + 4r。 如果连续读取n个存储字，总耗时为T + (n - 1)r，当n足够大时，读取单个存储字的时间约等于r。\n那么应该取几个“体” # 低位交叉编址的方式类似于“流水线”的方式进行并行存取，一个存储周期内，m体交叉存储器可以提供的数据量为单个的m倍。\n存取周期为T，存取时间为r，为了使刘淑霞不间断，应该保证模块数m \u0026gt;= T/r。 存取周期为T，总线传输周期为r，为了使读取不间断，应该保证模块数m \u0026gt;= T/r。\n如果m = T / r则刚好完美衔接。\n主存储器与CPU的连接 # 存储芯片的基本结构： 译码驱动电路、存储矩阵、读写电路、地址线、数据线、控制线、片选线组成\n存储芯片需要暴露地址总线和数据总线与CPU进行连接，片选线（一般为CS或CE）供CPU选择，读写控制线（一般为WE或WR，也有可能会拆分为两条线WE和OE）控制对存储芯片的读/写。\n单块存储芯片与CPU连接 # 例如给定一个8 * 8位的存储芯片，直接与CPU连接。\n如上图，存储芯片8K* 1位，即主存存储字长1 bit，主存存储单元213个\n13跟地址线A与CPU的16根地址线中的13根地址线接头相连； 写使能线WE与CPU的控制线中的写使能线相连 1跟数据线D与CPU的8根数据线中的一根相连； 片选线CS，由于只有这一个存储芯片与CPU相连接，所以只需要直接给片选线加高电平信号就行 CPU的最大能力能够处理的是是64K * 64位存储器 ，但是只连接一个存储器，CPU的能力没有被充分利用；不论是机器字长还是地址线。 现代计算机 # 现在的计算机一般的MDR与MAR都在CPU中。\n现在的存储体一般都是由多块存储芯片组成的。\n多块存储芯片与CPU连接 # 单个存储器的数据字长为8位，但是现在CPU可以同时处理的位数为32位，甚至64位，为了最大发挥数据总线的性能，每次多取多读可以减少读写次数，那应该怎么办？即数据总线宽度\u0026gt;存储芯片字长。采用位扩展的方法。\n位扩展（扩展位数） # 例如CPU的数据总线是8位，地址总线有16位，现在有若干个地址线有13位，8K*1位的存储芯片，来进行位扩展，使得CPU的数据总线都用上。\n地址总线与每个存储芯片进行串行地连接，数据总线与这些存储芯片进行并行连接。\n扩展主存的字数？采用字扩展的方法。\n字扩展（主存容量扩展） # 例如CPU的数据总线是8位，地址总线有16位，现在有若干个地址线有13位，8K*8位的存储芯片，由于数据总线都已经被占满，所以不需要进行位扩展。但是还有3根地址线是空闲的，我们可以将这三根地址线利用上。充分利用CPU的寻址能力。\n线选法：这三根地址线可以连接到3块存储芯片的片选线上。三根地址线信号为001则代表选择第一块存储芯片，010代表选择第二块。电路简单，地址空间不连续。\n片选法：这三根地址线通过3-8译码器，可以连接到8块存储芯片的片选线上。三根地址线信号为000则代表选择第一块存储芯片，001代表选择第二块。这样就实现了字扩展。\n这样也就是给这8块存储芯片重新编址，类似于高位交叉编址，第一块存储芯片的地址前加上00，范围为000 0000 0000 0000到001 1111 1111 1111，第二块存储芯片的地址范围为010 0000 0000 0000到011 1111 1111 1111以此类推。设计电路较为复杂，但是地址空间连续。\n两种方式的比较：\n字位可以同时扩展！ 关于译码器知识补充 # 译码器也有多个使能信号，CPU可以通过这些使能信号来控制译码器控制片选信号的生效时间。\n译码器 n条线入 ，可以得到2n个信号出。\n高电平有效，低电平有效译码器，与存储芯片连接时需要注意。\n一般连通后，都需要先等一小会，等待信号稳定后再进行片选，读取数据等操作！\n外部存储器 # 外存又称为辅助存储器，目前主要是使用磁表面存储器（机械硬盘，光盘）\n磁表面存储器是使用最广泛的外存储器。所谓磁表面存储，是用某些磁性材料薄薄地涂在金属铝或塑料表面作载磁体来存储信息。根据记录载体的外形，磁表面存储器有磁鼓、磁带、磁盘、磁卡等。而在计算机系统中广泛使用的是磁盘和磁带；特别是磁盘，几乎是稍具规模系统的基本配置。\n针头上有写线圈与读线圈，划过磁层上方后每次读或写1bit数据，如果要读/写8bit数据，需要转为串行。\n优点：\n存储容量大，位价格低 记录介质可以重复使用 记录信息可以长期保存不丢失，甚至可以脱机读档。 非破坏性读出，读出后不需要重新写入。 缺点：\n存取数据慢 机械机构复杂 对工作环境要求较高（不能处于强磁场区域） 既可以作为输入设备，也可以作为输出设备。\n磁盘存储器 # 磁盘设备的组成 # 存储区域 一块磁盘含有若干个记录面，每个记录面划分为若干条磁道，而每条磁道又划分为若干个扇区，扇区（也叫块）是磁盘读写的最小单位，也就是说磁盘按块读取。 磁头数 记录面数，表示磁盘总共有多少个磁头，磁头用于读取/写入盘片上记录面的信息，一个记录面对应一个磁头。 柱面数（从内向外） 表示硬盘每一面上有多少条磁道。在一个盘组中，不同记录面的相同编号（位置）的所有磁道构成一个圆柱面。 扇区数（圆周分为几部分扇形） 表示每一条磁道有多少个扇区 硬盘存储器 磁盘驱动器：\n核心部分是磁头组件和盘片组件。一般为机械硬盘的盘面磁头等一系列组件。\n磁盘控制器：\n是硬盘存储器与主机的接口。一般是机械硬盘背面的电路板。\n磁盘的性能指标 # 磁盘的容量： # 一个磁盘所能存储的字节总数。磁盘容量有非格式化容量和格式化容量之分。\n非格式化容量是指磁记录表面可以李彤的磁化单元总数。是理论上硬盘的容量。 格式化容量是指按照某种特定的记录格式所能存储信息的重量。用户实际能存储数据的容量。\n格式化容量一般比非格式化容量小。\n记录密度： # 道密度 沿磁盘半径方向单位长度上的磁道数。例如60道/cm 位密度 磁盘单位长度上能记录的二进制代码位数。例如600bit/cm 面密度 位密度与道密度的乘积，单位面积上能记录的二进制代码 注意：磁盘上所有磁道记录的信息量是相等的，并非越靠外，磁道越长记录的越多。这也表明每条磁道的位密度不同，越靠外位密度越低，越靠内位密度越高。所以磁盘性能很大情况看最内层磁道所存储的信息量。 平均存取时间 # 平均存取时间 = 寻道时间（磁头移动到要读取的磁道时间） + 旋转延迟时间（磁盘旋转将扇区划到磁头下方） + 传输时间（磁头开始读取数据）。\n数据传输率 # 单位时间内磁盘存储器向主机传送数据的字节数。假设磁盘转速为r，每条磁道容量为N个字节，则数据传输率为r*N 读取一个扇区的时间 ＝ 找磁道的时间 + 找扇区的时间 + 磁头扫过一个扇区的时间。 磁头先移动到 磁道的时间 为寻道时间。磁盘旋转到扇区的时间为旋转延迟时间，一般取磁头扫完整个磁道的时间的一半。 传输时间为 读取的数据除以 数据传输率。\n磁盘地址 # 主机向磁盘控制器发送寻址信息， 驱动器号（电脑可能有多个硬盘） + 盘面/磁道号（从内到外在哪个圈上） + 盘面号（从上到下在哪个盘上） + 扇区号（确定了哪个盘哪个磁道，再找在哪个扇区）\n磁盘的工作过程 # 硬盘的主要操作是寻址，读盘，写盘，每个操作都对应一个控制字，磁盘工作时，第一步是取控制字，第二步是执行控制字。\n磁盘属于机械式部件，其读写操作是串行的，不可能同一时刻读和写，也不可能同时读或写两份数据。\n磁盘阵列（RAID） # RAID （ Redundant Array of Independent Disks ）即独立磁盘冗余阵列，简称为「磁盘阵列」，其实就是用多个独立的磁盘组成在一起形成一个大的磁盘系统，从而实现比单块磁盘更好的存储性能和更高的可靠性。避免数据出现错误导致信息丢失。方案不断更新，安全性越高。 RAID方案常见的可以分为：\nRAID0：无冗余和无校验（无容错能力） RAID1：镜像磁盘阵列（容量减少一半，镜像磁盘互为备份） RAID2：采用纠错的海明码的磁盘阵列 RAID3：位交叉奇偶校验 RAID4：块交叉奇偶校验 RAID5：无独立校验的奇偶校验磁盘阵列 固态硬盘SSD # 原理 # 基于闪存技术，属于电可擦除ROM，即EEPROM。\n组成 # 闪存翻译层 负责翻译逻辑块号，定位到对应页 存储介质，闪存芯片组（包含一个或多个闪存芯片）。 每个芯片包含多个块，每个块包含多个页。 读写性能特性 # 以页为单位进行读写，相当于磁盘的扇区。 以块为单位擦除，擦干净的块，其中的每一页都可以写一次，读无数次。 支持随机访问，系统给定一个逻辑地址，闪存翻译层可以通过电路迅速定位到对应的物理地址。 读快、写慢（涉及擦除等操作），要写入的页如果有数据，则不能写入。需要将块内其他页全部复制到一个新的（擦除过的）块中，再写入新的页。 与机械硬盘相比的特点 # SSD读写快，随机访问性能高，用电路控制访问位置。 SSD安静无噪音，耐摔抗震，能耗低中，造价更贵。 SSD的一个“块”被擦除次数过多（重复写入同一个块）可能会坏掉，而机械硬盘并不会因为写的次数太多而坏掉。 磨损均衡技术 # 将擦除平均分布在各个块上，以提升使用寿命。 动态磨损均衡 写入数据时，优先选择累计擦除次数少的新闪存块。 静态磨损均衡 SSD监测并自动进行数据分配、迁移、让老旧的块承担以读为主的存储任务，让较新的闪存块承担更多的写任务。 高速缓冲器（Cache） # 通过提高存储芯片本身的速度与采用并行存储器结构可以缓解CPU与主存之间速度不匹配的问题。除了这两种方法，在CPU与主存之间设置高速缓冲器（Cache），即将频繁访问的数据放入高速存储器，这样CPU读取经常访问的数据的速度就快多了，这样也可以提高CPU访问指令和数据的速度！\n现在Cache一般都被集成到了CPU中，用SRAM实现，速度快，成本高！\n局部性原理 # 空间局部性：\n在将要使用的信息（指令和数据），很可能与正在使用的信息存在存储空间中相邻的位置，比如使用的数组元素。 时间局部性：\n将要使用的信息中，很可能就是现在正在使用的信息。 比如程序中所使用的循环结构。 基于这个原理不难想到，我们可以把CPU目前访问的地址附近的部分数据存到Cache中。 访问二维数组内容时，如果先访问列与先访问行内容的空间局部性利用较差！ Cache的基本工作原理 # 主存的“块”又叫”页/页框/页面“；Cache的“块”又叫“行”；主存块的大小等于Cache行中数据区的大小。\n主存地址可拆分为（主存块，块内地址）的形式。\n主存和Cache之间是以块为单位来进行交换的。 每次被访问的主存块，一定会被立即调入Cache中。\nCache中的有效位 # 系统启动或复位时，每个Cache行都为空，其中的信息无效，只用从主存中转入了数据才有效，为了说明Cache行中的数据是否有效，每个Cache行需要设定一个有效位。有了有效位，可以通过将有效位置为0来淘汰某Cache行中的主存块，称之为“冲刷”，装入时再置为1。\nCPU找Cache中的访问过程 # CPU在执行程序过程中，需要从主存储器中读取指令或数据时，先检查Cache中有没有要访问的信息，若有则直接从中读取，若没有再从主存中把当前访问信息所在的一个主存块复制到Cache中，因此Cache中的内容是主存中部分内容的副本。\n平均访问时间 # 设tc为访问一次Cache所需的时间，tm为访问一次主存所需要的时间，命中率H为CPU将要访问的信息在Cache中的比率。\n则 Cache-主存 系统中平均访问时间为：\n先访问Cache，找不到再访问主存 t = Htc + (1 - H)(tm + T) 同时访问Cache和主存，若Cache命中则停止访问主存 t = Htc + (1 - H)tm 几个问题 # 如何区分Cache与主存中的数据块对应关系？\n如果Cache满了要怎么办？ CPU修改了Cache中的数据副本，如何确保主存中的数据母本的一致性？\nCache行与主存块之间的映射方式 # Cache中存储的信息为：\n有效位0/1 + 标记（确定在主存中的地址） + 整块数据 如何区分Cache与主存中的数据块对应关系？\n全相联映射（随意映射） # 主存块可以放到Cache中的任意位置。 以某计算机的主存地址空间为256MB，按字节编址，其数据Cache有8个Cache行，行长为64B为例。\nCache块与主存块大小相等，所以主存块的大小也为64B，由于主存是按字节编址，则块内地址共6位，即0到63，主存块号为共22位。\n从而映射到Cache中的标记也有22位，再附加1位有效位，置1证明是有效。\n全相联映射的思想是一个主存块可装到Cache行中的任意一块，每行的标记用于指出该行取自主存的哪个块，主存地址也无需Cache行索引，只有标记和块内地址两个字段。只要有空闲的Cache行，就不会发生冲突。\n优点： Cache空间利用率充分，命中率高；\n缺点：查找“标记”锁定内存块慢，有可能需要比对很多行。不适合容量较大的Cache。\n直接映射 # 每个主存块只能放到一个特定的位置，Cache块号=主存块号 % Cache总块数 只能放到固定的位置。 以某计算机的主存地址空间为256MB，按字节编址，其数据Cache有8个Cache行，行长为64B为例。 Cache块与主存块大小相等，所以主存块的大小也为64B，由于主存是按字节编址，则块内地址共6位，即0到63，主存块号为共22位，其中19位为标记，3位为行号。\n从而映射到Cache中的标记也有19位，再附加1位有效位，置1证明是有效。\n直接映射的优点是容易实现，命中时间短。但是多个块号“同余”的内存块只能映射到同一行Cache，会频繁的调进调出，使其他Cache都空闲，不能够使得Cache存储空间得到充分利用，不够灵活，命中率较低。\n组相联映射 # Cache块分为若干组，每个主存块可以放到特定分组中的任意一个位置，所属分组 = 主存块号 % 分组数。\n以某计算机的主存地址空间为256MB，按字节编址，其数据Cache有8个Cache行，行长为64B为例。\n以2如组相联映射\u0026ndash;2块为一组，分为四组。\nCache块与主存块大小相等，所以主存块的大小也为64B，由于主存是按字节编址，则块内地址共6位，即0到63，主存块号为共22位，其中20位为标记，2位为行号。\n从而映射到Cache中的标记也有20位，再附加1位有效位，置1证明是有效\n对直接映射和全相联映射取长补短，综合效果较好。 n路组相联映射\u0026mdash;\u0026ndash;每n个Cache行为一组。\nCache中主存块的替换算法 # 如果Cache满了要怎么办？\n对于全相联映射，当Cache完全满了时，需要在全局内选择替换哪一块。对于组相联映射，当分组内Cache满了才需要替换，需要在分组内中选择替换掉哪一块。对于直接映射，如果选择的位置非空，那么直接替换，不用考虑替换算法。\n随机替换算法RAND # 若Cache满了，随机选择一块替换！ 设总共有4个Cache块，初始整个Cache行均 为空，采用全相联映射，依次访问主存块{1,2,3,4,1,2,5,1,2,3,4,5}。\n其中替换的块都是随机选择的。 随机算法，实现简单，但是没有考虑局部性原理，命中率低，实际效果很不稳定！\n先进先出算法FIFO # 若Cache满了，则替换最先被调入Cache的块！\n设总共有4个Cache块，初始整个Cache行均 为空，采用全相联映射，依次访问主存块{1,2,3,4,1,2,5,1,2,3,4,5}。\n其中替换的都是当前最先被调入的。实现也较为简单，最开始是按照#0#1#2#3放入Cache，之后轮流替换#0#1#2#3即可。但是依旧没有考虑局部性原理，因为最先被调用的很可能是频繁被访问的，有可能会出现频繁地被环路换出的情况“抖动”。\n最近最少用算法LRU # 为每一个Cache块设置一个“计数器”，用于记录每个Cache已有多久没被访问到了。若Cache满了，则替换”计数器“中数最大的。\n设总共有4个Cache块，初始整个Cache行均 为空，采用全相联映射，依次访问主存块{1,2,3,4,1,2,5,1,2,3,4,5} 命中时，所命中的行的计数器清零，比其低的计数器加一，其余不变。（如访问已有的1，只需把1所在Cache块计数器置零，比它大的没必要加1，因为计数器看大小。这样就可以保证计数器的大小小于4，只需要两个bit存储信息) 未命中且还有空闲行时，新装入的行的计数器置0，其余非空闲行全加1。 未命中且无空闲行时，计数值最大的行的信息被淘汰，新装行的块的计数器置0，其余全加1。 如果频繁访问的主存块数量大于Cache行的数量，则有可能发生“抖动”，如{1,2,3,4,5,1,2,3,4,5,1，2,3,4\u0026hellip;\u0026hellip;}。 最不常用算法LFU # 为每一个Cache块设置一个“计数器”，用于记录每个Cache被访问过多少次。若Cache满了，则替换”计数器“中数最小的。\n设总共有4个Cache块，初始整个Cache行均 为空，采用全相联映射，依次访问主存块{1,2,3,4,1,2,5,1,2,3,4,5} 新调入的块计数器置0，之后每次被访问一次计数器加一。当需要替换时，选择计数器最小的一行。如果有多个计数器最小的行，可以选择按照行号递增或FIFO策略进行替换。\n计数器中的值可能会很大，所以需要多位bit来存储信息。 LFU算法中曾经经常访问的主存块在为了不一定会被用到，比如一段时间内集中使用某段代码，但是这项工作结束后，后续可能很少会用到之前的相关数据。 并没有很好的遵循局部性原理，因此实际运行效果不如LRU。\nCache的一致性问题 # CPU修改了Cache中的数据副本，如何确保主存中的数据母本的一致性？\n写命中 # 写回法 # 当CPU对Cache写命中时，只修改Cache的内容，而不立即写入主存，只有当此时块被换出时才写会主存。Cache行中置一位脏位来表示是否被修改过，没被修改过就不必写回。\n减少了访存次数，但存在数据不一致的隐患。\n全写法（写直通法） # 当CPU对Cache写命中时，必须把数据同时写入Cache和主存，一般使用写缓冲。\n访存次数增加，速度变慢，但更能保持数据一致性。\n可以增加用SRAM制作的写缓冲，利用FIFO策略。CPU对Cache写命中时，对Cache写命中时，同时对写缓冲写入内容。CPU写入SRAM速度是比直接写入主存要快的，SRAM再通过专门的控制电路控制写缓冲逐一写回主存。\n如果操作不频繁，使用写缓冲的效果会较好，但是如果操作频繁，写缓冲会出现饱和并发生阻塞。\n写未命中 # 写分配法 # 当CPU对Cache写不命中时，会将主存中的块调入Cache，在Cache中修改，并通常搭配写回法使用。\n非写分配法 # 当CPU对Cache写不命中时，只写入主存，不调入Cache。只对读操作未命中时才调入Cache。并通常搭配全写法使用。\n多级Cache # 现代计算机常采用多级 Cache，离CPU越近速度越快，容量越小。离CPU越远速度越慢，容量越大。不同级的Cache中也有数据一致性的问题。 虚拟存储器 # 重点在操作系统中体现！\n主存和辅存共同构成了虚拟存储器，两者在硬件和系统软件的共同管理下工作。对于应用级程序员而言，虚拟存储器是透明的。虚拟存储器具有主存的速度和辅存的容量。\n手机和电脑有时候同时运行很多软件，这些软件占用的总内存可能超过了主存空间，但是用起来感觉不卡，这就是启用了虚拟存储器。将一些不常用的资源放到了辅存中。\n虚拟存储器的基本概念 # 页式虚拟存储器 # 操作系统将程序分“页”\n页表 # 逻辑页号 主存块号 外存块号 有效位（装入位） 表示对应页面是否已经被装入主存，1代表该页面已经被从外存调入主存。 访问位（引用位） 配合页面替换算法设置的。 脏位 也叫修改位，用来表示页面是否被修改过，虚拟机制一般采用回写策略。利用脏位来表示是否需要写会磁盘。 快表 # 段式虚拟存储器 # 段页式虚拟存储器 # "},{"id":9,"href":"/docs/chapter03/CO/cpt04/","title":"第四章|指令系统","section":"计算机组成原理","content":" 指令系统 # 指令（机器指令）：是指计算机执行某种操作的命令，是计算机运行的最小功能单位。 一台计算机的所有指令集合构成该计算机的指令系统，也称指令集。一台计算机只能执行自己指令系统中的指令，不能执行其他系统的指令。x86架构（一般是PC机）与ARM架构（一般是手机）的指令集不同。\n指令格式 # 操作码：做什么 地址码（操作数）：对谁做 一条指令通常包括操作码字段和地址码字段两部分。\n一条指令可能包括0、1、2、3、4个地址码。\n根据地址码数量不同，可以将指令分为零地址指令，一地址指令，二地址指令\u0026hellip;..\n零地址指令 # 只有操作码，没有操作数。 这种指令有两种可能：\n不需要操作数的指令，比如空操作指令，停机指令，关中断指令等。 在堆栈计算机中，通常将两个操作数隐含存放在栈顶和次栈顶，计算结构压回栈顶。 一地址指令 # 有操作码和一个操作数。\n只需要单操作数，如加1、减1、取反，求补等 OP(A1)-\u0026gt;A1，完成一条指令需要3次访存：取指-\u0026gt;读A1-\u0026gt;写A1 需要两个操作数， 需要两个操作数，但其中一个操作数隐含在某个寄存器（如隐含在ACC） (ACC)OP(A1)-\u0026gt;ACC，完成一条指令需要2次访存，取指-\u0026gt;读A1 二地址指令 # 常用于需要两个操作数的算术运算、逻辑运算相关指令。\n(A1)OP(A2)-\u0026gt;A1，完成一条指令通常需要访存4次，取指-\u0026gt;读A1-\u0026gt;读A2-\u0026gt;写A1\n三地址指令 # 常用于需要两个操作数的算术运算、逻辑运算相关指令。\n(A1)OP(A2)-\u0026gt;A3，完成一条指令通常需要访存4次，取指-\u0026gt;读A1-\u0026gt;读A2-\u0026gt;写A3\n四地址指令 # (A1)OP(A2)-\u0026gt;A3，A4为下一条将要执行的地址，完成一条指令通常需要访存4次，取指-\u0026gt;读A1-\u0026gt;读A2-\u0026gt;写A3\n正常情况下：取指令后PC+1，指向下一条指令。\n四地址指令：执行指令后，将PC值修改为A4所指地址。\nn位地址码的直接寻址范围为2n ，若指令总长度固定不变，则地址吗数量越多，寻址能力越差。\n指令分类 # 按指令长度分类 # 例如双字长指令在取指时需要两次访存 定长指令字结构： 指令系统中所有指令的长度都相等。定长操作码可以简化计算机硬件设计，提高指令译码和识别速度。 变长指令字结构： 指令系统中各种指令的长度不等。\n按操作码长度分类 # 定长操作码： 指令系统中所有指令的操作码长度都相同。 例如n位操作码，最多支持2n条指令。 可变长操作码： 指令系统中所有指令的操作码长度可变。 按操作类型分类 # 数据传送 （数据传送类） LOAD 把存储器中的数据放到寄存器中 STORE 把寄存器中的数据放到存储器中 算数逻辑运算 （运算类） 算数运算：加、减、乘、除、增一、减一、求补、浮点运算、十进制运算等\n逻辑运算：与或非异或位操作、位测试、位清除、位求反。 移位操作 （运算类） 算术移位、逻辑移位、循环移位（带进位和不带进位） 转移操作 （程序执行流的改变） 无条件转移 JMP\n条件转移 JZ：结果为0；JZ：结果溢出；JC：结果有进位； 调用和返回 CALL和RETURN 陷阱和陷阱指令 输入输出操作 （输入输出类） CPU寄存器与IO端口之间的数据传送（端口即IO接口中的寄存器） 扩展操作码指令格式 # 为了使指令字长有限的前提下仍保持比较丰富的指令种类，可采取可变长操作码，即全部指令的操作码字段的位数不固定，且分散地放在指令字的不同位置上。 举例：\n设计扩展操作码指令格式时，必须注意：\n不允许短码是长码的前缀，即短操作码不能与长操作码的前面部分的代码相同（类哈夫曼编码） 各指令的操作码一定不能重复 通常情况对于使用频率较高的指令，分配较短的操作码，对使用频率较低的指令，分配较长的操作码，从而尽可能减少指令译码和分析的时间。 扩展操作码举例： 对于三地址指令，前四位为操作码，后十二位为三个操作数。操作码从0000开始到1110，留1111一种提供给三地址指令扩展。共有16-1 = 15种状态。 对于二地址指令，前5-8位为操作码，后八位为两个操作数，操作码从0000-1011，留下1100、1101、1110、1111四种提供给一地址指令扩展，共有1* 16 - 4= 12种。 对于一地址指令，二地址指令留下的前7-8位和前9-12位为操作码，最后4位为操作数，操作码从00 0000-11 1101，留下11 1110和11 1111两种提供给零地址指令扩展，共有4 * 16 - 2= 62种。 对于零地址指令，一地址指令留下的第12位和最后四位为操作码，无操作数，操作码从0 0000-1 1111，共有2 * 16 = 32种。\n设地址长度为m，上一层留出m中状态，下一层就可以扩展出m * 2n种状态。实际情况根据不同地址指令种类多少进行扩展。 指令的寻址方式 # 指令寻址和数据寻址 # 每一条指令的执行部分分为“取指令”、”执行指令“两部分，在取完指令后，PC加“1”（一个指令字长）。\n指令寻址 # 顺序寻址 # 对于定长指令字结构，通过程序计数器PC加1（1个指令字长），自动形成下一条指令的地址。 如果指令字长与存储字长都为2B，主存按字编址，则每次PC加1，如果指令字长与存储字长都为2B，主存按字节编址，则每条指令占两个地址，则每次PC加2。 对于变长指令无法预先判断，所以CPU先读入指令，根据操作码判断这条指令的总字节数n，如果主存按字节编址，那么PC的值加n。\n跳跃寻址 # 通过转移指令给出，如果是无条件转移JMP则PC值改为对应数。\n数据寻址 # 确定本条指令的地址码的真实地址。 即指令的地址码中的地址并不一定是真正的地址，是一种真实地址的表现形式。 数据寻址方式很多，但是如何标识让CPU用哪种寻址方式进行解读呢？指令中每个形式地址之前都会有几位二进制代码表示寻址方式。\n常见数据寻址方式 # 直接寻址 # 指令字中的形式地址A就是操作数的真实地址EA，即EA = A。例如进行加法运算，可以直接将A传给MAR。\n优点 简单，指令执行阶段仅访问一次主存，不需要专门计算操作数的地址。 缺点 A的位数决定了该指令操作数的寻址范围，操作数的地址不易修改。 一条指令的执行，取指令访存一次，执行指令访存一次，暂不考虑存结果，共访存2次 间接寻址 # 指令中给出的地址码是存放有效地址的主存单元地址，即通过地址码找到真正的地址，通过真正的地址再找到有效地址EA。也可以有多重间接寻址。 优点 可扩大寻址范围（有效地址EA的位数大于形式地址A的位数），便于编制程序（用于间接寻址可以方便地完成子程序返回）。 缺点 指令执行的过程中要多次访存（一次间接寻址需要两次访存，多次寻址需根据存储字的最高位确定几次访存）。\n一条指令的执行：取指令访存一次，执行指令访存两次，暂不考虑存结果，共访存3次。若为多重间接寻址，则执行指令访存多次。 寄存器寻址 # 在指令字中直接给出操作数所在的寄存器编号，即EA=R，其操作数在由R所指的寄存器内。\n优点 在执行阶段不访问主存，只访问寄存器。指令字短且执行速度块，支持向量/矩阵运算。 缺点 寄存器价格昂贵，计算机中寄存器个数有限。 一条指令的执行，取指令访存一次，执行指令访存零次，暂不考虑存结果，共访存1次。 寄存器间接寻址 # 通过找寄存器编号，寄存器中的内容就是操作数的地址。 就是寄存器寻址和间接寻址的叠加态！ 比一般间接寻址要快，取指令访存一次，执行指令访存一次（因为操作数在主存中），共访存2次。\n隐含寻址 # 不是明显地给出操作数的地址，而是在指令中隐含着操作数的地址。 优点 有利于缩短指令字长 缺点 需增加存储操作数或隐含地址的硬件。 立即寻址 # 形式地址A就是操作数本身，又称为立即数，一般采取补码形式，#表示立即寻址特征。\n优点 指令执行阶段不访问主存，指令执行时间最短。 缺点A的位数限制了立即数的范围，如果A的位数为n，且立即数采用补码时，可表示的数据范围为-2n-1~2n-1 - 1。 一条指令的执行，取指令访存一次，执行指令访存零次，暂不考虑存结果，共访存1次。 基址寻址 # 以程序的起始存放地址作为“起点”。 将CPU中基址寄存器（BR）的内容加上指令格式中的形式地址A，从而形成操作数的有效地址，即EA = （BR）+ A； 或在指令中指出要使用哪个通用寄存器作为基址寄存器使用。\n指寄存器编号的位数需要根据寄存器总数来确定，如果有8个通用寄存器，就需要3个bit指明寄存器。\n例如执行一个四则运算程序，可以将数据和指令放到连续的地址上，那么当要使用某变量时，根据程序开始的地址，这段地址存到基址寄存器中，然后通过基址寻址快速的找到变量的地址，不管这段程序地址在地址空间的哪一个地方。便于程序的“浮动”，方便实现多道程序并发运行。因为多道相同的程序中指令与数据的相对位置都是一样的，只需要修改程序起始位置即可。 基址寄存器是面向操作系统的，其内容由操作系统或管理程序确定，在程序执行过程中，基址寄存器的内容不变（作为基地址），形式地址可变（偏移量）。一般BR或选择的某用于基址的通用寄存器中的内容。程序员无法修改。\n优点 可以扩大寻址范围（基址寄存器的位数大于形式地址A的位数），用不不必考虑自己的程序存与主存的哪一空间区域，故有利于多道程序设计，以及可以编写浮动程序（整个程序都在内存中浮动）。 变址寻址 # 以程序员自己决定的位置为“起点”。\n变址寄存器和基址寻址类似。 有效地址EA等于指令字中形式地址A与变址寄存器IX的内容相加之和，即EA = （IX） + A，其中IX可为变址寄存器（专用），也可以使用通用寄存器作为变址寄存器。\n变址寄存器是面向用户的，在程序执行过程中，变址寄存器的内容可由用户改变，（IX作为偏移量），形式地址A不变，（作为基准值），这点和基址寄存器不一样。\n例如，要进行对一个数组的求和，可以将指令中的A作为数组开头地址作为基准值，起始时IX的值为0，每次加后将IX中的值加1，直至求和完毕。变址寻址特别适合编址循环程序，偏移量（IX）的位数足以表示整个存储空间。\n相对寻址 # 以程序计数器PC所指地址为“起点”。\n把程序计数器PC的内容加上指令格式中的形式地址A而形成操作数的有效地址，即EA = (PC) + A，其中A是相对与PC所指地址的位移量，可正可负，补码表示。\n主要是面对汇编程序员，当需要调整代码在内存中的位置，若使用直接寻址，需要修改条件跳转的地址，使用基址寻址需要修改基准值，如果使用相对寻址，就无需改变。PC指向当前地址后自动根据A来进行寻址。\n优点 方便代码在程序内存浮动时，不用更改跳转指令的地址码。操作数的地址不是固定的，它随着PC值的变化而变化，并且与指令地址之间总是相差一个固定值，因此便于程序浮动，一段代码在程序内部的浮动。相对寻址广泛应用于转移指令。 一般基址寻址用于整个程序在内存中浮动，而相对寻址一般是程序内一段程序在该程序内部的浮动。变址寻址一般应用于程序内部的for循环来查找数组的下一位。 堆栈寻址 # 操作数存放在堆栈中，隐含使用堆栈指针（SP）作为操作数地址。堆栈是存储器（或专用寄存器组）中一块特定的按“后进先出（LIFO）”\n程序的机器级代码表示 # CISC和RISC的基本概念 # "},{"id":10,"href":"/docs/chapter03/CO/cpt05/","title":"第五章|中央控制器","section":"计算机组成原理","content":" CPU的功能和基本结构 # CPU的功能 # 中央处理器CPU由运算器和控制器组成。其中，控制器的功能是负责协调并控制计算机各部件执行程序的指令序列。包括取指令、分析指令和执行指令；运算器的功能是对数据进行加工。CPU的具体功能包括：\n指令控制 完成取指令、分析指令和执行指令的操作，即程序的顺序控制。 操作控制 一条指令的功能往往是由若干操作信号的组合来实现的。CPU管 理并产生由内存取出的每条指令的操作信号，把各种操作信号送往相应的部件， 从而控制这些部件按指令的要求进行动作。 时间控制 对各种操作加以时间上的控制。时间控制要为每条指令按时间 顺序提供应有的控制信号。 数据加工 对数据进行算术和逻辑运算。 中断处理 对计算机运行过程中出现的异常情况和特殊请求进行处理。 CPU的基本结构 # 在计算机系统中，CPU主要由运算器和控制器两大部分组成。 运算器 # 运算器接收从控制器送来的命令并执行相应的动作，对数据进行加工和处理。运算器是计算机对数据进行加工处理的中心，它主要由算术逻辑单元ALU、暂存寄存器、累加寄存器ACC、通用寄存器、程序状态字寄存器PSW、移位器、计数器CT等组成。\n算数逻辑单元 主要功能是进行算数/逻辑运算 暂存寄存器 用于暂存从主存读来的数据，该数据不能存在通用寄存器中，否则会破坏原有内容。暂存寄存器对程序员是透明的。 累加寄存器 它是一个通用寄存器，用于暂时存放ALU运算的结果信息，可以作为加法运算的一个输入端。 如：两个操作数分别来自主存和R0，最后结果存回R0， 那么从主存中取来的操作数直接放入暂存器，就不会 破坏运算前R0的内容。 通用寄存器组 如AX、BX、CX、DX、SP等，用于存放操作数（包括源操作数、目的操作数及中间结果）和各种地址信息等。SP是堆栈指针，用于指示栈顶的指针。 程序状态字寄存器 保留由算数逻辑运算指令或测试指令的结果而建立的各种状态信息，例如溢出标志OF、符号标志SF、零标志ZF、进位标志CF等。PSW这些位参与并决定微操作的形成。 移位器 对操作数或运算结果进行移位运算 计数器 控制乘除运算的操作步数 CPU内部单总线方式：将所有寄存器的输入端和输出端都连接到一条公共的通路上。 这样结构简单，容易实现。但数据传输存在较多冲突的现象。性能较低。 控制器 # 控制器是整个系统的指挥中枢，在控制器的控制下，运算器、存储器和输入/输出设备等功能部件构成一个有机整体，根据指令的要求指挥全机协调工作。控制器的基本功能是执行指令，每条指令的执行是由控制器发出的一组微操作实现的。\n控制器有硬布线控制器和微程序控制器两种类型。\n程序计数器 用于指出下一条指令在主存中的存放 地址。CPU就是根据PC的内容去主存中取指令的。因 程序中指令（通常）是顺序执行的，所以PC有自增 功能。 指令寄存器IR 用于存放当前正在执行的那条指令 指令译码器 仅对操作码字段进行译码，想控制器提供特定的操作信号。 存储器地址寄存器 用于存放将要访问的主存单元地址。 存储器数据寄存器 用于存放想主存写入的信息或从主存中读出的信息。 时序系统 用于产生各种时序信号，它们都是由统一时钟Clock分频得到的。 微操作信号发生器 根据IR的内容（指令）、PSW 的内容（状态信息）及时序信号，产生控制整个计算 机系统所需的各种控制信号，其结构有组合逻辑型和 存储逻辑型两种。 控制器的工作原理是根据指令操作码、指令的执行步骤（微命令序列）和条件信号来形成当前计算机各部件要用到的控制信号。就是计算机整机各硬件系统在这些控制信号的控制下协同运行，产生预期的执行结果。\nCPU内部寄存器大致分为两类： 用户可见的寄存器： 可以对该部分寄存器进行编程 通用寄存器组，程序状态寄存器PSW，程序计数器PC 用户不可见的寄存器： 该部分是对用户透明的。不可对这类寄存器编程， 存储器地址寄存器MDR、存储器数据寄存器MAR、指令寄存器IR，暂存寄存器 指令执行过程 # 指令周期 # 指令周期是CPU从主存中取出并执行一条指令所需的全部时间。不同指令的周期可能不同 。指令周期通常用若干个机器周期来表示，机器周期又叫做CPU周期。一个机器周期又包含若干时钟周期（也称为节拍，T周期或CPU时钟周期），它是CPU操作的最基本单位。 一般取指令比较慢，因为涉及到访存。\nCLK为CPU的脉冲，例如某CPU主频是3.0GHz，则该CPU每秒发出3.0G个CPU时钟周期。\n一个机器周期（包含多个CPU时钟周期）完成执行指令的一个小操作（如取指令）\n每个指令周期数可以不等，每个机器周期内的节拍数也可以不等。\n例如：\n空指令NOP 指令执行时，取指结束后什么都不做指令周期结束。 加法指令 指令执行时，包括取指周期和执行周期。 乘法指令 指令执行时，包括取指周期和执行周期，乘法指令的执行周期一般比加法指令的执行周期要长。 具有间址寻址的指令 指令执行时，包括取指周期，间址周期和执行周期，间址周期需要把形式地址转换为有效地址，需要指令周期更长。 带有中断周期的指令 指令执行时，包括取指周期、间址周期、执行周期和中断周期。 有些指令取指后就可以立即执行，有些需要再进行间址寻址等。\n为了区分到底处于哪个周期，在CPU内部设置4个标志触发器FE、IND、EX和INT，它们分别对应取指、间址、执行和中断周期，并以“1”状态表示有效\n指令周期的数据流 # 取指周期 # 主要任务是根据PC中的内容从主存中取出指令代码并存放在IR中。 数据流如下：\n间址周期 # 主要任务是取操作数有效地址。如将指令中的地址码送到MAR并送至地址总线，此后CU向存储器发读命令，以获得有效地址并存入MDR。\n数据流如下：\n第一步中，由于取指令时，MDR存放了指令内容，所以取IR与MDR的地址是一样的。\n第三步，得到操作数的有效地址后可以直接放入MAR中，也有的CPU是讲操作数的有效地址拼接到指令地址中。\n执行周期 # 执行周期的任务是根据IR中的指令字的操作码和操作数通过ALU操作产生执行结果，不同指令的执行周期操作不同，因此没有同一的数据流向。\n中断周期 # 中断：暂停当前任务去完成其他任务，为了能恢复当前任务，需要保存断点，一般使用堆栈来保存断点，这里使用SP表示栈顶指针。栈一般是地址空间从高到低，入栈是需要SP减1，再放入。 主要任务是处理中断请求。假设程序断点存入堆栈中，并用SP指示栈顶地址，并且进栈操作是先修改栈顶指针，后存入数据。\n数据流如下：\n指令执行方案 # 单指令周期 # 所有指令的指令周期都是相同的，任何一条指令都延长为最长指令周期的时间，指令之间是串行执行，即下一条指令只能在上一条指令执行完成后才能启动。执行时间取决于执行时间最长的指令的执行时间。\n对于本可以短时间内完成的指令，要用较长周期来完成，会降低整体系统的运行速度。\n多指令周期 # 对于不同类型的指令选用不同的执行步骤来完成。指令之间是串行执行，即下一条指令只能在上一条指令自行完成后才能启动。但是可选用不同个数的时钟周期来完成不同指令的执行过程，指令需要几个周期就给其分配几个周期，但是这样相比单指令周期需要更复杂的硬件设计。\n流水线方案 # 指令之间可以并行执行的方案，称为流水线方案，其追求的目的是力争每个时钟脉冲周期完成一条指令的执行过程。这种方案在每一个时钟周期启动一条指令，尽量让多条指令同时运行，但各自处在不同的执行步骤。\n数据通路的功能和基本结构 # 数据通路的功能 # 数据在功能部件之间传送的路径称为数据通路，包括数据通路上流经的部件，如ALU、通用寄存器、状态寄存器、异常和中断处理逻辑等。数据通路描述了信息从什么地方开始。中间经过哪个寄存器或多路开关，最后传送到哪个寄存器，这些都需要加以控制。\n数据通路由控制部件控制，控制部件根据每条指令功能的不同生成对数据通的控制信号。数据通路的功能是实现CPU内部的运算器与寄存器及寄存器之间的数据交换。\n数据通路的基本结构 # 数据通路的基本结构有以下几种：\nCPU内部单总线方式 # 将所有寄存器的输入端和输出端都连接到一条公共通路上，这种结构比较简单，但是会出现冲突的现象，性能较低。连接各部件只有一条总线时，为单总线方式。\nCPU内部多总线方式 # 将所有寄存器的输入端和输出端都连接到多条公共通路上，相比单总线上一个时钟周期只允许传一个数据，指令效率较低，采用多条总线方式可以在多个总线上传送不同的数据，提高效率。\n专用数据通路方式 # 根据指令执行过程中的数据和地址的流动方向安排连接线路，避免使用共享的总线，性能较高，但硬件量大。 内部总线：同一部件，指CPU内部连接各寄存器及运算部件之间的总线。\n系统总线：同一台计算机系统的各部件，如CPU、内存、通道和各类I/O接口间相互连接的总线。\n单总线结构 # 寄存器之间数据传送 # 比如把PC内容送到MAR，实现传送操作的流程及控制信号为：\n（PC）-\u0026gt;BUS PCout有效，PC内容送到总线； BUS-\u0026gt;MAR MARin有效，总线内容送到MAR；\n主存与CPU之间数据传送 # 比如CPU从主存读取指令，实现传送操作及控制信号为：\n（PC）-\u0026gt; BUS -\u0026gt;MAR PCout和MARin有效，现行指令地址-\u0026gt;MAR 1-\u0026gt;R CU发读命令（通过控制总线发出，图中未画出） MEM(MAR)-\u0026gt;MDR MDRin有效（将主存中的MAR对应的信息输入MDR中，图中未画出） MDR-\u0026gt;BUS-\u0026gt;IR MDRout和IRin有效，现行指令-\u0026gt;IR\n执行算术或逻辑运算 # 执行算数和逻辑操作时，由于ALU内部没有存储功能的组合电路，因此如果要执行加法运算，相加的两个数必须在ALU的两个输入端同时有效，而暂存寄存器就是将其中一个数与ALU一个输入端进行连接，另外一个数通过总线与另一个输入端进行连接，最终结果暂存到暂存器Z中。\n比如执行一条加法指令，微操作序列及控制信号为： Ad(IR)-\u0026gt;BUS-\u0026gt;MAR MDRout和MARin有效 1-\u0026gt;R CU发出读命令 MEM(MAR)-\u0026gt;MDR MDRin有效 MDR-\u0026gt;BUS-\u0026gt;Y MDRout和Yin有效，操作数-\u0026gt;Y (ACC)+Y-\u0026gt;Z ACCout和ALUin有效，CU向ALU发送加命令\nZ-\u0026gt;ACC Zout和ACCin有效\n专用数据通路 # 其中C1~C12为控制信号，控制这条线的连通，与MARin、MARout作用类似。\n取指令 # 例题 # 分析各阶段的微操作序列和控制信号\n控制器的功能和工作原理 # 控制器的结构和功能 # 高级语言代码被翻译为多条指令，每条指令的执行可能分为4个周期，取指周期FEtch、间址周期INDirect、执行周期EXecute、中断周期INTerpret。\nCU发出一个微命令，可以完成对应微操作，如：微命令1可以使PCout、MARin有效。完成对应的微操作1（PC）-\u0026gt;MAR。如果是多总线结果或专用数据通路，可以在一个节拍并行执行多个“相融的”微操作。同一个微操作可能在不同指令的不同阶段被使用。 不同指令的执行周期所需的节拍数不同，但是为了简化设计，可以选择定长机器周期，以可能出现的最大节拍数为准（通常以访存所需节拍数作为参考） 若实际所需节拍数较少，可将微操作安排在极期后期末尾的几个节拍上进行。\n根据指令操作码、目前的机器周期、节拍信号、机器状态条件，即可以确定这个节拍下应该发出哪些“微命令”。\n微操作指令分类 # 非访存指令 # CLA 清0 COM 取反 SHR 算数右移 CSL 循环左移 STP 停机指令 访存指令 # ADD X 加法指令 STA X 存数指令 LAD X 取数指令 转移指令 # JMP X 无条件转移 BAN X条件转移 硬布线控制器 # 指令操作码 指令寄存器IR传入n位操作码，经操作码译码器处理后传入控制单元 用于判断指令内容 当前机器周期 有FE、IND、EX、INT4个触发器分别表示取指、间址、执行、中断四个周期，传给CU来表示处于哪个机器周期。 这个四个触发器一般集成在CU内部 节拍信号 时钟脉冲信号传入节拍发生器，每个时钟周期发出一个节拍信号，有T1-Tm多个输出，循环发出。 用于表示节拍信号。 机器状态条件 标志来自执行单元的反馈信息，例如来自运算器的PSW、ACC的符号位等、也可能来自I/O设备、主存等。 这些信号可能会影响微操作的执行。 控制信号输出 CU接受信号输入后，输出控制信号，每个输出的控制信号对应一个微命令，例如要让C1对应微操作（PC）-\u0026gt;MAR，则将其接入到PCout和MARin上。 例如，所以指令的取指周期，T0节拍下要完成（PC）-\u0026gt;MAR，则可以让C1 = FE ^ T0。\n例如：\n硬布线控制器的设计 # 分析每个阶段的微操作序列（取指、间址、执行、中断四个阶段） 确定指令在哪个阶段，在什么条件下使用什么微操作。 CPU的控制方式 采用定长机器周期还是不定长，每个机器周期安排几个节拍 安排微操作时序 例如如何用3个节拍完成整个机器周期内的所有微操作。 电路设计 根据微操作命令设计的逻辑表达式用电路实现 组合逻辑设计 # 分析每个阶段的微操作序列 选择CPU的控制方式 安排微操作时序 电路设计 列出微操作命令的操作时间表 进行微操作信号综合 微操作控制信号=机器周期^节拍^脉冲^操作码^机器状态条件 画出微操作命令的逻辑图，根据逻辑表达式画出对应的逻辑电路。 硬布线控制器特点：\n指令越多、设计和实现越复杂，因此一般用于RISC（精简指令集），扩充一条新指令比较困难，需要大改。 但是采用纯硬件实现控制，执行速度非常快。 微程序控制器 # 采用“存储程序的思想”，CPU出厂前将所有指令的“微程序”存入“控制器存储器”中。\n微操作与微操作等同，微指令包括多个微命令。\n每一种指令对应一个微程序。\n基本结构 # 每个微程序包括多个微指令，每条微指令对应一个\n微地址形成部件： 微地址即微指令在CM中的存放地址。通过指令操作码形成对应微程序的第一条微指令的存放地址 顺序逻辑 根据某些机器标志和时序信息确定下一条微指令的存放地址 控制存储器CM： 用于存放个指令对应的微程序（微指令序列，按地址寻访。 控制存储器可用只读存储器ROM构成，通常在CPU出厂时就把所有微程序写入。 微地址寄存器CMAR或μPC： 用于存放控制存储器读写微指令的地址。指明接下来要执行的微指令的存放地址。 微指令寄存器CMDR或μIR： 用于存放从控制器中读出的微指令，即当前要执行的指令。CM（μPC）-\u0026gt;μIR\n控制存储器工作原理 # 取指周期、间址周期、中断周期的微程序一般是公用的，如果某指令系统中有n条机器指令，则CM中微程序端的个数至少为n+1个。（可能没有间址周期和中断周期） 一般而言取指周期的微指令序列固定从#0开始放，执行周期的微指令序列各不相同，\n概念对比 # 每条机器指令（比如让A+1）编写为一个微程序，每个微程序由多个微指令（例如取指令），每条微指令又对应多个微操作或微命令（比如（PC）-\u0026gt;MAR，1-\u0026gt;R这；两个微命令)。\n微指令的设计 # 微指令的格式 # 相容性微命令：可以并行完成的微命令。\n互斥性微命令：不允许并行完成的微命令。\n水平型微指令 # 一条微指令能定义多个可并行的微命令。\n微程序段，执行速度快。\n垂直型微指令 # 一条微指令只能定义一个微命令，由微操作码字段规定具体功能。 混合型微指令 # 异常和中断机制 # 指令流水线 # 多处理器的基本概念 # "},{"id":11,"href":"/docs/notes/readingnotes/0001/","title":"《大问题》阅读随笔","section":"notes","content":"The Big Questions\n\u0026ldquo;哲学就是对智慧的爱。它是对价值重要性的坚持，是对完全陷入生活琐事而仅仅随波逐流的拒斥。我们渴望洞察，企盼理解，但我们的生活被常规攫住了，不时会被那些所谓的“消遣”或“娱乐”活动分神。我们失去的是思考的快乐、理解的挑战、灵感，以及哲学的慰藉。我们都是借着思想而生活的，所以问题的关键不在于是否从事哲学，而在于是接受一种廉价的、没有挑战的替代品，还是试图进行真正的思考。\u0026rdquo;\n"},{"id":12,"href":"/docs/chapter02/acwing/DP/DP/","title":"DP","section":"Dp","content":" 背包DP # 01背包 # 每件物品最多只用一次。\n有 N 件物品和一个容量是 V 的背包。每件物品只能使用一次。 第 i 件物品的体积是 vi，价值是 wi。 求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。\n输出最大价值。 2. 01背包问题 - AcWing题库\n#include\u0026lt;iostream\u0026gt; using namespace std; const int N = 1010; int v[N],w[N]; int m,n; int f[N][N]; int main(){ cin \u0026gt;\u0026gt; m \u0026gt;\u0026gt; n; for(int i = 1; i \u0026lt;= m;i++ ){ cin \u0026gt;\u0026gt; v[i] \u0026gt;\u0026gt; w[i]; } for(int i = 1; i \u0026lt;= m;i++){ for(int j = 0;j\u0026lt;= n;j++) { f[i][j] = f[i - 1][j]; if( j \u0026gt;= v[i]) //当可以装下的空间比第i个大才有可能存在装第i个物品的情况。 f[i][j] = max(f[i][j],f[i - 1][j - v[i]] + w[i]); } } cout \u0026lt;\u0026lt; f[m][n]; return 0; } 优化为二维\n#include\u0026lt;iostream\u0026gt; using namespace std; 状态表示 # f(i,j) 表示从前i个背包中选，选出的总权值小于等于j的集合。 f(i,j)的值为总价值。\n集合 条件 只从前i中选 选出来的总权值 \u0026lt;j的集合 属性：最大值、最小值、数量。 状态计算 # 表示集合的划分 f(i,j)表示\n不包含第i个背包的最优解即f(i-1,j)， 包含第i个背包的最优解即f(i-1,j-w[i])+v[i]。即去掉第i个物品以及总权值减去第i个的权值。 总结： # 第i个背包能不能放，能放就是集合划分第二种，不能放就是第一种。从一步开始走，然后逐渐解决全部问题。\n完全背包 # 每件物品可以用很多次。\n整数划分\n#include\u0026lt;iostream\u0026gt; using namespace std; const int N = 1000010,MOD = 1e9; int f[N]; int main(){ int m; cin \u0026lt;\u0026lt; m; f[0] = 1; for(int i = 1; i \u0026amp;lt;= m;i *= 2){ for(int j = i; j \u0026amp;lt;= m ;j++){ f[j] = (f[j] + f[j - i]) % MOD; } } cout \u0026gt;\u0026gt; f[m]; return 0; } 多重背包 # 每件物品\n分组背包 # 有很多组，每组有多种\n线性DP # 最长上升子序列\n#include\u0026lt;iostream\u0026gt; using namespace std; const int N = 1010; int n; int a[N],f[N],g[N]; int main(){ scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); for(int i = 1 ; i \u0026lt;= n ; i ++){ scanf(\u0026#34;%d\u0026#34;,\u0026amp;a[i]); } for(int i = 1 ; i \u0026lt;=n ; i ++){ f[i] = 1; for(int j = 1 ; j \u0026lt; i ; j ++){ if(a[i] \u0026gt; a[j]){ if(f[j] + 1 \u0026gt; f[i]){ f[i] = f[j] + 1; g[i] = j; } } } } int k = 0; for(int i = 1 ; i \u0026lt;= n; i++){ // printf(\u0026#34;%d \u0026#34;,f[i]); if(f[i] \u0026gt; f[k]){ k = i; } } printf(\u0026#34;\\n%d\\n\u0026#34;,f[k]); for(int i = 0 ,len = f[k]; i \u0026lt; len ; i++){ printf(\u0026#34;%d \u0026#34;,a[k]); k = g[k]; } return 0; } 区间DP # 其他 # 3417. 砝码称重 - AcWing题库 砝码称重问题\n#include\u0026lt;iostream\u0026gt; using namespace std; const int N = 110; const int MAX = 2e5+10,B = MAX / 2; int w[N]; bool f[N][MAX]; int main(){ int n,m; m = 0; scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); for(int i = 1 ; i \u0026lt;= n ; i++) scanf(\u0026#34;%d\u0026#34;,\u0026amp;w[i]),m += w[i]; f[0][B] = true; for(int i = 1 ; i \u0026lt;= n ; i++){ for(int j = -m ; j \u0026lt;= m ; j ++){ //以下三种情况只要有一种满足 则f[i][j + B] 就满足. //不选 f[i][j + B] = f[i - 1][j + B]; //选,但是放另外一边 if(j + w[i] \u0026lt;= m)f[i][j + B] |= f[i - 1][j + w[i] + B]; //选,但是放一起 if(j - w[i] \u0026gt;= -m)f[i][j + B] |= f[i - 1][j - w[i] + B]; } } int sum = 0; for(int i = 1 ; i \u0026lt;= m ; i++){ if(f[n][i + B]) sum ++; } printf(\u0026#34;%d\u0026#34;,sum); return 0; } "},{"id":13,"href":"/docs/chapter02/acwing/DP/package/","title":"背包问题","section":"Dp","content":" 01 背包问题 # 每件物品最多只用一次。\n有 N 件物品和一个容量是 V 的背包。每件物品只能使用一次。 第 i 件物品的体积是 vi，价值是 wi。 求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。\n输出最大价值。 2. 01背包问题 - AcWing题库\n#include\u0026lt;iostream\u0026gt; using namespace std; const int N = 1010; int v[N],w[N]; int m,n; int f[N][N]; int main(){ cin \u0026gt;\u0026gt; m \u0026gt;\u0026gt; n; for(int i = 1; i \u0026lt;= m;i++ ){ cin \u0026gt;\u0026gt; v[i] \u0026gt;\u0026gt; w[i]; } for(int i = 1; i \u0026lt;= m;i++){ for(int j = 0;j\u0026lt;= n;j++) { f[i][j] = f[i - 1][j]; if( j \u0026gt;= v[i]) //当可以装下的空间比第i个大才有可能存在装第i个物品的情况。 f[i][j] = max(f[i][j],f[i - 1][j - v[i]] + w[i]); } } cout \u0026lt;\u0026lt; f[m][n]; return 0; } 优化为二维\n#include\u0026lt;iostream\u0026gt; using namespace std; 状态表示 # f(i,j) 表示从前i个背包中选，选出的总权值小于等于j的集合。 f(i,j)的值为总价值。\n集合 条件 只从前i中选 选出来的总权值 \u0026lt;j的集合 属性：最大值、最小值、数量。 状态计算 # 表示集合的划分 f(i,j)表示\n不包含第i个背包的最优解即f(i-1,j)， 包含第i个背包的最优解即f(i-1,j-w[i])+v[i]。即去掉第i个物品以及总权值减去第i个的权值。 总结： # 第i个背包能不能放，能放就是集合划分第二种，不能放就是第一种。从一步开始走，然后逐渐解决全部问题。\n完全背包 # 每件物品可以用很多次。\n整数划分\n#include\u0026lt;iostream\u0026gt; using namespace std; const int N = 1000010,MOD = 1e9; int f[N]; int main(){ int m; cin \u0026lt;\u0026lt; m; f[0] = 1; for(int i = 1; i \u0026amp;lt;= m;i *= 2){ for(int j = i; j \u0026amp;lt;= m ;j++){ f[j] = (f[j] + f[j - i]) % MOD; } } cout \u0026gt;\u0026gt; f[m]; return 0; } 多重背包 # 每件物品\n分组背包 # 有很多组，每组有多种\n"},{"id":14,"href":"/docs/chapter03/machine-learning/tools/","title":"常用工具","section":"机器学习","content":" 数据集网站 # UC Irvine Machine Learning Repository\n"},{"id":15,"href":"/docs/chapter02/commonSolution/","title":"常用思想方法","section":"第二章|基础算法","content":" 双指针思想 # 常用于对数组链表的处理，比如找两个和为定值的数。\n"},{"id":16,"href":"/docs/chapter02/acwing/base/base-1/","title":"基础算法一","section":"Base","content":" 快速排序 # 主要思想: # 在数组中选择一个值，然后遍历数组，比这个值大的放到这个值后边，比这个值小的放到这个值的前边。\n代码实现 # void quick_sort(int q[], int l, int r){ if(l \u0026gt;= r) return; int x = q[(l + r) \u0026gt;\u0026gt; 1], i = l - 1, j = r + 1; while(i \u0026lt; j) { do i ++ ; while(q[i] \u0026lt; x); do j -- ; while(q[j] \u0026gt; x); if(i \u0026lt; j) swap(q[i],q[j]); } quick_sort(q,l, j); quick_sort(q,j+1,r); } 为什么最后是j与j+1呢?\n因为范围确保的是左边是小于等于x，右边大于等于x。而循环判断结束的限制是i\u0026lt;j,则可能出现的情况是i=j或i = j + 1。如果是i=j+1那么左边为l到i不满足左边都小于等于x，因为q[i]\u0026gt;x。那为什么不是l到i-1呢？如果是l到i-1那么可能出现只有两个数的情况，然后划分的时候右边化为空集，左边为两个数的数组，此时陷入无尽循环。\n归并排序 # 主要思想: # 将数组拆分为两部分，前半部分和后半部分，然后这两部分分别进行排序。排序完成后从这两个数组开头开始比较，较小的数先插入到数组头位置，以此类推。\n代码实现 # void merged_sort(int a[],int l,int r){ if(l \u0026gt;= r) return; int mid = (l + r)\u0026gt;\u0026gt;1; merged_sort(a,l,mid); merged_sort(a,mid+1,r); int k = l,i = l,j = mid + 1; while(i \u0026lt;= mid\u0026amp;\u0026amp;j \u0026lt;= r){ if(a[i] \u0026lt; a[j]) tmp[k++] = a[i++]; else tmp[k++] = a[j++]; } while(i \u0026lt;= mid) tmp[k++] = a[i++]; while(j \u0026lt;= r) tmp[k++] = a[j++]; for(int i = l; i \u0026lt;= r ;i++) a[i] = tmp[i]; } 二分 # 主要思想 # 假设目标值在闭区间[l, r]中， 每次将区间长度缩小一半，当l = r时，我们就找到了目标值。 有单调性可以二分，使用二分不一定有单调性。\n整数二分 # 选择不同版本主要是看check函数，如果答案在[l, mid]和[mid + 1, r]与[l, mid - 1]和[mid, r]这两种情况中的一种，则需要判断是否在计算mid时多加一\n版本1 # 当我们将区间[l, r]划分成[l, mid]和[mid + 1, r]时，其更新操作是r = mid或者l = mid + 1;，计算mid时不需要加1。\nC++ 代码模板：\nint bsearch_1(int l, int r) { while (l \u0026lt; r) { int mid = l + r \u0026gt;\u0026gt; 1; if (check(mid)) r = mid; else l = mid + 1; } return l; } 版本1 # 当我们将区间[l, r]划分成[l, mid - 1]和[mid, r]时，其更新操作是r = mid - 1或者l = mid;，此时为了防止死循环，计算mid时需要加1。\nC++ 代码模板：\nint bsearch_2(int l, int r) { while (l \u0026lt; r) { int mid = l + r + 1 \u0026gt;\u0026gt; 1; if (check(mid)) l = mid; else r = mid - 1; } return l; } check(mid)函数一般表示数组的mid位是否大于等于要找的值，包含等于的情况则后边修改边界时是l或r等于mid。 两组差别是当更新边界时有l = mid;r = mid - 1;时，在计算mid时需要多加一来向上取整。\n实数二分 # 比如求某个数开根号的结果，可以使用二分。 举个例子，求实数n开三次方的结果，保留6位小数。\ndouble q(double a){return a*a*a;}//求三次方 double sancigen(double n){ double l = -n; double r = n; double mid = 0; while(l - r \u0026gt; 1e-7){//当左右边界很接近的时候 就已经满足了答案。 if(q(mid) \u0026gt; n) r = mid; else l = mid; mid = (l + r) / 2; } return l; } 高精度 # 应用场景 # 如果一个数据很大，大于int与long long的数据表示范围，即[-$2^{31}$,$2^{31} - 1$]和[-$2^{63}$,$2^{63} - 1$]无法表示.那么则需要进行高精度计算.c++中进行长数据运算会出现溢出为负的情况，而java、python没有这种问题（因为一般会自动转换为更大变量）。 一般情况为四种情况，大整数的加减乘除。\n计算前预处理 # 一般情况下，大数据int甚至long long存不下，我们可以使用数组存。一般使用大端模式，即高位存高位，低位存低位，便于高位进位，否则进位时需要把数组整体后移。 用vector存比较方便，因为有size()函数返回长度。 数据12345，在数组中存储的顺序是54321。\n加法 # 计算过程就是类似模拟加减法运算。\nvector\u0026lt;int\u0026gt; addBigInteger(vector\u0026lt;int\u0026gt; \u0026amp;A,vector\u0026lt;int\u0026gt; \u0026amp;B) { vector\u0026lt;int\u0026gt; C; int t = 0; for(int i = 0; i \u0026lt; A.size()|| i \u0026lt; B.size();i++) { if(i \u0026lt; A.size()) t += A[i]; if(i \u0026lt; B.size()) t += B[i]; C.push_back(t%10); t /= 10;//大于10则有进位。 } if(t)//最高位有进位，则再加一。 C.push_back(1); return C; } 减法 # 减法先考虑两个正数相减，其他情况可以转换为绝对值相加减，如两个负数相减可以转换为绝对值相加然后取反，正数负数相减可以转换为绝对值相减然后根据情况添加正负号。 可以先判断两个数哪个更大，用大的减去小的，再根据情况添加正负号。如果出现两个相同的数相减，需要处理前导0。\nbool cmp(vector\u0026lt;int\u0026gt; \u0026amp;A,vector\u0026lt;int\u0026gt; \u0026amp;B){ if(A.size() != B.size()) return A.size() \u0026gt; B.size(); for(int i = A.size() - 1; i \u0026gt;= 0;i--){ if(A[i] != B[i]) return A[i] \u0026gt; B[i]; } return true; } vector\u0026lt;int\u0026gt; subBigInteger(vector\u0026lt;int\u0026gt; \u0026amp;A,vector\u0026lt;int\u0026gt; \u0026amp;B) { vector\u0026lt;int\u0026gt; C; int t = 0; for(int i = 0;i \u0026lt; A.size();i++)//默认A.size()\u0026gt;=B.size() { t = A[i] + t; if(i \u0026lt; B.size()) t -= B[i]; C.push_back((t+10)%10); if(t \u0026gt;= 0) t = 0; else t = -1; //if(t \u0026gt;= 0) C.push_back(t); //else {C.push_back(t + 10);t = -1;} } while(C.size()\u0026gt;1\u0026amp;\u0026amp;C.back() == 0) C.pop_back();//处理前导0 return C; } 乘法 # 乘法一般考虑大数据与小数据相乘，直接模拟计算乘法的过程。\nvector\u0026lt;int\u0026gt; multBigInteger(vector\u0026lt;int\u0026gt; \u0026amp;A,int B) { vector\u0026lt;int\u0026gt; C; for(int i = 0,t =0;i \u0026lt; A.size() || t != 0;i++)//t != 0确保最高位进位 { if(i \u0026lt; A.size()) t = t + A[i] * B; C.push_back(t%10); t = t/10; } while(C.size() \u0026gt; 1 \u0026amp;\u0026amp; C.back() == 0)C.pop_back();//出现一个乘数为0的情况。 return C; } 除法 # 除法也是模拟的方法。不过细节稍微有点不同。\nvector\u0026lt;int\u0026gt; divBigInteger(vector\u0026lt;int\u0026gt; A,int B,int \u0026amp;d) { vector\u0026lt;int\u0026gt; C; d = 0; for(int i = A.size() - 1; i \u0026gt;=0;i--)//除法是从最高位开始除的，所以这里从最高位开始。 { d = A[i] + d*10;//列式除法最下方那个数字 C.push_back(d / B);//列式除法最上方那一行的数字入C； d = d % B;//算完后的余数，留给下一位计算。 } reverse(C.begin(),C.end());//由于C是正向加入，所以这里翻转。 while(C.size() \u0026gt; 1 \u0026amp;\u0026amp; C.back() == 0) C.pop_back();//除去前导0 return C; } 前缀和 # 前缀和是指用一个数组来存前i个数据的和，这样方便计算区间和的值。\n一维前缀和 # const int N = 100010; int s[N]; int a[N]; for(int i = 1; i \u0026lt;= n ;i++) { s[i] = s[i - 1] + a[i]; } 当要计算区间l到r的和时。\nprintf(\u0026#34;%d\u0026#34;,s[r] - s[l - 1]); 二维前缀和 # 计算前缀和数组\nconst int N = 1010; int a[N][N]; int s[N][N]; for(int i = 1;i \u0026lt;= n ;i++){ for(int j = 1;j \u0026lt;= m ;j++){ s[i][j] = a[i][j] + s[i][j - 1] + s[i-1][j] - s[i-1][j-1]; } } 求区间(i,j)到(k,l)内矩形内的和\nprintf(\u0026#34;%d\\n\u0026#34;,s[k][l] - s[k][j - 1] - s[i - 1][l] + s[i - 1][j - 1]); 差分 # 差分是指用一个数组来存相邻数的差，这样方便处理对区间内的数都加上某个数的操作。\n一维差分 # 定义插入函数\nconst int N = 100010; int arr[N]; int b[N]; void insert(int l,int r,int c) { b[l] += c; b[r + 1] -= c; } 区间内减去C\nb[l] = b[l] + c; b[r + 1] = b[r + 1] - c; ``` 求原数组，输出结果 ```cpp for(int i = 1;i \u0026lt;= n ;i++) { b[i] += b[i-1]; } for(int i = 1;i \u0026lt;= n ;i++) { printf(\u0026#34;%d \u0026#34;,b[i]); } 二维差分 # 定义插入函数\nconst int N = 1010; int n,m,q; int arr[N][N]; int b[N][N]; void insert(int x1,int y1,int x2,int y2,int c){ b[x1][y1] += c; b[x2 + 1][y1] -= c; b[x1][y2 + 1] -= c; b[x2 + 1][y2 + 1] += c; } 计算差分数组。\nwhile(q--){ int x1,x2,y1,y2,c; scanf(\u0026#34;%d%d%d%d%d\u0026#34;,\u0026amp;x1,\u0026amp;y1,\u0026amp;x2,\u0026amp;y2,\u0026amp;c); insert(x1,y1,x2,y2,c); } 逆运算求原数组并输出。\nfor(int i = 1; i\u0026lt;=n;i++) for(int j = 1;j\u0026lt;=m;j++){ b[i][j] += b[i-1][j] + b[i][j-1] - b[i-1][j-1]; } for(int i = 1;i \u0026lt;= n;i++){ for(int j = 1; j\u0026lt;=m;j++){ printf(\u0026#34;%d \u0026#34;,b[i][j]); } printf(\u0026#34;\\n\u0026#34;); } 双指针算法 # 一般用i,j两个指针来遍历数组。快速排序也使用了双指针的思想。 核心思想：\n将下面的朴素算法$O(n^2)$优化到$O(n)$\nfor(int i = 0;i\u0026lt;n;i++) { for(int j = 0; j \u0026lt; n ;j ++){ //具体逻辑 check(i,j); } } 基本模板：\nfor(int i = 0,j=0;i\u0026lt;n;i++) { while(i \u0026lt; j\u0026amp;\u0026amp;check(i,j))j++; //具体逻辑 } 求最长不重复子列长度 # 数组不含重复数字的最长子列的长度。 朴素做法是遍历所有i，j。但是根据分析后发现，如果区间内无重复子列，i往后移动出现了重复子列，那么j只有往后移动才可能消去这个子列。往左则不满足i移动前的条件，即当前是最长无重复子列。\nint a[N]; int s[N];//用于确定区间内是否有重复数组，这也可以使用哈希表来判断。 for(int i = 0,j = 0;i \u0026lt; n;i++){ s[a[i]] ++ ; while(s[a[i]] \u0026gt; 1){ //如果存在重复数，则j往前移动 //为什么不往后移动？因为当前j已经是满足上一个i的最右距离，只能往左了。 s[a[j]] --; j ++; } res = max(res,i - j + 1); } 位运算 # 常用操作 # 求n的二进制数的第k位，和第一个1的位置。\nint res = n\u0026gt;\u0026gt;k \u0026amp; 1;//将第k位右移到个位，然后与000001进行和运算。个位为1输出1否则输出0。 int lowbit(int n){ return n\u0026amp;(-n); //return n\u0026amp;(~x + 1); } int num = lowbit(n); 用例 判断一个数的二进制数有多少个1。\nint num = 0; while(x \u0026gt; 0){ x -= lowbit(x); num ++; } printf(\u0026#34;%d \u0026#34;,num); 离散化 # 主要思想 # 在一个长区间，是很长很长的区间中，存在零散的数据。这种情况下找区间内的值，如果一个个遍历会很费时（因为区间很长），所以有了离散化的想法。\n一般是将数据依照顺序来与自然数一一对应.如果有区间那么也添加到其中.\n以一个题目为例: 802. 区间和 - AcWing题库\n全部代码 # #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; typedef pair\u0026lt;int, int\u0026gt; PII; const int N = 300010; int n, m; int a[N], s[N];//定义离散化后的数组,与前缀和数组. vector\u0026lt;int\u0026gt; alls;//存储需要离散化的值,并将其与自然数映射. vector\u0026lt;PII\u0026gt; add, query;//存储添加数据对,与查询数据范围. int find(int x)//根据离散化的数查询自然数对应的位置. { int l = 0, r = alls.size() - 1; while (l \u0026lt; r) { int mid = l + r \u0026gt;\u0026gt; 1; if (alls[mid] \u0026gt;= x) r = mid; else l = mid + 1; } return r + 1;//因为要使用前缀和,所以一般数组以1开头,所以这里加一. } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 0; i \u0026lt; n; i ++ ) { int x, c; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; c; add.push_back({x, c}); alls.push_back(x);// } for (int i = 0; i \u0026lt; m; i ++ ) { int l, r; cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r; query.push_back({l, r}); alls.push_back(l); alls.push_back(r); } // 去重 sort(alls.begin(), alls.end()); alls.erase(unique(alls.begin(), alls.end()), alls.end()); //担心一个点加两次数却被去重? //这里只存储位置,加数在后边遍历添加数据对中, //如果一个点多加两次,那么add中也有两条对应的. // 处理插入 for (auto item : add) { int x = find(item.first); a[x] += item.second; } // 预处理前缀和 for (int i = 1; i \u0026lt;= alls.size(); i ++ ) s[i] = s[i - 1] + a[i]; // 处理询问 for (auto item : query) { int l = find(item.first), r = find(item.second); cout \u0026lt;\u0026lt; s[r] - s[l - 1] \u0026lt;\u0026lt; endl; } return 0; } 区间合并 # 问题提出 # 给出n个区间范围,如果区间有公共范围,则合并.求最终剩下几个区间.\n主要思路 # 可以按照左端点大小进行排序,然后检查右端点与下一个区间的左端点的关系,如果包含则并入,否则不处理,划分到下一个区间,\n主要代码 # #include\u0026lt;iostream\u0026gt; #include\u0026lt;vector\u0026gt; #include\u0026lt;algorithm\u0026gt; using namespace std; const int N = 100010; typedef pair\u0026lt;int,int\u0026gt; PAIR; vector\u0026lt;PAIR\u0026gt; seg; void merged(vector\u0026lt;PAIR\u0026gt;\u0026amp; seg){ vector\u0026lt;PAIR\u0026gt; res; int st, ed; st = -2e9; ed = -2e9; sort(seg.begin(),seg.end()); for(auto item:seg){ if(ed \u0026lt; item.first){ if(ed != -2e9){ res.push_back({st,ed}); } st = item.first; ed = item.second; }else ed = max(ed,item.second); } if(st != -2e9) res.push_back({st,ed}); seg = res; } int main(){ int n; cin \u0026gt;\u0026gt; n; for(int i = 0 ; i \u0026lt; n ;i ++){ int l , r; cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r; seg.push_back({l,r}); } merged(seg); cout \u0026lt;\u0026lt; seg.size(); return 0; } 大概就是这样了\n"},{"id":17,"href":"/docs/notes/readingnotes/0002/","title":"拉康","section":"notes","content":"人们可以因为完全不同的原因对同一个人产生兴趣，并把他安插到各自生命的故事中的不同位置上。\n科学只有一个目标，就是去知道，它不会考虑欲望、负罪感和享乐(jouissance)。对此，拉康说道：“科学会对所谓的人性造成一种不可呼吸的效果。”而精神分析相比科学的话语，处在例外的位置，它具有一种“人工肺的功能”。相比科学普遍化的尝试，精神分析的伦理学强调个体差异和每个人的独特性，这方面极端的例子是对于一些严重的精神病患者，有些分析家会主张针对每一个主体发明一种适合他的诊断，而不是将他对应到某个现有的诊断中。\n精神分析能够利用到自身，对人性的反应。\n三条岔路 # 另一个女人和男\u0026quot;工具人\u0026quot; # "},{"id":18,"href":"/docs/chapter03/DS/cpter08/","title":"排序算法","section":"数据结构","content":" 1.0 十大经典排序算法 | 菜鸟教程\n常用排序算法 # 冒泡排序 选择排序 插入排序 希尔排序 归并排序 快速排序 堆排序 基数排序 桶排序 计数排序 排序算法的稳定性 # 什么是稳定性？ # 稳定的算法是在排序后，相同排序属性的元素预期的前后顺序是已知的，不稳定的排序算法是未知的，即有可能是稳定算法的顺序，也有可能不是。 如果一个排序算法是稳定的，那么对于两个数值相同的元素而言，它们的相对位置是不变的。这对于只考虑排序属性的排序而言是无意义的，因为该排序是需要考虑排序属性的前后问题。但是如果排序的每个元素含有其他属性，这些属性需要保持一定的前后顺序，例如在排序含有姓名与年龄属性的用户时（待排序的用户是按照姓氏首字母的顺序排列），按照用户年龄排序，但是需要保证排序后相同年龄的用户前后顺序依旧是按照姓氏首字母来排，那么就需要保证排序算法的稳定性。\n什么排序算法是稳定的？ # 稳定的排序算法如果细节未处理好就会变成不稳定的排序算法，而不稳定的排序算法得出的结果就是不稳定的。 稳定的排序算法有： 直接插入排序、冒泡排序、归并排序、基数排序 不稳定的排序算法： 希尔排序、选择排序、堆排序、快速排序\n冒泡排序 # 基本思想 # 重复走访要排序的数列，一次比较两个相邻的数字大小，如果不符合顺序就交换，交换后移动到下一位进行比较。遍历遍历完一次数组后，重新从头操作，直到没有任何一对数字需要比较。\n代码实现 # void buble_sort(vector\u0026lt;int\u0026gt;\u0026amp; array){ int len = array.size(); int flag = 0; //定义标志位,判断是否已经排好。 for(int i = 0;i \u0026lt; len - 1;++i){ for(int j = 0;j \u0026lt; len - 1;++j){ if(array[j] \u0026gt; array[j+1]){ array[j] ^= array[j+1]; array[j+1] ^= array[j]; array[j] ^= array[j+1];// 交换 flag = 1;//如果有交换则证明排序未结束。 } } if(flag == 0) break;//一次遍历中无交换则证明排序已完成。 else flag = 0; } } 时空损耗 # 时间复杂度\n平均时间复杂度\nO(n^2) 最好情况\nO(n)，刚好就是预期的顺序。 最坏情况\nO(n^2)，刚好就是反着的顺序。 空间复杂度\nO(1)，只使用了循环所需要的变量。 选择排序 # 基本思想\n首先在数组中找最小（大）的元素，找到了放到数组起始位置，然后开始在除去起始位置的数组中寻找第二小（大）的元素，然后放到第二位置，如此重复直到最后一个位置。 插入排序 # 希尔排序 # 归并排序 # 快速排序 # 基本思想 # 快速排序采用了分治算法的思想，即分而治之。如果要排序一个数组，我可以先随意挑选选一个基准值（通常为数组的第一个元素，因为数组第一个元素一般是一般情况下都有的，取值方便），然后把比它大的放左边，比它小的放右边，然后这个问题就变成了基准值左边的小数组的排序和基准值右边的小数组的排序。然后我们可以对两个小数组进行快速排序，如此重复。\n代码实现 # int Paritition1(int A[], int low, int high){ int pivot = A[low]; //设定基准值 while (low \u0026lt; high){ while (low \u0026lt; high \u0026amp;\u0026amp; A[high] \u0026gt;= pivot){ --high; } A[low] = A[high]; while (low \u0026lt; high \u0026amp;\u0026amp; A[low] \u0026lt;= pivot){ ++low; } A[high] = A[low]; } A[low] = pivot; return low; }//以基准来划分两边的数组。 void QuickSort(int A[], int low, int high){ //快排母函数 if (low \u0026lt; high){ int pivot = Paritition1(A, low, high); QuickSort(A, low, pivot - 1); QuickSort(A, pivot + 1, high); } } 堆排序 # 基数排序 # 桶排序 # 计数排序 # "},{"id":19,"href":"/docs/chapter02/acwing/math/others/","title":"其他","section":"Math","content":" 秦九韶算法 # 使用秦九韶算法可以计算多项式的值，或进制转换。 例子：计算多项式的值。a[i]表示多项式中的x的i次幂的系数。\n#include\u0026lt;iostream\u0026gt; using namespace std; int n,x,ans,a[21]; int main(){ cin\u0026gt;\u0026gt;n; for(int i=0;i\u0026lt;=n;i++) cin\u0026gt;\u0026gt;a[i]; cin\u0026gt;\u0026gt;x; ans=a[n]; for(int i=1;i\u0026lt;=n;i++) ans=ans*x+a[n-i]; cout\u0026lt;\u0026lt;ans; return 0; } "},{"id":20,"href":"/docs/notes/thinknote/00003/","title":"生活","section":"小记","content":"记得东西有些杂乱，可以细分一下内容，归类，然后有空的时候整理一下，maybe换个主题？\n关于生活的意义， 且听下回分解！\n只喜欢一面，那只是占有欲啊！不是爱\n我在想什么?! 好没用啊 明明我之前也不是这样的 这是不想承认自己不行吗\n如果你想找回思考能力，可以尝试阅读一些挑战思维的书籍，如哲学、经济学、物理学、心理学等领域的经典著作。以下是一些建议：\n哲学类：柏拉图的《理想国》、尼采的《查拉图斯特拉如是说》、笛卡尔的《第一哲学沉思》等。 经济学类：亚当·斯密的《国富论》、约翰·梅纳德·凯恩斯的《就业、利息和货币通论》等。 物理学类：艾萨克·牛顿的《自然哲学的数学原理》、爱因斯坦的《相对论》等。 心理学类：弗洛伊德的《精神分析导论》、卡尔·罗杰斯的《成为人》等。 这些书籍可以激发你的思维，让你思考一些深层次的问题，提高你的逻辑思考和判断能力。当然，也可以选择其他类型的书籍，只要是能够激发你思维的书籍都可以尝试阅读。\n能够激发思维的书籍是指这些书籍可以激发读者的思维，让读者思考一些问题，探索一些新的想法，从而提升读者的认知水平和思考能力。这些书籍通常包含深刻的洞见、新颖的观点、严密的逻辑和清晰的语言表达。它们可以引发读者的兴趣，激发读者的好奇心和探究欲望，促使读者主动思考和探索。这些书籍不仅可以扩展读者的知识面，还可以提高读者的思考能力和思维方式。\n"},{"id":21,"href":"/docs/chapter02/acwing/base/datestruct/","title":"数据结构","section":"Base","content":" 链表 # 拿数组模拟链表,其实也就是静态链表. 静态链表的优点是快,但是缺点是必须要提前分配足够空间,并且可能会出现假满状态,即idx到最后但是前边还有很多未使用的节点,\n单链表 # #include\u0026lt;iostream\u0026gt; using namespace std; const int N = 100010; int e[N]; int ne[N]; int idx,head; void init(){ head = -1; idx = 0; } void add_to_head(int x){ e[idx] = x; ne[idx] = head; head = idx++; } //插入到下标为k的后面 void add(int k,int x){ e[idx] = x; ne[idx] = ne[k]; ne[k] = idx ++; } void del(int k){ if(k == -1) head = ne[head]; else ne[k] = ne[ne[k]]; } int main(){ int m; cin \u0026gt;\u0026gt; m; init(); while(m--){ char opt; cin \u0026gt;\u0026gt; opt; if(opt == \u0026#39;H\u0026#39;){ int x; cin \u0026gt;\u0026gt; x; add_to_head(x); }else if(opt == \u0026#39;D\u0026#39;){ int k; cin \u0026gt;\u0026gt; k; del(k-1); }else{ int k,x; cin \u0026gt;\u0026gt; k \u0026gt;\u0026gt;x; add(k - 1,x); } } int index = head; while(index != -1){ cout \u0026lt;\u0026lt; e[index] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; index = ne[index]; } return 0; } 双链表 # 所谓双链表就是每个节点含有前结点位置进而后节点位置.\n#include\u0026lt;iostream\u0026gt; using namespace std; const int N = 100010; int pre[N],ne[N],e[N]; int idx; // 定义0号位为头结点 // 定义1号位为尾结点 void init(){ ne[0] = 1; pre[0] = -1; ne[1] = -1; pre[1] = 0; idx = 2; } void add_head(int x){ e[idx] = x; ne[idx] = ne[0]; pre[idx] = 0; pre[ne[0]] = idx; ne[0] = idx; idx ++; } void add_tail(int x){ e[idx] = x; ne[idx] = 1; pre[idx] = pre[1]; ne[pre[1]] = idx; pre[1] = idx; idx++; } void del(int k){ ne[pre[k]] = ne[k]; pre[ne[k]] = pre[k]; } void add_left(int k,int x){ e[idx] = x; ne[idx] = k; pre[idx] = pre[k]; ne[pre[k]] = idx; pre[k] = idx; idx ++; } void add_right(int k,int x){ e[idx] = x; ne[idx] = ne[k]; pre[idx] = k; pre[ne[k]] = idx; ne[k] = idx; idx++; } int main(){ int m; cin \u0026gt;\u0026gt; m; init(); while(m --){ string opt; int k,x; cin \u0026gt;\u0026gt; opt; if(opt == \u0026#34;L\u0026#34;){ cin \u0026gt;\u0026gt; x; add_head(x); }if(opt == \u0026#34;R\u0026#34;){ cin \u0026gt;\u0026gt; x; add_tail(x); }if(opt == \u0026#34;D\u0026#34;){ cin \u0026gt;\u0026gt; k; del(k + 1); }if(opt == \u0026#34;IL\u0026#34;){ cin \u0026gt;\u0026gt; k \u0026gt;\u0026gt; x; add_left(k + 1,x); }if(opt == \u0026#34;IR\u0026#34;){ cin \u0026gt;\u0026gt; k \u0026gt;\u0026gt; x; add_right(k + 1,x); } } int j = 0; for(int i = ne[0]; ne[i] != -1; i = ne[i]){ cout\u0026lt;\u0026lt; e[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } return 0; } 栈和队列 # 使用数组实现基本的栈与队列\n模拟栈 # const int N = 1010; //栈 int stk[N],tt = -1; //入栈 stk[++tt] = elem; //出栈 stk[tt--]; //栈是否为空 if tt \u0026lt; 0 stack is empty else stack is not empty 完整操作代码\nconst int N = 100010; int stk[N],idx; //初始化 void init(){ idx = -1; } //插入元素 void push(int x){ stk[++idx] = x; } //取出栈顶元素 int pop(){ int res = stk[idx--]; return res; } //判断是否为空 bool isEmpty(){ if(idx \u0026lt; 0) return true; else return false; } //获取栈顶元素 int pull(){ return stk[idx]; } 模拟队列 # const int N = 1010; //栈 int queue[N],tt,hh; //入队 queue[tail++] = elem; //出队 queue[top++]; 完整操作\nconst int N = 100010; int queue[N],top,tail; //初始化 void init(){ top = -1; tail = -1; } //插入元素到队尾 void push(int x){ queue[++tail] = x; } //弹出队列队首元素 int pop(){ int res = queue[++top]; return res; } //队列是否空 bool isEmpty(){ if(top \u0026gt;= tail) return true; else return false; } //返回队列队首元素 int pull(){ return queue[top + 1]; } 单调栈与单调队列 # 单调栈 # 定义 # 什么是单调栈? 栈中的数据具有单调性.现在有一组数10,3,7,4,12从左到右依次入栈，则如果栈为空或入栈元素值小于栈顶元素值，则入栈；否则，如果入栈则会破坏栈的单调性，则需要把比入栈元素小的元素全部出栈。单调递减的栈反之。\n应用场景 # 给定一个序列,求每个元素左边(或右边)最近的比它小(或大)的元素.其实就是找逆序对,最近的两个构成逆序就输出,未找到就返回-1.\n如下图所示, 4找3,满足,则返回3; 2往前找4,不满足,找3,也不满足,则返回-1; 7往前找2(如果2满足,则无需考虑2之前的数据),满足则返回2. 5往前找7,不满足,则去找2,满足,则返回2. 如果满足逆序则保留,不满足则不保留 (因为如果保留,则当前点不满足,上一个点也不满足,需要多遍历, 例如序列5 4 3 1 2, 考虑3时,5 4是非逆序,那么4不满足,5同样不满足) 这种情况使用栈最好,因为考虑的数据是按照后进先出的顺序读取.\n主要代码 # #include\u0026lt;iostream\u0026gt; using namespace std; const int N = 10010; int stk[N].idx = 0; int main(){ int n; cin \u0026gt;\u0026gt; n; for(int i = 0 ; i \u0026lt; n ; i++){ int x; cin \u0026gt;\u0026gt; x; while(idx \u0026amp;\u0026amp; stk[idx] \u0026gt;= x) idx--; if(idx) cout \u0026lt;\u0026lt; stk[idx] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; else cout \u0026lt;\u0026lt; \u0026#34;-1\u0026#34; \u0026lt;\u0026lt; \u0026#34; \u0026#34;; stk[++idx] = x; } return 0; } 单调队列 # 定义 # 什么是单调队列? 有单调性的队列!\n应用场景 # 输入一个数组,并且有长度为k的滑动窗口不断向右移动,求每移动一次后窗口中元素的最大(小)值.滑动窗口求最值.\n先考虑暴力解法,再进行优化,考虑哪些没有用到却被操作.\n#include\u0026lt;iostream\u0026gt; using namespace std; const int N = 1000010; int n,k; int a[N],q[N]; int hh,tt; int main(){ scanf(\u0026#34;%d%d\u0026#34;,\u0026amp;n,\u0026amp;k); for(int i = 0 ; i \u0026lt; n ; i++) scanf(\u0026#34;%d\u0026#34;,\u0026amp;a[i]); int hh = 0, tt = 0; for(int i = 0 ; i \u0026lt; n ; i++ ){ //判断队头是否已经滑出窗口,即当窗口长度为3时 //,i = 3,hh = 0时,这个3长度的窗口 已经不包括 队首了 所以需要hh++ //一般情况只需要加一次,所以用的是if 不是while if(hh \u0026lt;= tt \u0026amp;\u0026amp; i - k + 1 \u0026gt; q[hh]) hh++; //队列如果加入新元素后不是单调的,就要出队, //直到满足队列为单调的 // 比如 当前窗口内为 3 -1 -3 , //那么3 -1 就是属于无效数据,因为-3是最小的 //在往后移动的过程中,只要有-3 前边都不考虑 //这种情况 也可以看成 不满足单调性 while(hh \u0026lt;= tt \u0026amp;\u0026amp; a[q[tt]] \u0026gt;= a[i]) tt--; //入队新元素 q[++tt] = i; //只要过了k个数 就要输出队头元素 if(i \u0026gt;= k - 1) printf(\u0026#34;%d \u0026#34;,a[q[hh]]); } printf(\u0026#34;\\n\u0026#34;); hh = tt = 0; for(int i = 0 ; i \u0026lt; n ; i ++){ if(hh \u0026lt;= tt \u0026amp;\u0026amp; i - k + 1 \u0026gt; q[hh]) hh++; while(hh \u0026lt;= tt \u0026amp;\u0026amp; a[q[tt]]\u0026lt;= a[i]) tt--; q[++tt] = i; if(i \u0026gt;= k - 1) printf(\u0026#34;%d \u0026#34;,a[q[hh]]); } return 0; } KMP # KMP是一种字符串匹配算法,该算法充分体现了利用已有信息降低操作数,即时间复杂度. 完整代码\n#include\u0026lt;iostream\u0026gt; using namespace std; const int M = 1e6 + 10, N = 1e5 + 10; //定义 字符串 str 与 模板串 ptn char str[M],ptn[N]; int n,m; // 定义next数组 int ne[N]; int main() { scanf(\u0026#34;%d%s%d%s\u0026#34;,\u0026amp;n,ptn + 1,\u0026amp;m,str+1); //next数组第一位是0 所以从第二位开始 // 计算next数组 for(int i = 2 , j = 0 ; i \u0026lt;= n ; i++) { // 如果j是0 就没办法再往前了 // 如果当前与 while(j \u0026amp;\u0026amp; ptn[i] != ptn[j + 1])j = ne[j]; if(ptn[i] == ptn[j+1]) j ++; ne[i] = j; } for(int i = 1 , j = 0 ; i \u0026lt;= m ; i++) { while(j \u0026amp;\u0026amp; str[i] != ptn[j + 1]) j = ne[j]; if(str[i] == ptn[j + 1]) j ++; if(j == n) { printf(\u0026#34;%d \u0026#34;,i - n); j = ne[j]; } } return 0; } Trie树(字典树) # “Trie这个名字取自“retrieval”，检索，因为Trie可以只用一个前缀便可以在一部字典中找到想要的单词。”\n什么是Trie树 # 高效地存储与查找字符串集合的数据结构.用树结构来存储字符串集合,举例: 对于某字符串集合{\u0026quot;abcde\u0026quot;,\u0026quot;abdcf\u0026quot;,\u0026quot;acde\u0026quot;,\u0026quot;acfd\u0026quot;,\u0026quot;abc\u0026quot;,\u0026quot;bd\u0026quot;}.有下面这种存储方法.带星号表示从头往下查找到这个地方算一个字符串, 基本思想 # 如果是存小写字母组成的字符串集合,那么a-z对应的是0-25,如果是大写字母或其他情况同理.每次新加一个字符串中的一个字符,都要给这个字符上一个序号idx.每个需要都要记录它的子节点.比如son[idx][u]记录了序号为idx的子节点u的下一个节点指向的序号.\n打个比方:字符串abcd存入时有这种情况\nson[0][\u0026#39;a\u0026#39; - \u0026#39;a\u0026#39;] = 1;//初始节点的后继节点a的序号是1 son[1][\u0026#39;b\u0026#39; - \u0026#39;a\u0026#39;] = 2;//序号为1的后继节点b的序号是2 son[2][\u0026#39;c\u0026#39; - \u0026#39;a\u0026#39;] = 3;//序号为2的后继节点c的序号是3 son[3][\u0026#39;d\u0026#39; - \u0026#39;a\u0026#39;] = 4;//序号为3的后继节点d的序号是4 如果我继续存入abcf\nson[0][\u0026#39;a\u0026#39; - \u0026#39;a\u0026#39;] = 1;//初始节点的后继节点a的序号是1 son[1][\u0026#39;b\u0026#39; - \u0026#39;a\u0026#39;] = 2;//序号为1的后继节点b的序号是2 son[2][\u0026#39;c\u0026#39; - \u0026#39;a\u0026#39;] = 3;//序号为2的后继节点c的序号是3 //abcf中abc节点都已经存过,所以不需要增加序号 //f属于abc这一子树的新节点,所以需要赋予新序号5 //如果要查找abcf后续节点x,则需要从5开始 //即son[5][x - \u0026#39;a\u0026#39;] = idx; idx表示 x 的序号,如果不存在则为0; son[3][\u0026#39;f\u0026#39; - \u0026#39;a\u0026#39;] = 5;//序号为3的后继节点f的序号是5 那么又一个问题来了。我怎么知道往下哪个是字符串结束呢？比如我存入abc和abcd两个字符串。怎么判断abc在里面。这里我们使用一个cnt[p]数组，该数组存的是以序号p的字符结尾的字符串个数. 。 依托这个数组,我们可以得到在字符串集合{\u0026quot;abc\u0026quot;,\u0026quot;abcd\u0026quot;}中cnt[3] = 1; cnt[4] = 1;代表以字符序号为3和4结尾的字符串各出现了一次.\n主要代码 # #include\u0026lt;iostream\u0026gt; using namespace std; const int N = 1e5 + 10; //son[i][j] 表示编号为i的j儿子的后继节点数 int son[N][26],cnt[N]; char str[N]; int n,idx; void insert(char x[]) { int p = 0; for(int i = 0 ; x[i] ;i++) { int u = x[i] - \u0026#39;a\u0026#39;; //如果不存在节点，则新建一个，然后新节点标号为++idx。 //++idx表示给新节点上个序号,盖个出生证明 if(!son[p][u]) son[p][u] = ++idx; //如何找到下一个节点? //son[p][u]为节点序号为 //p的节点的子节点为u的节点的下一个节点序号 p = son[p][u]; } //表示以节点序号为p结尾的字符串个数. cnt[p] ++; } int query(char x[]) { int p = 0; for(int i = 0 ; x[i] ; i++) { int u = x[i] - \u0026#39;a\u0026#39;; if(!son[p][u]) return 0 ; p = son[p][u]; } return cnt[p]; } int main() { scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); while(n --){ char opt; cin \u0026gt;\u0026gt; opt \u0026gt;\u0026gt; str; if(opt == \u0026#39;I\u0026#39;)insert(str); else printf(\u0026#34;%d\\n\u0026#34;,query(str)); } return 0; } 并查集 # 应用场景 # 适用于维护集合之间的合并，与查询两个数是否在同一个集合内的情况。\n核心代码 # int p[N]; // 压缩路径版本 // 即每次查询 都将集合中的节点指向根节点 int find(int x){ if (p[x] != x) p[x] = find(p[x]); return p[x]; } // 预处理，代表每一个数都属于单独的集合，集合编号为i for(int i = 1 ; i \u0026lt;= n ; i++) p[i] = i; //合并操作 void merge(int a,int b) { p[find(a)] = find(b); } //查询操作 void query(int a,int b) { if(find(a) == find(b)) puts(\u0026#34;Yes\u0026#34;); else puts(\u0026#34;No\u0026#34;); } 哈希表 # 哈希表存储结构 # 将一个集合中的数通过一个函数映射到另外一个集合中。例如离散化中，将大范围中的数据映射到小范围的区间上，这是一种哈希映射，但这种映射需要保存前后顺序，属于特殊的哈希映射。哈希表一般指比较一般情况下的映射。\n但是哈希映射函数可能会出现哈希冲突的情况，比如有一个数据范围为0~1e9的数组，映射到0~1e5范围内，使用的映射函数为h(x) = x MOD 1e5，这种情况可能会出现某两个数经过哈希映射函数计算的哈希值相同，就发生了冲突。这就是所谓的哈希冲突，解决哈希冲突一般有两种方法：开放寻址法和拉链法。\n开放寻址法 # 所谓开放寻址，就是某个点如果发生哈希冲突，就在这个点哈希值加一位置插入数据，如果这个点还有数，就继续往后加，直到为空。\n#include\u0026lt;iostream\u0026gt; #include \u0026lt;cstring\u0026gt; using namespace std; //一般取质数情况下，发生哈希冲突的概率较低。 //开放寻址法 一般要数组开大一点. //因为h[N]存的是哈希值为N的值是多少 const int N = 200003,null = 0x3f3f3f3f; //按位寻址法 int h[N]; int find(int x) { //负数模后是负数，所以加N int k = (x % N + N) % N; while(h[k] != null \u0026amp;\u0026amp; h[k] != x){ k++; //找到头还没找到 就从0开始 //一般不会出现找不到的情况，有的话就把数组开大 if(k == N) k = 0; } return k; } int main(){ int n; scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); //初始化全部为null 以便标记该位置没存过数 memset (h, null , sizeof h); while(n --) { char opt[2]; int x; scanf(\u0026#34;%s%d\u0026#34;,opt,\u0026amp;x); //先找到位置，如果是没有的话就返回null。 //插入就是把null赋值为x //查找的话 是null就是没找到 int k = find(x); if(*opt == \u0026#39;I\u0026#39;) h[k] = x; else { if(h[k] != null) puts(\u0026#34;Yes\u0026#34;); else puts(\u0026#34;No\u0026#34;); } } return 0; } 拉链法 # 所谓拉链法，就是某个点如果发生哈希冲突，就在这个点上建立一个链表，然后把数加到链表上。\n#include\u0026lt;iostream\u0026gt; #include \u0026lt;cstring\u0026gt; using namespace std; //一般取质数情况下，发生哈希冲突的概率较低。 const int N = 100003; // 拉链法 //定义链表，e[idx]存序号为idx的数值，ne[idx]存序号为idx的下一项; // h[k]存哈希值为k的第一个数的idx序号 int h[N],e[N],ne[N],idx; void insert(int x) { //负数模后是负数，所以加N int k = (x % N + N) % N; e[idx] = x; ne[idx] = h[k]; h[k] = idx ++; } bool find(int x) { int k = (x % N + N) % N; for(int i = h[k]; i != -1 ; i = ne[i]) { if(e[i] == x) return true; } return false; } int main(){ int n; scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); //初始化全部为-1 以便标记为空 memset (h, -1 , sizeof h); while(n --) { char opt[2]; int x; scanf(\u0026#34;%s%d\u0026#34;,opt,\u0026amp;x); if(*opt == \u0026#39;I\u0026#39;) insert(x); else { if(find(x)) puts(\u0026#34;Yes\u0026#34;); else puts(\u0026#34;No\u0026#34;); } } return 0; } 字符串哈希 # 将字符串转换为一串数字然后计算哈希值存入哈希表，如abcde中每个字母对应的ASCII码中的编号按顺序为1 2 3 4 5（计算方法为'a' - 'a' + 1，'b' - 'a' + 1，'c' - 'a' + 1等）那么可以将这段数字转换为P进制数，这样就可以区分不同字符串对应的哈希值。但是如果字符串位数比较多，会出现哈希值溢出的情况，那么就需要取模Q运算！\n//一般情况下 P = 131;//P = 131; Q = 1 \u0026lt;\u0026lt; 64; 也可以利用这个算法实现前缀哈希，即某个字符串前i位的哈希值。然后我们就可以通过这个数组计算某个子串的哈希值。\n"},{"id":22,"href":"/docs/chapter02/acwing/math/shulun/","title":"数论","section":"Math","content":" 质数 # 针对所有大于1的自然数定义的，只包含1和本身两个约数的自然数叫做质数（素数）。\n质数的判定 # 试除法 # bool is_prime(int n){ if(n \u0026lt; 2) return false; for(int i = 2; i \u0026lt;= n ; i++){ if(n % i == 0) return false; } return true; } O(n); 如果i包含其他因子，那么这因子应该是成双成对出现的。比如12的因子有{1,2,3,4,6,12}。 这里只需要遍历成对中的第一个就可以了， 如果n可以被d整除，证明d是n的一个因子，那么另外一个与其对应的因子是n除以n除以d的商。所以我只需要遍历到第一个因子就可以了，即d满足大于n除以d的商，d大于根号n就OK。时间复杂度可以降到根号n。\nbool is_prime(int n){ if(n \u0026lt; 2) return false; for(int i = 2; i \u0026lt;= n / i ; i++){ if(n % i == 0) return false; } return true; } O(sqrt(n)); 不使用sqrt(i)可以降低时间复杂度，每次循环都会计算一次。如果使用i * i \u0026lt;= n，则可能存在 i * i溢出风险，变成负值。\n分解质因数 # 什么是质因数？\n一个数的某对因子均为质数。比如6的因子有2和3，这对因子就是质因数。 从小到大枚举所有约数。\n试除法 # void divide(int n){ for(int i = 2; i \u0026lt;= n; i++) { if(n % i == 0) { } } } "},{"id":23,"href":"/docs/chapter02/acwing/base/search_and_graph/","title":"搜索与图论","section":"Base","content":" 图论 # Floyd算法 # 主要思想是: 循环邻接矩阵中查找每个点到另外一个点的最短距离，不仅是看直接距离，也还要通过计算中转点。比如计算A到B的距离，要比较A到C的距离与C到B的距离的和、A到B的直接距离的最小值来判断，中转点可以是其他节点，所以代码实现中出现了三重循环。\n//n为顶点个数 //第一轮循环为 选取中间点的个数 //第二三轮循环为 void floyd(){ for(int k = 1 ; k \u0026lt;=n ; k++) for(int i = 1 ; i \u0026lt;= n ;i ++) for(int j = 1 ; j \u0026lt;=n ;j ++) dic[i][j] = min(dic[i][j],dic[i][k] + dic[k][j]); } 模板题代码：\n#include\u0026lt;iostream\u0026gt; using namespace std; const int N = 210,INF = 1e9; int dic[N][N]; int n,m,Q; void floyd(){ for(int k = 1 ; k \u0026lt;=n ; k++) for(int i = 1 ; i \u0026lt;= n ;i ++) for(int j = 1 ; j \u0026lt;=n ;j ++) dic[i][j] = min(dic[i][j],dic[i][k] + dic[k][j]); } int main(){ scanf(\u0026#34;%d%d%d\u0026#34;,\u0026amp;n,\u0026amp;m,\u0026amp;Q); for(int i = 1 ; i \u0026lt;= n ;i ++) for(int j = 1 ; j\u0026lt;=n;j++) if(i == j) dic[i][j] = 0; else dic[i][j] = INF; while(m--) { int a,b,w; scanf(\u0026#34;%d%d%d\u0026#34;,\u0026amp;a,\u0026amp;b,\u0026amp;w); dic[a][b] = min(dic[a][b],w); } floyd(); while(Q--) { int a,b; scanf(\u0026#34;%d%d\u0026#34;,\u0026amp;a,\u0026amp;b); if(dic[a][b] \u0026lt; INF / 2) printf(\u0026#34;%d\u0026#34;,dic[a][b]); else printf(\u0026#34;impossible\u0026#34;); printf(\u0026#34;\\n\u0026#34;); } return 0; } "},{"id":24,"href":"/docs/chapter01/argo-datastru/","title":"算法竞赛常用STL","section":"第一章|基础知识储备","content":" 数据结构 # vector[可变数组] # vector是一种变长数组，即可以自动改变长度的数组。 头文件\n#include\u0026lt;vector\u0026gt; 初始化\n#include\u0026lt;iostream\u0026gt; #include\u0026lt;vector\u0026gt; using namespace std; int main () { //几种初始化的方法 vector\u0026lt;int\u0026gt; a;//定义一个vector 未初始化 输出》 0 vector\u0026lt;int\u0026gt; a(3);//定义一个长度为3的vector 未初始化 输出》0 0 0 vector\u0026lt;int\u0026gt; a(10, 3); //定义一个长度为10，且每个数赋值为3 //将向量b中从下标0 1 2（共三个）的元素赋值给a，a的类型为int型 //它的初始化不和数组一样 vector\u0026lt;int\u0026gt;a(b.begin(),b.begin+3); //从数组中获得初值 int b[7]={1,2,3,4,5,6,7}; vector\u0026lt;int\u0026gt; a(b,b+7）; for(auto x : a) {//遍历输出 cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } return 0; } 相关函数\na.size();//返回元素个数 a.resize();//改变大小 a.empty();//判断a是否为空，空则返回true，非空则返回false a.front(); //返回a的第1个元素,当且仅当a存在 a.back(); //返回vector的最后一个数 a.clear(); //清空a中的元素 a.pop_back(); //删除a向量的最后一个元素 a.push_back(5); //在a的最后一个向量后插入一个元素，其值为5 a.begin();// vector的第0个数 a.end();// vector的最后一个的数的后面一个数 //通常与for循环结合使用 ⑦倍增的思想\n[C++]系统为某一程序分配空间的所需时间，与空间大小无关，与申请次数有关如申请一个空间为1000 和 空间为1 申请1000次的所需时间差别是很大的，申请次数越多，越耗时间 支持比较运算 比较操作如==，！=，\u0026lt;，\u0026lt;，\u0026lt;=，\u0026gt;，\u0026gt;=\nint main () { //支持比较运算 vector\u0026lt;int\u0026gt; a(4, 3), b(3, 4); //a: 3 3 3 3 b:4 4 4 //比较原理字典序 (根据最前面那个判断，如果一样就往后比较) if (a \u0026lt; b) { puts(\u0026#34;a \u0026lt; b\u0026#34;); } return 0; } 遍历方法\nint main () { vector\u0026lt;int\u0026gt; a; for (int i = 0; i \u0026lt; 10; i ++) { a.push_back(i); } //三种遍历vector的方法 for (int i = 0; i \u0026lt; a.size(); i ++) { cout \u0026lt;\u0026lt; a[i] \u0026lt;\u0026lt; \u0026#39; \u0026#39;; } cout \u0026lt;\u0026lt; endl; for (auto i = a.begin(); i != a.end(); i ++) { cout \u0026lt;\u0026lt; *i \u0026lt;\u0026lt; \u0026#39; \u0026#39;; } cout \u0026lt;\u0026lt; endl; //C++11的新语法 for (auto x : a) { cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#39; \u0026#39;; } cout \u0026lt;\u0026lt; endl; return 0; } 结合算法库中的erase() reverse()\na.erase(p)//从a中删除迭代器p指定的元素，p必须指向c中的一个真实元素，不能是最后一个元素end() a.erase(b,e)//从a中删除迭代器对b和e所表示的范围中的元素，返回e vector\u0026lt;int\u0026gt; a={1,2,3,4,5}; reverse(a.begin(),a.end());//a的值为5，4，3，2，1 倒置 string[字符串] # 支持比较运算 比较操作如==，！=，\u0026lt;，\u0026lt;，\u0026lt;=，\u0026gt;，\u0026gt;= 头文件\n#include\u0026lt;string\u0026gt; 初始化\nstring a = \u0026#34;abc\u0026#34;; queue[队列]和priority_queue[优先队列，堆] # stack[栈] # deque[双向队列] # set[集合]和multiset # set（集合），是一个内部自动有序且不含重复元素的容器。 set可以在需要去重复元素的情况大放异彩，节省时间，减少思维量。 要使用set，需要添加头文件： 头文件\n#include\u0026lt;set\u0026gt; 初始化\nset\u0026lt;int\u0026gt; gather; map[映射]和multiset # unordered[哈希表] # bitset[压位] # 算法 # Algorithm[常用算法函数] # 其他 # C++ pair的基本用法总结（整理） - 知乎 `\n"},{"id":25,"href":"/docs/chapter02/acwing/base/greedy/","title":"贪心","section":"Base","content":" 与区间有关的问题 # "},{"id":26,"href":"/docs/chapter03/machine-learning/LinerRegression/","title":"线性回归","section":"机器学习","content":"数据集\nurl = \u0026#34;https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data\u0026#34; names = [\u0026#39;花萼-length\u0026#39;, \u0026#39;花萼-width\u0026#39;, \u0026#39;花瓣-length\u0026#39;, \u0026#39;花瓣-width\u0026#39;, \u0026#39;class\u0026#39;] dataset = pd.read_csv(url, names=names) # 下面我们提取数据集中花瓣宽度与花瓣长度数据，将花瓣数据分为训练数据与测试数据， # 训练数据用于训练线性回归模型，测试数据用于检测我们的模型的准确率。 # 最终我们要达到的效果是：输入花瓣宽度，通过模型预测花瓣宽度。 X = dataset[\u0026#34;花瓣-length\u0026#34;] Y = dataset[\u0026#34;花瓣-width\u0026#34;] X = X.values.reshape(len(X), 1) Y = Y.values.reshape(len(Y), 1) # 将数据集拆分数据集成训练集、测试集 from sklearn.model_selection import train_test_split X_train, X_test, Y_train, Y_test = train_test_split(X, Y, test_size=0.2, random_state=0) # 线性回归模型 regression = LinearRegression() regression.fit(X_train, Y_train) # 拟合 # LinearRegression(copy_X=True, fit_intercept=True, n_jobs=1, normalize=False) print(regression.intercept_) # 截距，以下画线结束 print(regression.coef_) # 斜率，回归系数 # 反映了x对y影响的大小 # 以下画线结束，表示模型自身的属性 # 区别于用户设置的参数 # array([ 0.2]) regression.predict([[6]]) # 对未知点进行预测，结果为数组 # array([ 1.6]) import matplotlib.pyplot as plt plt.scatter(X_train, Y_train, color=\u0026#39;red\u0026#39;) plt.plot(X_train, regression.predict(X_train), color=\u0026#39;green\u0026#39;) plt.xlabel(\u0026#34;Iris-length\u0026#34;) plt.ylabel(\u0026#34;Iris-width\u0026#34;) plt.title(\u0026#34;This is train dataset-kzb\u0026#34;) plt.show() plt.scatter(X_test, Y_test, color=\u0026#39;blue\u0026#39;) plt.plot(X_train, regression.predict(X_train), color=\u0026#39;green\u0026#39;) plt.xlabel(\u0026#34;Iris-length\u0026#34;) plt.ylabel(\u0026#34;Iris-width\u0026#34;) plt.title(\u0026#34;This is test dataset-kzb\u0026#34;) plt.show() "},{"id":27,"href":"/docs/notes/thinknote/00000/","title":"原初号","section":"小记","content":"为什么要记录？\n借用知乎上某位网友对问题“语言和文字有本质上的区别吗？”的回答：\n“文字又是对语言的记录。是为了从时间上，把过去的思维记录下来。所以本质上看文字是语言的扩张，是又一次信息传递的生产力革命。通过文字对语言的记录，使得瞬间的思维得以固定下来，这带来更多的经验。”\n“文字操纵思想，思想操控文字。”\n许多想法总是会在闲余时，在脑子中涌现，这些想法可能包括了一些自己经常思考的问题，比如对自己的某些问题的评价，一些事情的态度等等，但过后又会忘记。所以就想不如有什么思考或者想法，就记录下来吧。\n学习别人之长。\n现在是2023-06-18 00:16:38，午夜。当下目标是考研，大约还有188天，约莫6个月。是当前最要紧之事， 暂且先列一下吧，\n阅读计划（根据当前手里的书）：\n乔布斯专 沙丘 中央重大决策背后的故事（党史） 矛盾论导读 \u0026hellip;.. 当然是有空了读，眼下最重要的还是刷题，学习。 还有就是一个心理问题，下次说）\n努力和努力有用？\n生活处处有机会，看路（找准路子，这个路子可能并不是你以为正确的路子，可能需要超出自己当前的认知，所以说要适时扩大自己的认知，不要被周围的人所困）！\n123\n2023年8月9日\n关于生活，\n家人、朋友、自己、\n时间线 # 2023-07-02 # 记得滚动复习！少抽点时间给线代和概论。\n今天听了高数强化课 因为各种事情学习时间少吧。明天步入正轨\n2023-07-01 # 下半年第一天！不要急躁，一步步来。\n值班 莫得运动 今日 # 高数强化定积分，做例题。 408同步与互斥! 英语单词加阅读，阅读做的不好，不够细致。 明日 # 想一下定目标，每天线性代数和概率论小推进一点。 408继续往后推进 英语 细心！ 。。。。 2023-06-30 # 运动 但是室内 哇，六月最后一天，下半年第一天。 今日 # 高数强化跟进到定积分哩，习题也都跟着做，不过自习室调换确实有点小影响心情 408 操作系统 听完调度算法，题还没做。 英语背了单词，新背了三十多个 好多不会、、 明日 # 晚上可能要值班 不运动了 高数强化把定积分例题做完，快速把强化课过一遍。 408做完课后题，课往后推进一节。 英语背单词加阅读。 2023-06-29 # 小运动 今天原来都周四了。 今日 # 880第二章综合篇剩大题了，然后第三章积分开了，但是有点小困难。 英语只背了单词，因为开会没做题 408计组结束啦，操作系统第一章也结束了。但是和计组联系还是挺多的。 。。。。 明天 # 上午把积分例题做完搞懂，下午多花一个小时做数学， 英语中午抽会时间背单词。 下午加晚上看408 适量运动！ 2023-06-28 # 运动 今日完成 # 880第二章基础篇完成了！ 辅导讲义例题推进了一点。 英语一篇阅读\u0026amp;单词背诵 408 计组 I/O 加中断 计组剩最后一章啦！ 。。 明天 # 880第二章选择题\u0026amp;辅导讲义例题 英语一篇阅读\u0026amp;单词背诵 计组收尾！ 。。。 2023-06-27 # 运动 今日完成 # 880第二章基础题 做不动 因为很多证明题。 概率论基础阶段完成，高数基础阶段全部完成。 英语背单词 到一千词 408 进度到计组 第五章末尾 。 明日任务 # 880第二章基础题做完。 辅导讲义例题推进。 "}]