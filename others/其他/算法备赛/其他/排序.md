# 排序算法

## 实验介绍

信息获取后通常需要进行处理，处理后的信息其目的是便于人们的应用。信息处理方法有多种，通常有数据的排序、查找、插入、删除等操作。本章主要介绍几种简单的数据排序算法和高效的排序算法.

在比赛中，排序算法是必不可少的。虽然我们可能会直接使用 sort 等函数直接进行排序，但在有些特殊题目中，我们仍需使用到排序算法。

## 知识点

- 选择排序的原理以及代码编写
- 冒泡排序的原理以及代码编写
- 桶排序的原理以及代码编写
- 插入排序的原理以及代码编写
- 理解希尔排序
- 快速排序
- 归并排序的原理

## 时间复杂度分析![图片描述](D:\Course\笔记\算法备赛\aeaa2120caaa28b1feb1bb6e26cc6985-0.png)

## 简单排序算法

简单排序算法包括选择排序、冒泡排序、桶排序和插入排序，本节重点介绍以上四种简单排序算法。

### 选择排序

- #### 基本思想

每一趟从待排序的数据元素中选出最小（或最大）的一个元素，按照顺序放在待排序的数列的最前，直到全部待排序的数据元素排完。

- #### 排序过程

例如:

```txt
初始：[5 4 6 8 7 1 2 3]
第一趟排序后 1 [4 6 8 7 5 2 3]
第二趟排序后 1 2 [6 8 7 5 4 3]
第三趟排序后 1 2 3 [8 7 5 4 6]
第四趟排序后 1 2 3 4 [7 5 8 6]
第五趟排序后 1 2 3 4 5 [7 8 6]
第六趟排序后 1 2 3 4 5 6 [8 7]
第七趟排序后 1 2 3 4 5 6 7 [8]
最后排序结果 1 2 3 4 5 6 7 8
```

- #### 对应代码(以非递减排序为例)

	```java
	void select_Sort(int[] a){
		for(int i = 0;i < a.length; i++){
	        int k = i;
	        for(int j = i + 1;j < n;j++){
	            if(a[j]<a[k]) k = j;
	        }
	        if(k != i){
	            int temp = a[i];
	            a[i] = a[j];
	            a[j] = temp;
	        }
	    }
	}

### 冒泡排序

- #### 基本思想

所谓冒泡排序就是依次将两个相邻的数进行比较，大的在前面，小的在后面。

- 即先比较第一个数和第二个数，大数在前，小数在后，然后比较第 2 个数和第 3 个数，直到比较最后两个数
	- 第一趟排序结束后，最小数的数一定在最后
	- 第二趟排序在第一趟的基础上重复上述操作
	由于排序过程中总是大数在前，小数在后，相当于气泡上升，所以叫冒泡排序。
- 大数在前，小数在后排序后得到的是降序
- 小数在前，大数在后排序后得到的是升序结果
- **排序过程(降序)**

```txt
  初始数据：4 5 6 1 2 3
  第一趟：
  比较前两个数，   4比5小，交换位置     5 4 6 1 2 3
  比较第2第3个数， 4比6小，交换位置     5 6 4 1 2 3
  比较第3第4个数， 5比1大，位置不变     5 6 4 1 2 3
  比较第4第5个数， 1比2小，交换位置     5 6 4 2 1 3
  比较最后两个数， 1比3小，交换位置     5 6 4 2 3 1
  第一趟结束

  第二趟重复第一趟过程得到 6 5 4 3 2 1
  排序完毕。
```

可以发现，第二趟排序结束后，所有数据已经排好序了。实际上，我们在对于一组数据进行冒泡排序时，假如需要排列的数据个数为 n 个，那么 **n-1** 趟一定能排好序，比如因为第 2 趟都会有前 2 个小的数排序好，n-1 趟前 n-1 小的数已排好序，最后一个数自然也排好序了。

**对应代码:**

```java
static void BubbleSort(int arr[]){
    int n = arr.length;
    for(int i = 0; i < n - 1; i++){
        for(int j = 0; j < n - i - 1; j++){
            if(arr[j] > arr[j + 1]){
                int temp = arr[j + 1];
                arr[j + 1] = arr[j];
                arr[j] = temp;
            }
        }
    }
}
```
### 桶排序

- #### 基本思想

桶排序的思想是，若待排序的记录的关键字在一个明显有限范围内时，可设计有限个有序桶，每个桶只能装与之对应的值，顺序输出各桶的值，将得到有序的序列。简单来说，在我们可以确定需要排列的数组的范围时，可以生成该数值范围内有限个桶去对应数组中的数，然后我们将扫描的数值放入匹配的桶里的行为，可以看作是分类，在分类完成后，我们需要依次按照桶的顺序输出桶内存放的数值，这样就完成了桶排序。

例如，要求我们输入 n 个 0~9 之间的整数，由小到大排序输出，我们可以准备 10 个桶依次编号为 0~9。那么，输入的数 0 则入 0 号桶，1 入 1 号桶，依次类推。

- #### 如图所示

![图片描述](D:\Course\笔记\算法备赛\ab03a879c703383c91d48c90e4c254ab-0.png)

如上图琐事，我们已准备好 10 个空桶并编号。

下面我们依次输入 8 个整数，分别是 2，5，6，8，5，2，9，6，我们每输入一个数值就将其放入对应的桶。

输入完毕后桶内数据如图所示：

![图片描述](D:\Course\笔记\算法备赛\1a119a16798069ddb71bd32a9cafcfe4-0.png)

#### 桶排序过程：

- 如上图所示，2 号桶内有两个数字 2，5 号桶内有两个数字 5，6 号桶内有两个数字 6，8 号桶内有一个数字 8，9 号桶内有一个数字 9
- 然后我们按桶编号从小到大的顺序将桶内数字输出，得到 2，2，5，5，6，6，8，9，至此桶排序完成。

**注意**，桶排序需要注意适用范围，在已知所需排序数据的范围下可以使用，另外本次课程我们只讨论整型的情况，其他数据类型的情况下如何使用，感兴趣的小伙伴可以当作课外内容，自行了解哦。

#### 实现代码

```java
int maxN=10; //题目出现的数据的最大值
int a[]=new int[maxN];
int n;
Scanner in =new Scanner(system.in)
n=in.nextInt();
for(int i=0;i<n;i++)
{
  int key;
  key=in.nextInt();
  a[key]++;
}
for(int i=0;i<maxN;i++)
{
  for(int j=0;j<a[i];j++)
  {
      System.out.printf(i + " ");
  }
}
```

## 插入排序

### 基本思想

插入排序是一种简单的排序方法，时间复杂度为 O(n*n)，适用于数据已经排好序，插入一个新数据的情况。其算法的基本思想是，假设待排序的数据存放在数组 a[1...n] 中，增加一个节点 x 用于保存当前数据，进行比较，a[1]即作为有序区，a[2...n] 作为无序区。

- 从 i=2 起直至 i=n 为止，通过循环遍历，将 a[i] 放在恰当的位置，使 a[1...i] 数据序列有序

<img src="D:\Course\笔记\算法备赛\af44fbc3250dbb143a8b2fdc56b82c95-0.png" alt="图片描述" style="zoom:67%;" />

```txt
x=a[i] 将 x 与前 i-1 个数比较

j=i-1
while(x<a[j])  j-= 1,
  
将 a 数组的元素从 j 位置开始向后移动：

for k in range(j,i+1,-1):  
 
 a[k]=a[k-1]
 a[j]=x

生成包含 n 个数据的有序区
```

例如，我们现在有一个数组 a=[3 2 4 1 6 5 2 7]，需要使用插入排序进行排列。

**排序过程：**

```txt
第0步：[3] 2 4 1 6 5 2 7
第1步：[2 3] 4 1 6 5 2 7
第2步：[2 3 4] 1 6 5 2 7
第3步：[1 2 3 4] 6 5 2 7
第4步：[1 2 3 4 6] 5 2 7
第5步：[1 2 3 4 5 6] 2 7
第6步：[1 2 2 3 4 5 6] 7
第7步：[1 2 2 3 4 5 6 7]
```

#### 实现代码
