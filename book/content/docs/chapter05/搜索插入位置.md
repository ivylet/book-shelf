---
title: 搜索插入位置
date: 2023-02-27T18:17:27+08:00
---
## 题目
<div class="px-5 pt-4"><div class="_1l1MA"><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p>

<p>请必须使用时间复杂度为 <code>O(log n)</code> 的算法。</p>

<p>&nbsp;</p>

<p><strong>示例 1:</strong></p>

<pre><strong>输入:</strong> nums = [1,3,5,6], target = 5
<strong>输出:</strong> 2
</pre>

<p><strong>示例&nbsp;2:</strong></p>

<pre><strong>输入:</strong> nums = [1,3,5,6], target = 2
<strong>输出:</strong> 1
</pre>

<p><strong>示例 3:</strong></p>

<pre><strong>输入:</strong> nums = [1,3,5,6], target = 7
<strong>输出:</strong> 4
</pre>

<p>&nbsp;</p>

<p><strong>提示:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>4</sup></code></li>
	<li><code>-10<sup>4</sup> &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>
	<li><code>nums</code> 为&nbsp;<strong>无重复元素&nbsp;</strong>的&nbsp;<strong>升序&nbsp;</strong>排列数组</li>
	<li><code>-10<sup>4</sup> &lt;= target &lt;= 10<sup>4</sup></code></li>
</ul>
</div></div>

## 分析
这题主要是用二分查找来解决。直接进行遍历没有充分考虑到所给的数组有序的条件，以及时间复杂度的要求~
## 题解
```cpp
class Solution {
public:
    int searchInsert(vector<int>& nums, int target) {
        int high = nums.size() - 1;
        int low = 0;
        int mid = (high + low)/2;
        if(target > nums[high]) return high + 1;
        if(target <= nums[0]) return 0;
        while(1){
            if(nums[mid] == target) return mid;
            if(nums[mid] > target){
                if(target > nums[mid - 1]) return mid;
                if(target == nums[mid - 1]) return mid - 1;
                high = mid;
                mid = (high + low) / 2;
            }
            if(nums[mid] < target){
                if(target <= nums[mid + 1]) return mid + 1;
                low = mid;
                mid = (high + low) / 2;
            }
        }
    }
};
```
官解：
```cpp
class Solution { 
public: 
	int searchInsert(vector<int>& nums, int target) {
		int n = nums.size(); 
		int left = 0, right = n - 1, ans = n; 
		while (left <= right) { 
			int mid = ((right - left) >> 1) + left; 
			if (target <= nums[mid]) { 
				ans = mid; 
				right = mid - 1; 
			} 
			else { 
				left = mid + 1; 
			} 
		} 
		return ans; 
	} 
}; 
```
