## 快速排序
主要思想：在数组中选择一个值，然后遍历数组，比这个值大的放到这个值后边，比这个值小的放到这个值的前边。
代码：
```cpp
void quick_sort(int q[], int l, int r){
	if(l >= r) return;
	int x = q[(l + r) >> 1], i = l - 1, j = r + 1;
	while(i < j)
	{
		do i ++ ; while(q[i] > x);
		do j -- ; while(q[j] < x);
		if(i < j) swap(q[i],q[j]);
	} 
	quick_sort(q,l, j);
	quick_sort(q,j+1,r);
}
```
## 归并排序
主要思想: 将数组拆分为两部分，前半部分和后半部分，然后这两部分分别进行排序。排序完成后从这两个数组开头开始比较，较小的数先插入到数组头位置，以此类推。
```cpp
void merged_sort(int a[],int l,int r){
    if(l >= r) return;
    int mid = (l + r)>>1;
    merged_sort(a,l,mid);
    merged_sort(a,mid+1,r);
    int k = l,i = l,j = mid + 1;
    while(i <= mid&&j <= r){
        if(a[i] < a[j]) tmp[k++] = a[i++];
        else tmp[k++] = a[j++];
    }
    while(i <= mid)   tmp[k++] = a[i++];
    while(j <= r) tmp[k++] = a[j++];
    for(int i = l; i <= r ;i++) a[i] = tmp[i];
}
```
## 二分
算法思路：假设目标值在闭区间[l, r]中， 每次将区间长度缩小一半，当l = r时，我们就找到了目标值。
有单调性可以二分，使用二分不一定有单调性。
### 整数二分
版本1
当我们将区间[l, r]划分成[l, mid]和[mid + 1, r]时，其更新操作是r = mid或者l = mid + 1;，计算mid时不需要加1。

C++ 代码模板：
```cpp
int bsearch_1(int l, int r)
{
    while (l < r)
    {
        int mid = l + r >> 1;
        if (check(mid)) r = mid;
        else l = mid + 1;
    }
    return l;
}
```
版本2
当我们将区间[l, r]划分成[l, mid - 1]和[mid, r]时，其更新操作是r = mid - 1或者l = mid;，此时为了防止死循环，计算mid时需要加1。

C++ 代码模板：
```cpp
int bsearch_2(int l, int r)
{
    while (l < r)
    {
        int mid = l + r + 1 >> 1;
        if (check(mid)) l = mid;
        else r = mid - 1;
    }
    return l;
}
```
`check(mid)`函数一般表示数组的mid位是否大于等于要找的值，包含等于的情况则后边修改边界时是l或r等于mid。
两组差别是当更新边界时有`l = mid;r = mid - 1;`时，在计算mid时需要多加一来向上取整。
### 实数二分
比如求某个数开根号的结果，可以使用二分。
## 高精度
高精度适用于长数据运算，c++中进行长数据运算会出现溢出为负的情况，而java、python没有这种问题。
