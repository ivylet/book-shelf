---
title: 第四章|指令系统
weight: 4
---
# 指令系统
指令（机器指令）：是指计算机执行某种操作的命令，是计算机运行的最小功能单位。    
一台计算机的所有指令集合构成该计算机的指令系统，也称指令集。一台计算机只能执行自己指令系统中的指令，不能执行其他系统的指令。x86架构（一般是PC机）与ARM架构（一般是手机）的指令集不同。    
## 指令格式
操作码：做什么    
地址码（操作数）：对谁做    
一条指令通常包括操作码字段和地址码字段两部分。  
![image.png](https://cdn.staticaly.com/gh/ivylet/blog_picg-@master/img/202306161652839.png)
一条指令可能包括0、1、2、3、4个地址码。  
根据地址码数量不同，可以将指令分为零地址指令，一地址指令，二地址指令.....    
### 零地址指令
![image.png](https://cdn.staticaly.com/gh/ivylet/blog_picg-@master/img/202306161714778.png)    
只有操作码，没有操作数。      
这种指令有两种可能：
1. 不需要操作数的指令，比如空操作指令，停机指令，关中断指令等。
2. 在堆栈计算机中，通常将两个操作数隐含存放在栈顶和次栈顶，计算结构压回栈顶。
### 一地址指令
![image.png](https://cdn.staticaly.com/gh/ivylet/blog_picg-@master/img/202306161714092.png)     
有操作码和一个操作数。   
1. 只需要单操作数，如加1、减1、取反，求补等
   OP(A1)->A1，完成一条指令需要3次访存：取指->读A1->写A1
   需要两个操作数，
2. 需要两个操作数，但其中一个操作数隐含在某个寄存器（如隐含在ACC）
   (ACC)OP(A1)->ACC，完成一条指令需要2次访存，取指->读A1
### 二地址指令
![image.png](https://cdn.staticaly.com/gh/ivylet/blog_picg-@master/img/202306161712233.png)     
常用于需要两个操作数的算术运算、逻辑运算相关指令。   
(A1)OP(A2)->A1，完成一条指令通常需要访存4次，取指->读A1->读A2->写A1     
### 三地址指令
![image.png](https://cdn.staticaly.com/gh/ivylet/blog_picg-@master/img/202306161712560.png)    
常用于需要两个操作数的算术运算、逻辑运算相关指令。   
(A1)OP(A2)->A3，完成一条指令通常需要访存4次，取指->读A1->读A2->写A3        
### 四地址指令
![image.png](https://cdn.staticaly.com/gh/ivylet/blog_picg-@master/img/202306161716149.png)
(A1)OP(A2)->A3，A4为下一条将要执行的地址，完成一条指令通常需要访存4次，取指->读A1->读A2->写A3   
正常情况下：取指令后PC+1，指向下一条指令。  
四地址指令：执行指令后，将PC值修改为A4所指地址。   
n位地址码的直接寻址范围为2<sup>n</sup> ，若指令总长度固定不变，则地址吗数量越多，寻址能力越差。   
## 指令分类
### 按指令长度分类

例如双字长指令在取指时需要两次访存    
定长指令字结构： 指令系统中所有指令的长度都相等。定长操作码可以简化计算机硬件设计，提高指令译码和识别速度。     
变长指令字结构： 指令系统中各种指令的长度不等。   
### 按操作码长度分类
- 定长操作码：
指令系统中所有指令的操作码长度都相同。
例如n位操作码，最多支持2<sup>n</sup>条指令。
- 可变长操作码：
指令系统中所有指令的操作码长度可变。  
### 按操作类型分类
- 数据传送  （数据传送类）
  LOAD 把存储器中的数据放到寄存器中
  STORE 把寄存器中的数据放到存储器中
- 算数逻辑运算 （运算类）
  算数运算：加、减、乘、除、增一、减一、求补、浮点运算、十进制运算等   
  逻辑运算：与或非异或位操作、位测试、位清除、位求反。   
- 移位操作 （运算类）
  算术移位、逻辑移位、循环移位（带进位和不带进位）  
- 转移操作 （程序执行流的改变）
  无条件转移 JMP   
  条件转移  JZ：结果为0；JZ：结果溢出；JC：结果有进位；    
  调用和返回 CALL和RETURN      
  陷阱和陷阱指令   
- 输入输出操作 （输入输出类）
  CPU寄存器与IO端口之间的数据传送（端口即IO接口中的寄存器）
## 扩展操作码指令格式
为了使指令字长有限的前提下仍保持比较丰富的指令种类，可采取可变长操作码，即全部指令的操作码字段的位数不固定，且分散地放在指令字的不同位置上。 
举例：   
![image.png](https://cdn.staticaly.com/gh/ivylet/blog_picg-@master/img/202306161935378.png)   
设计扩展操作码指令格式时，必须注意：  
1. 不允许短码是长码的前缀，即短操作码不能与长操作码的前面部分的代码相同（类哈夫曼编码）   
2. 各指令的操作码一定不能重复
通常情况对于使用频率较高的指令，分配较短的操作码，对使用频率较低的指令，分配较长的操作码，从而尽可能减少指令译码和分析的时间。    
扩展操作码举例：     
![](https://cdn.staticaly.com/gh/ivylet/blog_picg-@master/img/202306162012979.png)
- 对于三地址指令，前四位为操作码，后十二位为三个操作数。操作码从0000开始到1110，留1111一种提供给三地址指令扩展。共有16-1 = 15种状态。     
- 对于二地址指令，前5-8位为操作码，后八位为两个操作数，操作码从0000-1011，留下1100、1101、1110、1111四种提供给一地址指令扩展，共有1\* 16 - 4= 12种。    
- 对于一地址指令，二地址指令留下的前7-8位和前9-12位为操作码，最后4位为操作数，操作码从00 0000-11 1101，留下11 1110和11 1111两种提供给零地址指令扩展，共有4 \* 16 - 2= 62种。   
- 对于零地址指令，一地址指令留下的第12位和最后四位为操作码，无操作数，操作码从0 0000-1 1111，共有2 \* 16 = 32种。  
设地址长度为m，上一层留出m中状态，下一层就可以扩展出m \* 2<sup>n</sup>种状态。实际情况根据不同地址指令种类多少进行扩展。
# 指令的寻址方式
## 指令寻址和数据寻址
每一条指令的执行部分分为“取指令”、”执行指令“两部分，在取完指令后，PC加“1”（一个指令字长）。   
### 指令寻址
#### 顺序寻址
对于定长指令字结构，通过程序计数器PC加1（1个指令字长），自动形成下一条指令的地址。 如果指令字长与存储字长都为2B，主存按字编址，则每次PC加1，如果指令字长与存储字长都为2B，主存按字节编址，则每条指令占两个地址，则每次PC加2。     
对于变长指令无法预先判断，所以CPU先读入指令，根据操作码判断这条指令的总字节数n，如果主存按字节编址，那么PC的值加n。 
#### 跳跃寻址
通过转移指令给出，如果是无条件转移JMP则PC值改为对应数。  
### 数据寻址
确定本条指令的地址码的真实地址。  即指令的地址码中的地址并不一定是真正的地址，是一种真实地址的表现形式。  数据寻址方式很多，但是如何标识让CPU用哪种寻址方式进行解读呢？指令中每个形式地址之前都会有几位二进制代码表示寻址方式。
## 常见数据寻址方式 
### 直接寻址
指令字中的形式地址A就是操作数的真实地址EA，即EA = A。例如进行加法运算，可以直接将A传给MAR。  
![image.png](https://cdn.staticaly.com/gh/ivylet/blog_picg-@master/img/202306162112728.png)

- 优点
  简单，指令执行阶段仅访问一次主存，不需要专门计算操作数的地址。
- 缺点
  A的位数决定了该指令操作数的寻址范围，操作数的地址不易修改。
一条指令的执行，取指令访存一次，执行指令访存一次，暂不考虑存结果，共访存2次
### 间接寻址
指令中给出的地址码是存放有效地址的主存单元地址，即通过地址码找到真正的地址，通过真正的地址再找到有效地址EA。也可以有多重间接寻址。     
![image.png](https://cdn.staticaly.com/gh/ivylet/blog_picg-@master/img/202306162111362.png)
- 优点
  可扩大寻址范围（有效地址EA的位数大于形式地址A的位数），便于编制程序（用于间接寻址可以方便地完成子程序返回）。
- 缺点
  指令执行的过程中要多次访存（一次间接寻址需要两次访存，多次寻址需根据存储字的最高位确定几次访存）。  
一条指令的执行：取指令访存一次，执行指令访存两次，暂不考虑存结果，共访存3次。若为多重间接寻址，则执行指令访存多次。
### 寄存器寻址
在指令字中直接给出操作数所在的寄存器编号，即EA=R，其操作数在由R所指的寄存器内。  
![image.png](https://cdn.staticaly.com/gh/ivylet/blog_picg-@master/img/202306162118257.png)
- 优点
  在执行阶段不访问主存，只访问寄存器。指令字短且执行速度块，支持向量/矩阵运算。
- 缺点
  寄存器价格昂贵，计算机中寄存器个数有限。
一条指令的执行，取指令访存一次，执行指令访存零次，暂不考虑存结果，共访存1次。 
### 寄存器间接寻址
通过找寄存器编号，寄存器中的内容就是操作数的地址。 就是寄存器寻址和间接寻址的叠加态！ 比一般间接寻址要快，取指令访存一次，执行指令访存一次（因为操作数在主存中），共访存2次。  
### 隐含寻址
不是明显地给出操作数的地址，而是在指令中隐含着操作数的地址。
![image.png](https://cdn.staticaly.com/gh/ivylet/blog_picg-@master/img/202306162126001.png)
- 优点
  有利于缩短指令字长
- 缺点
  需增加存储操作数或隐含地址的硬件。
### 立即寻址
形式地址A就是操作数本身，又称为立即数，一般采取补码形式，#表示立即寻址特征。
- 优点
  指令执行阶段不访问主存，指令执行时间最短。
- 缺点A的位数限制了立即数的范围，如果A的位数为n，且立即数采用补码时，可表示的数据范围为-2<sup>n-1</sup>~2<sup>n-1</sup> - 1。
一条指令的执行，取指令访存一次，执行指令访存零次，暂不考虑存结果，共访存1次。 
### 基址寻址
以程序的起始存放地址作为“起点”。    
将CPU中基址寄存器（BR）的内容加上指令格式中的形式地址A，从而形成操作数的有效地址，即EA = （BR）+ A； 
![](https://cdn.staticaly.com/gh/ivylet/blog_picg-@master/img/202306162140502.png)    
或在指令中指出要使用哪个通用寄存器作为基址寄存器使用。  
![image.png](https://cdn.staticaly.com/gh/ivylet/blog_picg-@master/img/202306162142584.png)
指寄存器编号的位数需要根据寄存器总数来确定，如果有8个通用寄存器，就需要3个bit指明寄存器。   
例如执行一个四则运算程序，可以将数据和指令放到连续的地址上，那么当要使用某变量时，根据程序开始的地址，这段地址存到基址寄存器中，然后通过基址寻址快速的找到变量的地址，不管这段程序地址在地址空间的哪一个地方。便于程序的“浮动”，方便实现多道程序并发运行。因为多道相同的程序中指令与数据的相对位置都是一样的，只需要修改程序起始位置即可。    
基址寄存器是面向操作系统的，其内容由操作系统或管理程序确定，在程序执行过程中，基址寄存器的内容不变（作为基地址），形式地址可变（偏移量）。一般BR或选择的某用于基址的通用寄存器中的内容。程序员无法修改。      
- 优点
  可以扩大寻址范围（基址寄存器的位数大于形式地址A的位数），用不不必考虑自己的程序存与主存的哪一空间区域，故有利于多道程序设计，以及可以编写浮动程序（整个程序都在内存中浮动）。   
### 变址寻址
以程序员自己决定的位置为“起点”。  
变址寄存器和基址寻址类似。 有效地址EA等于指令字中形式地址A与变址寄存器IX的内容相加之和，即EA = （IX） + A，其中IX可为变址寄存器（专用），也可以使用通用寄存器作为变址寄存器。   
![image.png](https://cdn.staticaly.com/gh/ivylet/blog_picg-@master/img/202306162200727.png)

变址寄存器是面向用户的，在程序执行过程中，变址寄存器的内容可由用户改变，（IX作为偏移量），形式地址A不变，（作为基准值），这点和基址寄存器不一样。   
例如，要进行对一个数组的求和，可以将指令中的A作为数组开头地址作为基准值，起始时IX的值为0，每次加后将IX中的值加1，直至求和完毕。变址寻址特别适合编址循环程序，偏移量（IX）的位数足以表示整个存储空间。   

### 相对寻址
以程序计数器PC所指地址为“起点”。  
### 堆栈寻址

# 程序的机器级代码表示
# CISC和RISC的基本概念

