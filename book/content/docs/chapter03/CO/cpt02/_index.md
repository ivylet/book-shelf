---
title: 第二章|数据的表示与运算
weight: 2
---
## 移位运算
移位：通过改变各个数码位和小数点的相对位置，从而改变各数码位的位权。可用移位运算实现乘法、除法。
注意：由于原、反、补码位数有限，因此某些时候算数移位不能精确等效乘法、除法
### 算数移位
#### 原码
原码的算数移位
符号位保持不变，仅对数值位进行移位。 
右移：高位补0，低位舍弃。
若舍弃的位=0，则相当于÷2；若舍弃的位≠0，则会丢失精度。
左移：低位补0，高位舍弃。
若舍弃的位=0，则相当于×2；若舍弃的位≠0，则会出现严重误差。
#### 反码
反码的算数移位
正数的反码与原码相同， 因此对正数反码的移位运算也和原码相同。 
- 右移：高位补0，低位舍弃。 
- 左移：低位补0，高位舍弃。
负数的反码数值位与原 码相反，因此负数反码的移位运算规则如下，
- 右移：高位补1，低位舍弃。 
- 左移：低位补1，高位舍弃。
#### 补码
补码的算数移位
正数的补码与原码相同， 因此对正数补码的移位运算也和原码相同。
- 右移：高位补0，低位舍弃。 
- 左移：低位补0，高位舍弃。 
负数补码的算数移位规则如下： 
- 右移（同反码）：高位补1，低位舍弃。 
- 左移（同原码）：低位补0，高位舍弃。
#### 总结
![image.png](https://cdn.staticaly.com/gh/ivylet/blog_picg-@master/img/202306052126017.png)
### 逻辑移位
逻辑右移：高位补0，低位舍弃。 逻辑左移：低位补0，高位舍弃。
可以把逻辑移位看作是对“无符号数”的算数移位。
### 循环移位
分为两种情况：
不带进位位：用移出的位补充到添补位。
带进位位：移出的位放到进位位，原进位位放到添补位。
## 运算器

ACC： 累加器，用于存放操作数，或运算结果。
MQ： 乘商寄存器，在乘、除运算时，用于存放操作数或运算结果。
X： 通用的操作数寄存器，用于存放操作数
ALU：算术逻辑单元，通过内部复杂的电路实现算数运算、逻辑运算

|  | 加 | 减 | 乘 | 除 |
|---|---|---|---|---  |
|ACC|被加数、和|被减数、差|乘积高位|被除数、余数|
|MQ| | |乘积、乘积低位|商|
|X|加|减|被乘数|除数|
## 定点数的表示
## 定点数的运算
定点数的小数点一般是固定的。
### 原码的除法
符号位单独处理，即对除数与被除数的符号位进行异或运算。
#### 恢复余数法
数值位取绝对值进行除法运算，符号位单独处理（进行异或运算）。
先默认商1，如果余数为负数即首位为1，则修正为商0。
##### 举例
设机器字长为5位（含1位符号位，n=4）
x=0.1011，y=0.1101，采用原码恢复余数法求x/y |x|=0.1011，|y|=0.1101，[|y|]<sub>补</sub>=0.1101，[−|y|]<sub>补</sub>=1.0011
![image.png](https://cdn.staticaly.com/gh/ivylet/blog_picg-@master/img/202306051540543.png)
计算机很傻，会先默认上商1，如果 搞错了再改上商0。并“恢复余数”。
###### 整体流程
1. 商先上1，即MQ的最后一位先赋为1
2. 求余数：
	ACC中的内容 减去 除数即通用寄存器中的内容。
	ACC 的内容 传入ALU 然后加上除数相反数的补码，完成减法运算，再返回ACC
	ACC + [−|y|]<sub>补</sub> --> ACC
3. 判断！
	若ACC的值为正数，则商1正确。
	若ACC的值为负数，即第一位为1，则判定应该商0而非商1。
	此时应该恢复余数，即ACC加上除数的补码，恢复余数。
	ACC + [|y|]<sub>补</sub> --> ACC
4. 逻辑左移
	ACC与MQ中的数整体逻辑左移，
	ACC中的余数丢去最高位，末尾补0。
	MQ中的商左移，末尾补上新的待计算位。
一般5位机器数中MQ5位，则最后的商就只有5位，ACC中最终余数5位。
###### 手算模拟
![image.png](https://cdn.staticaly.com/gh/ivylet/blog_picg-@master/img/202306051558910.png)
##### 总结
左移动n位确定n位商
#### 加减交替法（不恢复余数法）
前边同恢复余数法，就是在发现余数为负时，如何处理。
恢复余数法的方法是先加上[|y|]<sub>补</sub>，然后左移，然后处理下一位时再加上[-|y|]<sub>补</sub>，然后商1，再判断余数正负。
```text
记a为当前需要恢复余数的余数（为负数，因为负数才需要恢复）
b为除数绝对值的补码。
则操作为 a、a + b、2(a+b)、2(a+b) - b = 2a + b
```
![image.png](https://cdn.staticaly.com/gh/ivylet/blog_picg-@master/img/202306051628356.png)

则以上操作可以直接简化为，发现余数为负，则直接先左移一位然后加上[|y|]<sub>补</sub>，可以达到同样的效果，还少了一步操作。
![image.png](https://cdn.staticaly.com/gh/ivylet/blog_picg-@master/img/202306051632762.png)
注意！ 如果最后一个数得到的结果为负，则需要加上|y|]<sub>补</sub>来恢复余数！
加/减 n + 1次，先减 减完如果为余数正则确定一位商，否则需要一次加法运算才可以确定。如果最后结果余数为负数，则需要再加一次，固为n + 2 次。
移位 n 次，每次得到商都需要左移。

### 补码的除法
#### 加减交替法
与加减交替法有点类似。补码运算一般采用双符号位运算，符号位也参与运算。
补码除法：
- 符号位参与运算。
- 被除数/余数、除数采用双符号位

余数和除数同号，商1，余数 左移一位减去除数；
余数和除数异号，商0，余数 左移一位加上除数。 重复n次
##### 举例
设机器字长为5位(含1位符号位，n=4)，x = +0.1000，y = - 0.1011，采用补码加减交替除法求x/y。
[x]<sub>补</sub> = 00.1000，[y]<sub>补</sub> = 11.0101，[-y]<sub>补</sub> = 00.1010

![image.png](https://cdn.staticaly.com/gh/ivylet/blog_picg-@master/img/202306051657765.png)
###### 主要步骤
余数和除数同号，商1，余数 左移一位减去除数；
余数和除数异号，商0，余数 左移一位加上除数。 重复n次
### 除法总结
![image.png](https://cdn.staticaly.com/gh/ivylet/blog_picg-@master/img/202306051701057.png)
## 数据的存储与排列
### 大小端模式
一般数字分为最高有效字节`MSB`和最低有效字节`LSB`
例如：
4字节的int 存储 `01 23 45 67H`其十进制数为`19088743D`
其中`01`为最高有效字节，`67`为最低有效字节。
#### 大端模式
大端模式一般适合人类正常阅读。
按照地址从左往右排列，绝大部分人类阅读一般是从左往右，比如你看这个数字42316，都会认为4的位权是最大的，表示4万，然后是2千，3百等等。这就是大端模式，地址低位存数据高位。
#### 小端模式
小端模式适合机器读取数据。
机器读取数据时，一般是从低地址往高地址读取对应地址上的数据。然后CPU对数据处理时一般是进行加法运算，那么首先读取某个数据的低地址位更好，因为加法都是从低位开始加，不断加到高位。这就是小端模式，地址低位存数据低位。
![image.png](https://cdn.staticaly.com/gh/ivylet/blog_picg-@master/img/202306051723202.png)
### 边界对齐
_**一句话：K字节大小的数据必须要存储在K的整数倍的地址上**_
现代计算机通常是按字节编址，即每个字节对应一个地址。通常也支持按字，按半字，按字节寻址。 
假设存储字长为32位，则1个字为32bit，半字为16bit。每次访存只能读/写1个字。
所谓按字节寻址是，每次往后1B，即8bit；所谓按半字寻址是，每次往后2B，即16bit；寻找第几号编址就是往后几次，不同编址方式也可以转换，例如按字寻址2号位的地址就相当于按字节编址8号位的地址（逻辑左移2位），一般都是最终转换为按字节编址。
![image.png](https://cdn.staticaly.com/gh/ivylet/blog_picg-@master/img/202306051956972.png)
所谓边界对齐，就是4B的数据即4个字节的数据（int，float）只能占用4的整数倍数的地址，2B就只能占用2的整数倍的地址。而计算机每次读取数据都是读一个字或一个半字，也就是2B或1B，如果不使用对齐，在访问图2.11中的半字1时，需要先访问第二个半字的高位，然后再访问第三个半字的低位，需要访问两次，费时间。边界对齐是以空间换时间的。
## 浮点数的表示
定点数的缺陷：定点数表示的数字范围有限，不能无限制增加范围。
浮点数与科学记数法表示的思想类似。
![image.png](https://cdn.staticaly.com/gh/ivylet/blog_picg-@master/img/202306052029990.png)
例如用科学记数法表示的3.026 * 10<sup>11</sup>，可以转换为+11+3.026。其中11为阶码，3.026表示尾数。
阶码反映数据范围，以及小数点的位。
尾数反映数值部分的位数，与数值的精度。
![image.png](https://cdn.staticaly.com/gh/ivylet/blog_picg-@master/img/202306052043951.png)
例如其中的b = 0 10 0 01001 实际表示的数据应为+1.001，但是b丢失了最后一位，导数b最终的数为+ 1.000。但是为了避免精度损失最少，并且表示的范围尽量大，那就应该对浮点数进行规格化！
### 浮点数规格
与科学记数法类似，保证尾数部分的最高位不是无效位（不表示数据信息的位），以上图中的b为例，若b = 0 01 0 1001，即b = 2<sup>1</sup> * (2<sup>-1</sup> + 2<sup>-4</sup>) = +1.001 正确表示出了数据。这种情况为左规，尾数算数左移一位，阶码减1。同理当用当前的方法表示时，进行运算后，尾数部分溢出，则需要右规，即尾数算数右移，阶码加1。
![image.png](https://cdn.staticaly.com/gh/ivylet/blog_picg-@master/img/202306052102021.png)
#### 规格化
![image.png](https://cdn.staticaly.com/gh/ivylet/blog_picg-@master/img/202306052113642.png)
浮点数表示的范围也有限，对浮点数规格化一般称对尾数的规格化，注意补码表示最高位和符号位是不同的。
所以有没有一种规格，能够确定阶码，尾数用原码还是补码，各多少位呢？下面就来了1
### IEEE754表示
IEEE754就是一种标准！
## 浮点数的运算