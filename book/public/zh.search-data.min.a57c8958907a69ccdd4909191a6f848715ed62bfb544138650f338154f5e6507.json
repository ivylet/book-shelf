[{"id":0,"href":"/docs/chapter01/cpp-stl-argo/","title":"STL中常用算法","section":"第一章|基本语法储备","content":"\rSTL中常用算法\r#\rSTL中定义了常用的一些算法，比如遍历，查找，排序等一些算法。\n遍历\r#\rfor_each 查找\r#\rcount_if\r#\r函数原型为count_if(v.begin(),v.end(),comp)\nv.begin()为开始，v.end()为结束，comp为自定义判断函数。\n举个例子：\n排序\r#\r复制与拷贝\r#\r算术生成\r#\r集合算法\r#\r"},{"id":1,"href":"/docs/chapter01/datastru/","title":"常用算法储备知识","section":"第一章|基本语法储备","content":"\r时间复杂度\r#\r对数 ： 每轮排除一半情况 常用于二分法 指数：每轮分别出两倍情况 线性对数：一般为两层循环相互独立，一层为n一层为对数 常常出现在快速排序 空间复杂度\r#\r位运算\r#\r位运算有（\u0026amp;、|、^、~、\u0026raquo;、\u0026laquo;）这几种方法，以下为正且位数相同的二进制数进行的位运算，但是还会有其他特殊情况，比如二进制数非正，位数不同的情况。\n符号 描述 运算规则 \u0026amp; 与 两个位都为1时，结果才为1 | 或 两个位都为0时，结果才为0 ^ 异或 两个位相同为0，相异为1 ~ 取反 0变1，1变0 \u0026laquo; 左移 各二进位全部左移若干位，高位丢弃，低位补0 \u0026raquo; 右移 各二进位全部右移若干位，对无符号数，高位补0，有符号数，各编译器处理方法不同 按位与运算符（\u0026amp;）\r#\r定义：参加运算的两个数据，按二进制位进行\u0026quot;与\u0026quot;运算。\n运算规则：同时为1才为1，\n0\u0026amp;0=0 0\u0026amp;1=0 1\u0026amp;0=0 1\u0026amp;1=1 //两位同时为1，结果才为1，否则结果为0。 例如：5\u0026amp;7 即 0000 0101\u0026amp; 0000 0111 = 0000 0101，因此 5\u0026amp;7 的值为5。\n注意：负数按补码形式参加按位与运算。\n与运算的用途：\n清零 如果想将一个单元清零，即使其全部二进制位为0，只要与一个各位都为零的数值相与，结果为零。 取一个数的指定位 比如取数 X=1011 1001 的低4位，只需要另找一个数Y，令Y的低4位为1，其余位为0，即Y=0000 1111，然后将X与Y进行按位与运算（X\u0026amp;Y=0000 1001）即可得到X的指定位。 判断奇偶 二进制的奇偶数只需要根据最未位是0还是1来决定，为0就是偶数，为1就是奇数。因此可以用if ((a \u0026amp; 1) == 0)代替if (a % 2 == 0)来判断a是不是偶数。 按位或运算符（|）\r#\r定义：参加运算的两个对象，按二进制位进行\u0026quot;或\u0026quot;运算。\n运算规则：有1就为1，\n0|0=0 0|1=1 1|0=1 1|1=1 //参加运算的两个对象只要有一个为1，其值为1。 例如：5|7即 0000 0101| 0000 0111 = 0000 0111，因此，5|7的值得7。　注意：负数按补码形式参加按位或运算。\n或运算的用途：\n常用来对一个数据的某些位设置为1 比如将数 X=1010 1001 的低4位设置为1，只需要另找一个数Y，令Y的低4位为1，其余位为0，即Y=0000 1111，然后将X与Y进行按位或运算（X|Y=1010 1001）即可得到。 异或运算符（^）\r#\r定义：参加运算的两个数据，按二进制位进行\u0026quot;异或\u0026quot;运算。\n运算规则：不同为1，相同为0\n0^0=0 0^1=1 1^0=1 1^1=0 //参加运算的两个对象，如果两个相应位相同为0，相异为1。 异或的几条性质:\n1、交换律 2、结合律 (a^b)^c == a^(b^c) 3、对于任何数x，都有 x^x=0，x^0=x 4、自反性: a^b^b=a^0=a; 异或运算的用途：\n翻转指定位 比如将数 X=1010 1110 的低4位进行翻转，只需要另找一个数Y，令Y的低4位为1，其余位为0，即Y=0000 1111，然后将X与Y进行异或运算（X^Y=1010 0001）即可得到。\n与0相异或值不变 例如：1010 1110 ^ 0000 0000 = 1010 1110\n交换两个数 例：(不使用中间变量，但是只能只能交换整型)\nvoid Swap(int \u0026amp;a, int \u0026amp;b){ if (a != b){ a ^= b; b ^= a; a ^= b; } } 取反运算符 (~)\r#\r定义：参加运算的一个数据，按二进制进行\u0026quot;取反\u0026quot;运算。\n运算规则：　直接取反\n~1=0 ~0=1 //对一个二进制数按位取反，即将0变1，1变0。 异或运算的用途：\n使一个数的最低位为零 使a的最低位为0，可以表示为：a \u0026amp; ~1。~1的值为 1111 1111 1111 1110，再按\u0026quot;与\u0026quot;运算，最低位一定为0。 因为\u0026quot; ~\u0026ldquo;运算符的优先级比算术运算符、关系运算符、逻辑运算符和其他运算符都高。 左移运算符（\u0026laquo;）\r#\r定义：将一个运算对象的各二进制位全部左移若干位（左边的二进制位丢弃，右边补0）。\n设 a=1010 1110，a = a\u0026laquo; 2 将a的二进制位左移2位、右补0，即得a=1011 1000。\n若左移时舍弃的高位不包含1，则每左移一位，相当于该数乘以2。\n右移运算符（\u0026raquo;）\r#\r定义：将一个数的各二进制位全部右移若干位，正数左补0，负数左补1，右边丢弃。\n例如：a=a\u0026raquo;2 将a的二进制位右移2位，左补0 或者 左补1得看被移数是正还是负。\n操作数每右移一位，相当于该数除以2。\n复合赋值运算符\r#\r位运算符与赋值运算符结合，组成新的复合赋值运算符，它们是：\n\u0026amp;= 例：a\u0026amp;=b 相当于 a=a\u0026amp;b |= 例：a|=b 相当于 a=a|b \u0026gt;\u0026gt;= 例：a\u0026gt;\u0026gt;=b 相当于 a=a\u0026gt;\u0026gt;b \u0026lt;\u0026lt;= 例：a\u0026lt;\u0026lt;=b 相当于 a=a\u0026lt;\u0026lt;b ^= 例：a^=b 相当于 a=a^b 运算规则：和前面讲的复合赋值运算符的运算规则相似。\n不同长度的数据进行位运算：如果两个不同长度的数据进行位运算时，系统会将二者按右端对齐，然后进行位运算。\n"},{"id":2,"href":"/docs/chapter01/cpp-stl-intro/","title":"C++ STL","section":"第一章|基本语法储备","content":"\r什么是C++标准模板库（STL）？\r#\r标准模板库 STL（Standard Template Library），是 C++ 标准库的一部分，不需要单独安装，只需要#include 头文件。\nC++ 对模板（Template）支持得很好，STL 就是借助模板把常用的数据结构及其算法都实现了一遍，并且做到了数据结构和算法的分离。\nC++ 语言的核心优势之一就是便于软件的复用。\nC++ 语言有两个方面体现了复用：\n面向对象的继承和多态机制 通过模板的概念实现了对泛型程序设计的支持 C++中的模板，就好比英语作文的模板，只换主题，不换句式和结构。对应到C++模板，就是只换类型，不换方法。\nSTL有什么优势？\r#\rSTL封装了很多实用的容器，省时省力，能够让你将更多心思放到解决问题的步骤上，而非费力去实现数据结构诸多细节上，像极了用python时候的酣畅淋漓。\nSTL到底有什么？\r#\r六大部件:\n容器 分配器 算法 迭代器 适配器 仿函数 自定义\r#\rvector 矢量\r#\r定义\r#\r使用前需添加头文件\n#include\u0026lt;vector\u0026gt; using namespace std; 像定义变量一样定义vector变量：\nvector\u0026lt;类型名\u0026gt; 变量名; 类型名可以是int、double、char、struct，也可以是STL容器：vector、set、queue。\nvector\u0026lt;int\u0026gt; name; vector\u0026lt;double\u0026gt; name; vector\u0026lt;char\u0026gt; name; vector\u0026lt;struct node\u0026gt; name; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; name; vector数组就是一个一维数组,如果定义成vector数组的数组，那就是二维数组**。**\nvector\u0026lt;int\u0026gt; array[SZIE]; //二维变长数组 在此，我送你一句话非常受用的话：低维是高维的地址。\n二维数组中，它的一维形式就是地址。例如：\n#include \u0026lt;iostream\u0026gt; using namespace std; int main(){ int arr[3][2];//定义一个3行2列的地址 cout\u0026lt;\u0026lt;arr[0]\u0026lt;\u0026lt;endl; //输出arr第1行的地址 cout\u0026lt;\u0026lt;arr[1]\u0026lt;\u0026lt;endl; //输出arr第2行的地址 cout\u0026lt;\u0026lt;arr[2]\u0026lt;\u0026lt;endl; //输出arr第3行的地址 return 0; } 输出：\n0x61fe00 //arr第1行的地址 0x61fe08 //arr第2行的地址 0x61fe10 //arr第3行的地址 所以，vector容器也可以这样理解。\n常用函数\r#\r1.构造函数\r#\rvector():创建一个空vector vector(int nSize):创建一个vector,元素个数为nSize vector(int nSize,const t\u0026amp; t):创建一个vector，元素个数为nSize,且值均为t vector(const vector\u0026amp;):复制构造函数 vector(begin,end):复制[begin,end)区间内另一个数组的元素到vector中 2.增加函数\r#\rvoid push_back(const T\u0026amp; x):向量尾部增加一个元素X iterator insert(iterator it,const T\u0026amp; x):向量中迭代器指向元素前增加一个元素x iterator insert(iterator it,int n,const T\u0026amp; x):向量中迭代器指向元素前增加n个相同的元素x iterator insert(iterator it,const_iterator first,const_iterator last):向量中迭代器指向元素前插入另一个相同类型向量的[first,last)间的数据 3.删除函数\r#\riterator erase(iterator it):删除向量中迭代器指向元素 iterator erase(iterator first,iterator last):删除向量中[first,last)中元素 void pop_back():删除向量中最后一个元素 void clear():清空向量中所有元素 4.遍历函数\r#\rreference at(int pos):返回pos位置元素的引用 reference front():返回首元素的引用 reference back():返回尾元素的引用 iterator begin():返回向量头指针，指向第一个元素 iterator end():返回向量尾指针，指向向量最后一个元素的下一个位置 reverse_iterator rbegin():反向迭代器，指向最后一个元素 reverse_iterator rend():反向迭代器，指向第一个元素之前的位置 5.判断函数\r#\rbool empty() const:判断向量是否为空，若为空，则向量中无元素 6.大小函数\r#\rint size() const:返回向量中元素的个数 int capacity() const:返回当前向量所能容纳的最大元素值 int max_size() const:返回最大可允许的vector元素数量值 7.其他函数\r#\rvoid swap(vector\u0026amp;):交换两个同类型向量的数据 void assign(int n,const T\u0026amp; x):设置向量中前n个元素的值为x void assign(const_iterator first,const_iterator last):向量中[first,last)中元素设置成当前向量元素 访问容器内元素\r#\rvector一般有两种访问方式：\n（1）通过下标访问\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; int main(){ vector\u0026lt;int\u0026gt; vi; vi.push_back(1); cout\u0026lt;\u0026lt;vi[0]\u0026lt;\u0026lt;endl; return 0; } 输出：\n1 （2）通过迭代器访问\n迭代器（iterator）可以理解为指针：\nvector\u0026lt;类型名\u0026gt;::iterator 变量名; 例如：\nvector\u0026lt;int\u0026gt;::iterator it; vector\u0026lt;double\u0026gt;::iterator it; 举个例子：\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; int main(){ vector\u0026lt;int\u0026gt; v; for (int i = 0; i \u0026lt; 5; i++) { v.push_back(i); } //v.begin()返回v的首元素地址 vector\u0026lt;int\u0026gt;::iterator it=v.begin(); for (int i = 0; i \u0026lt; v.size(); i++) { cout\u0026lt;\u0026lt;it[i]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } return 0; } 输出：\n0 1 2 3 4 for循环迭代部分也可以写成：\nvector\u0026lt;int\u0026gt;::iterator it=v.begin(); for (int i = 0; i \u0026lt; v.size(); i++) { cout\u0026lt;\u0026lt;*(it+i)\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } 也即是\nit[i] = *(it+i) //这两个写法等价 这是简单的常识，以后不再提及。\n与此同时，迭代器与for循环还有一种优雅的写法。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; int main(){ vector\u0026lt;int\u0026gt; v; for (int i = 0; i \u0026lt; 5; i++) { v.push_back(i); } //vector的迭代器不支持it\u0026lt;v.end()的写法，因此循环条件只能it!=v.end() for (vector\u0026lt;int\u0026gt;::iterator it=v.begin(); it!=v.end();it++) { cout\u0026lt;\u0026lt;*it\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } return 0; } 此种写法与遍历字符串有异曲同工之妙：\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; int main(){ string str; str=\u0026#34;Hello World\u0026#34;; for (int i = 0; str[i]!=\u0026#39;\\0\u0026#39;; i++) { cout\u0026lt;\u0026lt;str[i]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } return 0; } 输出：\nH e l l o W o r l d vector常用函数实例解析\r#\rpush_back() pop_back() size() clear() insert() erase() （1）push_back()\nvoid std::vector\u0026lt;int\u0026gt;::push_back(const int \u0026amp;__x) 见名知意，push_back(item)就是在vector后面添加一个元素item。\n用例：\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; int main(){ vector\u0026lt;int\u0026gt; v; for (int i = 0; i \u0026lt; 5; i++) { v.push_back(i); } for (int i = 0; i \u0026lt; v.size(); i++) { cout\u0026lt;\u0026lt;v[i]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } return 0; } 以前还要为定长数组内存分配而苦恼时，现在只需要无脑push_back()就好了。\n（2）pop_back()\nvoid std::vector\u0026lt;int\u0026gt;::pop_back() push和pop时一对反义词，学过数据结构的人都知道，栈元素的压入和弹出就是push和pop。\n须知，pop_back()一次弹出一个元素，vector容器就会减少一个预算。\n之所以叫容器，就是能往里面装一个一个的元素。\n用例：\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; int main(){ vector\u0026lt;int\u0026gt; v; for (int i = 0; i \u0026lt; 5; i++) { v.push_back(i); } cout\u0026lt;\u0026lt;\u0026#34;pop_back前:\u0026#34;\u0026lt;\u0026lt;endl; for (int i = 0; i \u0026lt; v.size(); i++) { cout\u0026lt;\u0026lt;v[i]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } cout\u0026lt;\u0026lt;endl; v.pop_back(); cout\u0026lt;\u0026lt;\u0026#34;pop_back后:\u0026#34;\u0026lt;\u0026lt;endl; for (int i = 0; i \u0026lt; v.size(); i++) { cout\u0026lt;\u0026lt;v[i]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } return 0; } 输出：\npop_back前: 0 1 2 3 4 pop_back后: 0 1 2 3 （3）size()\nstd::size_t std::vector\u0026lt;int\u0026gt;::size() szie()返回vector中所含元素的个数，时间复杂度为O(1)。\n用例：\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; int main(){ vector\u0026lt;int\u0026gt; v; for (int i = 0; i \u0026lt; 5; i++) { v.push_back(i); } cout\u0026lt;\u0026lt;v.size()\u0026lt;\u0026lt;endl; return 0; } 输出：\n5 （4）clear()\nvoid std::vector\u0026lt;int\u0026gt;::clear() clear()用于一键清空vector中的所有元素，时间复杂度为O(N)，其中N为vector中原属和元素的个数。\n用例：\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; int main(){ vector\u0026lt;int\u0026gt; v; for (int i = 0; i \u0026lt; 5; i++) { v.push_back(i); } for (int i = 0; i \u0026lt; v.size(); i++) { cout\u0026lt;\u0026lt;v[i]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } v.clear(); cout\u0026lt;\u0026lt;endl; cout\u0026lt;\u0026lt;\u0026#34;size = \u0026#34;\u0026lt;\u0026lt;v.size()\u0026lt;\u0026lt;endl; return 0; } 输出：\n0 1 2 3 4 size = 0 （5）insert()\ninsert(__position,__x); insert(要插入的地址，要插入的元素); 参数： __position：– A const_iterator into the %vector. __x:– Data to be inserted. 与push_back()无脑在尾部添加元素不同的是，insert()是根据指定位置在vector中插入元素。\n用例：\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; int main(){ vector\u0026lt;int\u0026gt; v; for (int i = 0; i \u0026lt; 5; i++) { v.push_back(i); } for (int i = 0; i \u0026lt; v.size(); i++) { cout\u0026lt;\u0026lt;v[i]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } v.insert(v.begin()+2,-1); //将-1插入v[2]的位置 cout\u0026lt;\u0026lt;endl; for (int i = 0; i \u0026lt; v.size(); i++) { cout\u0026lt;\u0026lt;v[i]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } return 0; } 输出：\n0 1 2 3 4 0 1 -1 2 3 4 （6）erase()\nerase(__position); 同样，与clear()简单粗暴清空vector不同的是erase()，删除指定位置的元素。\nerase()有两种用法：\n删除一个元素 删除一个区间内的元素 1.删除一个元素\nerase(__position); 用例：\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; int main(){ vector\u0026lt;int\u0026gt; v; for (int i = 0; i \u0026lt; 5; i++) { v.push_back(i); } for (int i = 0; i \u0026lt; v.size(); i++) { cout\u0026lt;\u0026lt;v[i]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } //删除v[3] v.erase(v.begin()+3); cout\u0026lt;\u0026lt;endl; for (int i = 0; i \u0026lt; v.size(); i++) { cout\u0026lt;\u0026lt;v[i]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } return 0; } 输出：\n0 1 2 3 4 0 1 2 4 2.删除一个区间内的元素\nerase(__positionBegin,__positionEnd); 即是删除[__positionBegin, __positionEnd)区间内的元素，注意：是左闭右开！\n用例：\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; int main(){ vector\u0026lt;int\u0026gt; v; for (int i = 0; i \u0026lt; 5; i++) { v.push_back(i); } for (int i = 0; i \u0026lt; v.size(); i++) { cout\u0026lt;\u0026lt;v[i]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } //删除v[1]到v[4]的元素 v.erase(v.begin()+1,v.begin()+4); cout\u0026lt;\u0026lt;endl; for (int i = 0; i \u0026lt; v.size(); i++) { cout\u0026lt;\u0026lt;v[i]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } return 0; } 输出：\n0 1 2 3 4 0 4 vector常见用途\r#\r（1）储存数据\nvector本身可以作为数组使用，而且在一些元素个数不确定的场合可以很好地节省空间。\n（2）用邻接表存储图\n使用vector实现邻接表，更为简单。\nset\r#\rset（集合），是一个内部自动有序且不含重复元素的容器。\nset可以在需要去重复元素的情况大放异彩，节省时间，减少思维量。\n要使用set，需要添加头文件：\n#include \u0026lt;set\u0026gt; using namespace std; 定义\r#\r像定义变量一样定义set变量：\nset\u0026lt;类型名\u0026gt; 变量名; 类型名可以是int、double、char、struct，也可以是STL容器：vector、set、queue。\n用例：\nset\u0026lt;int\u0026gt; name; set\u0026lt;double\u0026gt; name; set\u0026lt;char\u0026gt; name; set\u0026lt;struct node\u0026gt; name; set\u0026lt;set\u0026lt;int\u0026gt;\u0026gt; name; set数组的定义和vector相同：\nset\u0026lt;类型名\u0026gt; array[SIZE]; 例如：\nset\u0026lt;int\u0026gt; arr[10]; 访问set容器内的元素\r#\rset只能通过迭代器(iterator)访问：\nset\u0026lt;int\u0026gt;::iterator it; set\u0026lt;char\u0026gt;::iterator it; 这样，就得到了迭代器it，并且可以通过*it来访问set里的元素。\n注意：\n除了vector和string之外的STL容器都不支持*(it+i)的访问方式，因此只能按照如下方式枚举：\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;set\u0026gt; using namespace std; int main() { set\u0026lt;int\u0026gt; st; st.insert(5); st.insert(2); st.insert(6); for (set\u0026lt;int\u0026gt;::iterator it = st.begin(); it != st.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; endl; } return 0; } 输出：\n2 5 6 我们可以看到，原本无序的元素，被插入set集合后，set内部的元素自动递增排序，并且自动去除了重复元素。\nset常用函数实例解析\r#\r（1）insert()\n插入元素十分简单。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;set\u0026gt; using namespace std; int main() { set\u0026lt;char\u0026gt; st; st.insert(\u0026#39;C\u0026#39;); st.insert(\u0026#39;B\u0026#39;); st.insert(\u0026#39;A\u0026#39;); for (set\u0026lt;char\u0026gt;::iterator it = st.begin(); it != st.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; endl; } return 0; } （2）find()\nfind(value)返回的是set中value所对应的迭代器，也就是value的指针（地址）。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;set\u0026gt; using namespace std; int main() { set\u0026lt;int\u0026gt; st; for (int i = 1; i \u0026lt;= 3; i++) { st.insert(i); } set\u0026lt;int\u0026gt;::iterator it = st.find(2); //在set中查找2，返回其迭代器 cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; endl; // 以上可以直接x携程 cout \u0026lt;\u0026lt; *(st.find(2)) \u0026lt;\u0026lt; endl; return 0; } 输出：\n2 2 （3）erase()\nerase()有两种用法：删除单个元素、删除一个区间内的所有元素。\n1.删除单个元素\n删除单个元素有两种方法：\nst.erase(it)，其中it为所需要删除元素的迭代器。时间复杂度为O(1)。可以结合find()函数来使用。 #include \u0026lt;iostream\u0026gt; #include \u0026lt;set\u0026gt; using namespace std; int main() { set\u0026lt;int\u0026gt; st; st.insert(100); st.insert(200); st.insert(100); st.insert(300); // 删除单个元素 st.erase(st.find(100)); //利用find()函数找到100,然后用erase删除它 st.erase(st.find(200)); for (set\u0026lt;int\u0026gt;::iterator it = st.begin(); it != st.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; endl; } return 0; } 输出：\n300 st.erase(value)，value为所需要删除元素的值。其时间复杂度为O(logN)，N为set内的元素个数。 #include \u0026lt;iostream\u0026gt; #include \u0026lt;set\u0026gt; using namespace std; int main() { set\u0026lt;int\u0026gt; st; st.insert(100); st.insert(200); st.insert(100); st.insert(300); // 删除单个元素 st.erase(100); for (set\u0026lt;int\u0026gt;::iterator it = st.begin(); it != st.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; endl; } return 0; } 输出：\n200 300 2.删除一个区间内的所有元素\nst.erase(iteratorBegin , iteratorEnd)可以删除一个区间内的所有元素。\n其中iteratorBegin为所需要删除区间的起始迭代器\niteratorEnd为所需要删除区间的结束迭代器的下一个地址\n也即是**[iteratorBegin,iteratorEnd)**\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;set\u0026gt; using namespace std; //2.删除一个区间内的所有元素 int main() { set\u0026lt;int\u0026gt; st; st.insert(100); st.insert(200); st.insert(100); st.insert(300); set\u0026lt;int\u0026gt;::iterator it = st.find(200); st.erase(it, st.end()); for (it = st.begin(); it != st.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; endl; } return 0; } 输出：\n100 （4）size()\n不难理解，szie()用来实时获得set内元素的个数，时间复杂度为O(1)。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;set\u0026gt; using namespace std; int main() { set\u0026lt;int\u0026gt; st; st.insert(2); st.insert(5); st.insert(4); cout \u0026lt;\u0026lt; st.size() \u0026lt;\u0026lt; endl; return 0; } 输出：\n3 string\r#\rmap\r#\r定义\r#\rmap\r#\rmap\u0026lt;int,int\u0026gt; maps; 相关函数\r#\rmaps.insert() 插入 maps[key] = value;数组方式插入 maps.find(num) 查找一个元素 maps.clear()清空 maps.szie()长度 maps.begin()返回指向map头部的迭代器 maps.end()返回指向map末尾的迭代器 maps.erase(num)删除一个元素。 unordered_map\r#\r与map容器仅有一点不同的是，unordered_map是无序的。其底层采用的是哈希表存储，不会自动对存储的键值对进行排序。\nqueue\r#\rpriority\r#\rstack\r#\rpair\r#\ralgorithm\r#\r"},{"id":3,"href":"/docs/chapter03/CO/cpt02/","title":"第二章|数据的表示与运算","section":"计算机组成原理","content":"\r移位运算\r#\r移位：通过改变各个数码位和小数点的相对位置，从而改变各数码位的位权。可用移位运算实现乘法、除法。 注意：由于原、反、补码位数有限，因此某些时候算数移位不能精确等效乘法、除法\n算数移位\r#\r原码\r#\r原码的算数移位 符号位保持不变，仅对数值位进行移位。 右移：高位补0，低位舍弃。 若舍弃的位=0，则相当于÷2；若舍弃的位≠0，则会丢失精度。 左移：低位补0，高位舍弃。 若舍弃的位=0，则相当于×2；若舍弃的位≠0，则会出现严重误差。\n反码\r#\r反码的算数移位 正数的反码与原码相同， 因此对正数反码的移位运算也和原码相同。\n右移：高位补0，低位舍弃。 左移：低位补0，高位舍弃。 负数的反码数值位与原 码相反，因此负数反码的移位运算规则如下， 右移：高位补1，低位舍弃。 左移：低位补1，高位舍弃。 补码\r#\r补码的算数移位 正数的补码与原码相同， 因此对正数补码的移位运算也和原码相同。\n右移：高位补0，低位舍弃。 左移：低位补0，高位舍弃。 负数补码的算数移位规则如下： 右移（同反码）：高位补1，低位舍弃。 左移（同原码）：低位补0，高位舍弃。 总结\r#\r逻辑移位\r#\r逻辑右移：高位补0，低位舍弃。 逻辑左移：低位补0，高位舍弃。 可以把逻辑移位看作是对“无符号数”的算数移位。\n循环移位\r#\r分为两种情况： 不带进位位：用移出的位补充到添补位。 带进位位：移出的位放到进位位，原进位位放到添补位。\n运算器\r#\rACC： 累加器，用于存放操作数，或运算结果。 MQ： 乘商寄存器，在乘、除运算时，用于存放操作数或运算结果。 X： 通用的操作数寄存器，用于存放操作数 ALU：算术逻辑单元，通过内部复杂的电路实现算数运算、逻辑运算\n加 减 乘 除 ACC 被加数、和 被减数、差 乘积高位 被除数、余数 MQ 乘积、乘积低位 商 X 加 减 被乘数 除数 定点数的表示\r#\r定点数的运算\r#\r定点数的小数点一般是固定的。\n原码的除法\r#\r符号位单独处理，即对除数与被除数的符号位进行异或运算。\n恢复余数法\r#\r数值位取绝对值进行除法运算，符号位单独处理（进行异或运算）。 先默认商1，如果余数为负数即首位为1，则修正为商0。\n举例\r#\r设机器字长为5位（含1位符号位，n=4） x=0.1011，y=0.1101，采用原码恢复余数法求x/y |x|=0.1011，|y|=0.1101，[|y|]补=0.1101，[−|y|]补=1.0011 计算机很傻，会先默认上商1，如果 搞错了再改上商0。并“恢复余数”。\n整体流程\r#\r商先上1，即MQ的最后一位先赋为1 求余数： ACC中的内容 减去 除数即通用寄存器中的内容。 ACC 的内容 传入ALU 然后加上除数相反数的补码，完成减法运算，再返回ACC ACC + [−|y|]补 \u0026ndash;\u0026gt; ACC 判断！ 若ACC的值为正数，则商1正确。 若ACC的值为负数，即第一位为1，则判定应该商0而非商1。 此时应该恢复余数，即ACC加上除数的补码，恢复余数。 ACC + [|y|]补 \u0026ndash;\u0026gt; ACC 逻辑左移 ACC与MQ中的数整体逻辑左移， ACC中的余数丢去最高位，末尾补0。 MQ中的商左移，末尾补上新的待计算位。 一般5位机器数中MQ5位，则最后的商就只有5位，ACC中最终余数5位。 手算模拟\r#\r总结\r#\r左移动n位确定n位商\n加减交替法（不恢复余数法）\r#\r前边同恢复余数法，就是在发现余数为负时，如何处理。 恢复余数法的方法是先加上[|y|]补，然后左移，然后处理下一位时再加上[-|y|]补，然后商1，再判断余数正负。\n记a为当前需要恢复余数的余数（为负数，因为负数才需要恢复） b为除数绝对值的补码。 则操作为 a、a + b、2(a+b)、2(a+b) - b = 2a + b 则以上操作可以直接简化为，发现余数为负，则直接先左移一位然后加上[|y|]补，可以达到同样的效果，还少了一步操作。 注意！ 如果最后一个数得到的结果为负，则需要加上|y|]补来恢复余数！ 加/减 n + 1次，先减 减完如果为余数正则确定一位商，否则需要一次加法运算才可以确定。如果最后结果余数为负数，则需要再加一次，固为n + 2 次。 移位 n 次，每次得到商都需要左移。\n补码的除法\r#\r加减交替法\r#\r与加减交替法有点类似。补码运算一般采用双符号位运算，符号位也参与运算。 补码除法：\n符号位参与运算。 被除数/余数、除数采用双符号位 余数和除数同号，商1，余数 左移一位减去除数； 余数和除数异号，商0，余数 左移一位加上除数。 重复n次\n举例\r#\r设机器字长为5位(含1位符号位，n=4)，x = +0.1000，y = - 0.1011，采用补码加减交替除法求x/y。 [x]补 = 00.1000，[y]补 = 11.0101，[-y]补 = 00.1010\n主要步骤\r#\r余数和除数同号，商1，余数 左移一位减去除数； 余数和除数异号，商0，余数 左移一位加上除数。 重复n次\n除法总结\r#\r数据的存储与排列\r#\r大小端模式\r#\r一般数字分为最高有效字节MSB和最低有效字节LSB 例如： 4字节的int 存储 01 23 45 67H其十进制数为19088743D 其中01为最高有效字节，67为最低有效字节。\n大端模式\r#\r大端模式一般适合人类正常阅读。 按照地址从左往右排列，绝大部分人类阅读一般是从左往右，比如你看这个数字42316，都会认为4的位权是最大的，表示4万，然后是2千，3百等等。这就是大端模式，地址低位存数据高位。\n小端模式\r#\r小端模式适合机器读取数据。 机器读取数据时，一般是从低地址往高地址读取对应地址上的数据。然后CPU对数据处理时一般是进行加法运算，那么首先读取某个数据的低地址位更好，因为加法都是从低位开始加，不断加到高位。这就是小端模式，地址低位存数据低位。 边界对齐\r#\r一句话：K字节大小的数据必须要存储在K的整数倍的地址上 现代计算机通常是按字节编址，即每个字节对应一个地址。通常也支持按字，按半字，按字节寻址。 假设存储字长为32位，则1个字为32bit，半字为16bit。每次访存只能读/写1个字。 所谓按字节寻址是，每次往后1B，即8bit；所谓按半字寻址是，每次往后2B，即16bit；寻找第几号编址就是往后几次，不同编址方式也可以转换，例如按字寻址2号位的地址就相当于按字节编址8号位的地址（逻辑左移2位），一般都是最终转换为按字节编址。 所谓边界对齐，就是4B的数据即4个字节的数据（int，float）只能占用4的整数倍数的地址，2B就只能占用2的整数倍的地址。而计算机每次读取数据都是读一个字或一个半字，也就是2B或1B，如果不使用对齐，在访问图2.11中的半字1时，需要先访问第二个半字的高位，然后再访问第三个半字的低位，需要访问两次，费时间。边界对齐是以空间换时间的。\n浮点数的表示\r#\r定点数的缺陷：定点数表示的数字范围有限，不能无限制增加范围。 浮点数与科学记数法表示的思想类似。 例如用科学记数法表示的3.026 * 1011，可以转换为+11+3.026。其中11为阶码，3.026表示尾数。 阶码反映数据范围，以及小数点的位。 尾数反映数值部分的位数，与数值的精度。 例如其中的b = 0 10 0 01001 实际表示的数据应为+1.001，但是b丢失了最后一位，导数b最终的数为+ 1.000。但是为了避免精度损失最少，并且表示的范围尽量大，那就应该对浮点数进行规格化！\n浮点数规格\r#\r与科学记数法类似，保证尾数部分的最高位不是无效位（不表示数据信息的位），以上图中的b为例，若b = 0 01 0 1001，即b = 21 * (2-1 + 2-4) = +1.001 正确表示出了数据。这种情况为左规，尾数算数左移一位，阶码减1。同理当用当前的方法表示时，进行运算后，尾数部分溢出，则需要右规，即尾数算数右移，阶码加1。 规格化\r#\r浮点数表示的范围也有限，对浮点数规格化一般称对尾数的规格化，注意补码表示最高位和符号位是不同的。 所以有没有一种规格，能够确定阶码，尾数用原码还是补码，各多少位呢？下面就来了1\nIEEE754表示\r#\rIEEE754就是一种标准！\n浮点数的运算\r#\r"},{"id":4,"href":"/docs/chapter05/","title":"其他","section":"Docs","content":"\r飞机降落\r#\rdfs 暴力搜索\n#include\u0026lt;iostream\u0026gt; #include\u0026lt;cstring\u0026gt; using namespace std; const int N = 15; struct Plane{ int t; int d; int l; }p[N]; int n; bool st[N]; bool dfs(int u, int last){ if(u == n) return true; for(int i = 0 ; i \u0026lt; n ; i ++){ int t = p[i].t,d = p[i].d, l = p[i].l; //当前点 没选过 并且 飞机能够降落的最后时间 比上一架飞机的降落时间 靠后 //满足这种情况 可以降落 if(!st[i] \u0026amp;\u0026amp; t + d \u0026gt;= last){ st[i] = true; if(dfs(u + 1, max(last,t) + l)) return true; st[i] = false; } } return false; } int main(){ int T; cin \u0026gt;\u0026gt; T; while(T --){ cin \u0026gt;\u0026gt; n; for(int i = 0 ; i \u0026lt; n ; i ++){ cin \u0026gt;\u0026gt; p[i].t \u0026gt;\u0026gt; p[i].d \u0026gt;\u0026gt; p[i].l; } //每次结束后 都要 重新初始化st数组，避免上组数据 影响下一组 memset(st,0,sizeof st); if(dfs(0,0)) cout \u0026lt;\u0026lt; \u0026#34;YES\u0026#34; \u0026lt;\u0026lt; endl; else cout \u0026lt;\u0026lt; \u0026#34;NO\u0026#34; \u0026lt;\u0026lt; endl; } return 0; } $O(N!)$\n状态压缩DP\n$O(2^n /times nT)$\n#include\u0026lt;iostream\u0026gt; #include\u0026lt;cstring\u0026gt; using namespace std; const int N = 10,M = 1 \u0026lt;\u0026lt; N, INF = 0x3f3f3f3f; struct Plane { int t,d,l; }p[N]; int n; int f[M]; int main(){ int T; cin \u0026gt;\u0026gt; T; while(T --){ cin \u0026gt;\u0026gt; n; for(int i = 0 ; i \u0026lt; n ; i ++){ int t,d,l; cin \u0026gt;\u0026gt; t \u0026gt;\u0026gt; d \u0026gt;\u0026gt; l; p[i] = {t,d,l}; } memset(f,0x3f,sizeof f); f[0] = 0; for (int i = 1 ; i \u0026lt; 1 \u0026lt;\u0026lt; n; i ++) for (int j = 0 ; j \u0026lt; n; j++) { int t = p[j].t; int d = p[j].d; int l = p[j].l; if(i \u0026gt;\u0026gt; j \u0026amp; 1) { int last = f[i - (1 \u0026lt;\u0026lt; j)]; if (t + d \u0026gt;= last) f[i] = min(f[i],max(last,t) + l); } } if(f[(1 \u0026lt;\u0026lt; n) - 1] \u0026lt; INF) cout \u0026lt;\u0026lt; \u0026#34;YES\u0026#34; \u0026lt;\u0026lt; endl; else cout \u0026lt;\u0026lt; \u0026#34;NO\u0026#34; \u0026lt;\u0026lt;endl; } return 0; } 接龙数列\r#\r朴素DP\r#\r#include\u0026lt;iostream\u0026gt; using namespace std; const int N = 1e5 + 10; int num[N]; int f[N]; int n; int get_high(int x){ while(x/10){ x = x/10; } return x; } int get_low(int x){ return x % 10; } int main(){ scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); for(int i = 0 ; i \u0026lt; n ; i ++){ scanf(\u0026#34;%d\u0026#34;,\u0026amp;num[i]); } for(int i = 0 ; i \u0026lt; n ; i++) { f[i] = 1; for(int j = 0 ; j \u0026lt; i; j ++) { if(get_high(num[i]) == get_low(num[j])) { f[i] = max(f[i],f[j] + 1); } } } int res = 0; for(int i = 0 ; i \u0026lt; n ; i ++){ res = max(res,f[i]); } printf(\u0026#34;%d\u0026#34;,n - res); return 0; } 神奇做法\r#\r考虑到每个数列只有9种情况，即以1-9结尾。那么可以定义状态数组dp[10] 存储每个以i结尾的数组的长度。考虑到第i个数，是以a开头，b结尾的数。那么dp[b]有两种情况，一种是不加这个数，另外一种是加上这个数 然后就变成了dp[a] + 1，即以a结尾的数加上这个数 然后变成以b结尾的数，所以是dp[a] + 1;然后找到最大的状态就OK\n处理数字可以使用string 导入然后首位就是string[0] - \u0026lsquo;0\u0026rsquo;,末尾位就是string.back()- \u0026lsquo;0\u0026rsquo;\n#include\u0026lt;iostream\u0026gt; using namespace std; const int N = 10; int dp[N]; int n,ans; int main(){ scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); for(int i = 0 ; i \u0026lt; n ; i ++){ string num; cin \u0026gt;\u0026gt; num; // 这个数以 a 开头 b 结尾 int a = num[0] - \u0026#39;0\u0026#39;; int b = num.back() - \u0026#39;0\u0026#39;; // 以b结尾的可能 只有 // 这个数加上去 然后变成 以a结尾的 数加一， // 或者是 这个不加 dp[b] = max(dp[b],dp[a] + 1); ans = max(ans,dp[b]); } cout \u0026lt;\u0026lt; n - ans ; return 0; } "},{"id":5,"href":"/docs/chapter05/%E5%AF%BB%E6%89%BE%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E5%BF%83%E7%B4%A2%E5%BC%95/","title":"寻找数组的中心索引","section":"其他","content":"\r题目\r#\r给你一个整数数组\u0026nbsp;nums ，请计算数组的 中心下标 。\n数组 中心下标 是数组的一个下标，其左侧所有元素相加的和等于右侧所有元素相加的和。\n如果中心下标位于数组最左端，那么左侧数之和视为 0 ，因为在下标的左侧不存在元素。这一点对于中心下标位于数组最右端同样适用。\n如果数组有多个中心下标，应该返回 最靠近左边 的那一个。如果数组不存在中心下标，返回 -1 。\n\u0026nbsp;\n示例 1：\n输入：nums = [1, 7, 3, 6, 5, 6] 输出：3 解释： 中心下标是 3 。 左侧数之和 sum = nums[0] + nums[1] + nums[2] = 1 + 7 + 3 = 11 ， 右侧数之和 sum = nums[4] + nums[5] = 5 + 6 = 11 ，二者相等。 示例 2：\n输入：nums = [1, 2, 3] 输出：-1 解释： 数组中不存在满足此条件的中心下标。 示例 3：\n输入：nums = [2, 1, -1] 输出：0 解释： 中心下标是 0 。 左侧数之和 sum = 0 ，（下标 0 左侧不存在元素）， 右侧数之和 sum = nums[1] + nums[2] = 1 + -1 = 0 。 \u0026nbsp;\n提示：\n1 \u0026lt;= nums.length \u0026lt;= 104 -1000 \u0026lt;= nums[i] \u0026lt;= 1000 \u0026nbsp;\n分析\r#\r题解\r#\rclass Solution { public: int pivotIndex(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int rsum = 0; int lsum = 0; int len = nums.size(); for(int i = 0; i \u0026lt; len; i++){ rsum += nums[i]; } rsum = rsum - nums[0]; if(rsum == 0) return 0; for(int j = 1; j \u0026lt; len; j++){ rsum = rsum - nums[j]; lsum = lsum + nums[j - 1]; if(rsum == lsum) return j; } return -1; } }; "},{"id":6,"href":"/docs/chapter05/%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/","title":"搜索插入位置","section":"其他","content":"\r题目\r#\r给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。\n请必须使用时间复杂度为 O(log n) 的算法。\n\u0026nbsp;\n示例 1:\n输入: nums = [1,3,5,6], target = 5 输出: 2 示例\u0026nbsp;2:\n输入: nums = [1,3,5,6], target = 2 输出: 1 示例 3:\n输入: nums = [1,3,5,6], target = 7 输出: 4 \u0026nbsp;\n提示:\n1 \u0026lt;= nums.length \u0026lt;= 104 -104 \u0026lt;= nums[i] \u0026lt;= 104 nums 为\u0026nbsp;无重复元素\u0026nbsp;的\u0026nbsp;升序\u0026nbsp;排列数组 -104 \u0026lt;= target \u0026lt;= 104 分析\r#\r这题主要是用二分查找来解决。直接进行遍历没有充分考虑到所给的数组有序的条件，以及时间复杂度的要求~\n题解\r#\rclass Solution { public: int searchInsert(vector\u0026lt;int\u0026gt;\u0026amp; nums, int target) { int high = nums.size() - 1; int low = 0; int mid = (high + low)/2; if(target \u0026gt; nums[high]) return high + 1; if(target \u0026lt;= nums[0]) return 0; while(1){ if(nums[mid] == target) return mid; if(nums[mid] \u0026gt; target){ if(target \u0026gt; nums[mid - 1]) return mid; if(target == nums[mid - 1]) return mid - 1; high = mid; mid = (high + low) / 2; } if(nums[mid] \u0026lt; target){ if(target \u0026lt;= nums[mid + 1]) return mid + 1; low = mid; mid = (high + low) / 2; } } } }; 官解：\nclass Solution { public: int searchInsert(vector\u0026lt;int\u0026gt;\u0026amp; nums, int target) { int n = nums.size(); int left = 0, right = n - 1, ans = n; while (left \u0026lt;= right) { int mid = ((right - left) \u0026gt;\u0026gt; 1) + left; if (target \u0026lt;= nums[mid]) { ans = mid; right = mid - 1; } else { left = mid + 1; } } return ans; } }; "},{"id":7,"href":"/docs/chapter02/acwing/DP/DP/","title":"DP","section":"Dp","content":"\r背包DP\r#\r01背包\r#\r每件物品最多只用一次。\n有 N 件物品和一个容量是 V 的背包。每件物品只能使用一次。 第 i 件物品的体积是 vi，价值是 wi。 求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。\n输出最大价值。 2. 01背包问题 - AcWing题库\n#include\u0026lt;iostream\u0026gt; using namespace std; const int N = 1010; int v[N],w[N]; int m,n; int f[N][N]; int main(){ cin \u0026gt;\u0026gt; m \u0026gt;\u0026gt; n; for(int i = 1; i \u0026lt;= m;i++ ){ cin \u0026gt;\u0026gt; v[i] \u0026gt;\u0026gt; w[i]; } for(int i = 1; i \u0026lt;= m;i++){ for(int j = 0;j\u0026lt;= n;j++) { f[i][j] = f[i - 1][j]; if( j \u0026gt;= v[i]) //当可以装下的空间比第i个大才有可能存在装第i个物品的情况。 f[i][j] = max(f[i][j],f[i - 1][j - v[i]] + w[i]); } } cout \u0026lt;\u0026lt; f[m][n]; return 0; } 优化为二维\n#include\u0026lt;iostream\u0026gt; using namespace std; 状态表示\r#\rf(i,j) 表示从前i个背包中选，选出的总权值小于等于j的集合。 f(i,j)的值为总价值。\n集合 条件 只从前i中选 选出来的总权值 \u0026lt;j的集合 属性：最大值、最小值、数量。 状态计算\r#\r表示集合的划分 f(i,j)表示\n不包含第i个背包的最优解即f(i-1,j)， 包含第i个背包的最优解即f(i-1,j-w[i])+v[i]。即去掉第i个物品以及总权值减去第i个的权值。 总结：\r#\r第i个背包能不能放，能放就是集合划分第二种，不能放就是第一种。从一步开始走，然后逐渐解决全部问题。\n完全背包\r#\r每件物品可以用很多次。\n整数划分\n#include\u0026lt;iostream\u0026gt; using namespace std; const int N = 1000010,MOD = 1e9; int f[N]; int main(){ int m; cin \u0026lt;\u0026lt; m; f[0] = 1; for(int i = 1; i \u0026amp;lt;= m;i *= 2){ for(int j = i; j \u0026amp;lt;= m ;j++){ f[j] = (f[j] + f[j - i]) % MOD; } } cout \u0026gt;\u0026gt; f[m]; return 0; } 多重背包\r#\r每件物品\n分组背包\r#\r有很多组，每组有多种\n线性DP\r#\r最长上升子序列\n#include\u0026lt;iostream\u0026gt; using namespace std; const int N = 1010; int n; int a[N],f[N],g[N]; int main(){ scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); for(int i = 1 ; i \u0026lt;= n ; i ++){ scanf(\u0026#34;%d\u0026#34;,\u0026amp;a[i]); } for(int i = 1 ; i \u0026lt;=n ; i ++){ f[i] = 1; for(int j = 1 ; j \u0026lt; i ; j ++){ if(a[i] \u0026gt; a[j]){ if(f[j] + 1 \u0026gt; f[i]){ f[i] = f[j] + 1; g[i] = j; } } } } int k = 0; for(int i = 1 ; i \u0026lt;= n; i++){ // printf(\u0026#34;%d \u0026#34;,f[i]); if(f[i] \u0026gt; f[k]){ k = i; } } printf(\u0026#34;\\n%d\\n\u0026#34;,f[k]); for(int i = 0 ,len = f[k]; i \u0026lt; len ; i++){ printf(\u0026#34;%d \u0026#34;,a[k]); k = g[k]; } return 0; } 区间DP\r#\r其他\r#\r3417. 砝码称重 - AcWing题库 砝码称重问题\n#include\u0026lt;iostream\u0026gt; using namespace std; const int N = 110; const int MAX = 2e5+10,B = MAX / 2; int w[N]; bool f[N][MAX]; int main(){ int n,m; m = 0; scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); for(int i = 1 ; i \u0026lt;= n ; i++) scanf(\u0026#34;%d\u0026#34;,\u0026amp;w[i]),m += w[i]; f[0][B] = true; for(int i = 1 ; i \u0026lt;= n ; i++){ for(int j = -m ; j \u0026lt;= m ; j ++){ //以下三种情况只要有一种满足 则f[i][j + B] 就满足. //不选 f[i][j + B] = f[i - 1][j + B]; //选,但是放另外一边 if(j + w[i] \u0026lt;= m)f[i][j + B] |= f[i - 1][j + w[i] + B]; //选,但是放一起 if(j - w[i] \u0026gt;= -m)f[i][j + B] |= f[i - 1][j - w[i] + B]; } } int sum = 0; for(int i = 1 ; i \u0026lt;= m ; i++){ if(f[n][i + B]) sum ++; } printf(\u0026#34;%d\u0026#34;,sum); return 0; } "},{"id":8,"href":"/docs/chapter02/acwing/DP/package/","title":"背包问题","section":"Dp","content":"\r01 背包问题\r#\r每件物品最多只用一次。\n有 N 件物品和一个容量是 V 的背包。每件物品只能使用一次。 第 i 件物品的体积是 vi，价值是 wi。 求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。\n输出最大价值。 2. 01背包问题 - AcWing题库\n#include\u0026lt;iostream\u0026gt; using namespace std; const int N = 1010; int v[N],w[N]; int m,n; int f[N][N]; int main(){ cin \u0026gt;\u0026gt; m \u0026gt;\u0026gt; n; for(int i = 1; i \u0026lt;= m;i++ ){ cin \u0026gt;\u0026gt; v[i] \u0026gt;\u0026gt; w[i]; } for(int i = 1; i \u0026lt;= m;i++){ for(int j = 0;j\u0026lt;= n;j++) { f[i][j] = f[i - 1][j]; if( j \u0026gt;= v[i]) //当可以装下的空间比第i个大才有可能存在装第i个物品的情况。 f[i][j] = max(f[i][j],f[i - 1][j - v[i]] + w[i]); } } cout \u0026lt;\u0026lt; f[m][n]; return 0; } 优化为二维\n#include\u0026lt;iostream\u0026gt; using namespace std; 状态表示\r#\rf(i,j) 表示从前i个背包中选，选出的总权值小于等于j的集合。 f(i,j)的值为总价值。\n集合 条件 只从前i中选 选出来的总权值 \u0026lt;j的集合 属性：最大值、最小值、数量。 状态计算\r#\r表示集合的划分 f(i,j)表示\n不包含第i个背包的最优解即f(i-1,j)， 包含第i个背包的最优解即f(i-1,j-w[i])+v[i]。即去掉第i个物品以及总权值减去第i个的权值。 总结：\r#\r第i个背包能不能放，能放就是集合划分第二种，不能放就是第一种。从一步开始走，然后逐渐解决全部问题。\n完全背包\r#\r每件物品可以用很多次。\n整数划分\n#include\u0026lt;iostream\u0026gt; using namespace std; const int N = 1000010,MOD = 1e9; int f[N]; int main(){ int m; cin \u0026lt;\u0026lt; m; f[0] = 1; for(int i = 1; i \u0026amp;lt;= m;i *= 2){ for(int j = i; j \u0026amp;lt;= m ;j++){ f[j] = (f[j] + f[j - i]) % MOD; } } cout \u0026gt;\u0026gt; f[m]; return 0; } 多重背包\r#\r每件物品\n分组背包\r#\r有很多组，每组有多种\n"},{"id":9,"href":"/docs/chapter03/machine-learning/tools/","title":"常用工具","section":"机器学习","content":"\r数据集网站\r#\rUC Irvine Machine Learning Repository\n"},{"id":10,"href":"/docs/chapter05/part1/","title":"第一章","section":"其他","content":"线性表\n#include\u0026lt;stdio.h\u0026gt; #define ElementType int #define MAXSIZE 10 typedef struct SqList{ ElementType data[MAXSIZE]; int length; }SqList; void InitSqueList(SqList sq){ sq.length = 0; } void InsertSqueList(SqList* sq, int x){ (*sq).data[0] = x; } int main() { SqList sq; InitSqueList(sq); InsertSqueList(\u0026amp;sq,1); printf(\u0026#34;%d\\n\u0026#34;,sq.length); printf(\u0026#34;%d\u0026#34;,sq.data[0]); return 0; } 线性存储 链式存储\n"},{"id":11,"href":"/docs/chapter02/acwing/base/base-1/","title":"基础算法一","section":"Base","content":"\r快速排序\r#\r主要思想:\r#\r在数组中选择一个值，然后遍历数组，比这个值大的放到这个值后边，比这个值小的放到这个值的前边。\n代码实现\r#\rvoid quick_sort(int q[], int l, int r){ if(l \u0026gt;= r) return; int x = q[(l + r) \u0026gt;\u0026gt; 1], i = l - 1, j = r + 1; while(i \u0026lt; j) { do i ++ ; while(q[i] \u0026lt; x); do j -- ; while(q[j] \u0026gt; x); if(i \u0026lt; j) swap(q[i],q[j]); } quick_sort(q,l, j); quick_sort(q,j+1,r); } 为什么最后是j与j+1呢?\n因为范围确保的是左边是小于等于x，右边大于等于x。而循环判断结束的限制是i\u0026lt;j,则可能出现的情况是i=j或i = j + 1。如果是i=j+1那么左边为l到i不满足左边都小于等于x，因为q[i]\u0026gt;x。那为什么不是l到i-1呢？如果是l到i-1那么可能出现只有两个数的情况，然后划分的时候右边化为空集，左边为两个数的数组，此时陷入无尽循环。\n归并排序\r#\r主要思想:\r#\r将数组拆分为两部分，前半部分和后半部分，然后这两部分分别进行排序。排序完成后从这两个数组开头开始比较，较小的数先插入到数组头位置，以此类推。\n代码实现\r#\rvoid merged_sort(int a[],int l,int r){ if(l \u0026gt;= r) return; int mid = (l + r)\u0026gt;\u0026gt;1; merged_sort(a,l,mid); merged_sort(a,mid+1,r); int k = l,i = l,j = mid + 1; while(i \u0026lt;= mid\u0026amp;\u0026amp;j \u0026lt;= r){ if(a[i] \u0026lt; a[j]) tmp[k++] = a[i++]; else tmp[k++] = a[j++]; } while(i \u0026lt;= mid) tmp[k++] = a[i++]; while(j \u0026lt;= r) tmp[k++] = a[j++]; for(int i = l; i \u0026lt;= r ;i++) a[i] = tmp[i]; } 二分\r#\r主要思想\r#\r假设目标值在闭区间[l, r]中， 每次将区间长度缩小一半，当l = r时，我们就找到了目标值。 有单调性可以二分，使用二分不一定有单调性。\n整数二分\r#\r选择不同版本主要是看check函数，如果答案在[l, mid]和[mid + 1, r]与[l, mid - 1]和[mid, r]这两种情况中的一种，则需要判断是否在计算mid时多加一\n版本1\r#\r当我们将区间[l, r]划分成[l, mid]和[mid + 1, r]时，其更新操作是r = mid或者l = mid + 1;，计算mid时不需要加1。\nC++ 代码模板：\nint bsearch_1(int l, int r) { while (l \u0026lt; r) { int mid = l + r \u0026gt;\u0026gt; 1; if (check(mid)) r = mid; else l = mid + 1; } return l; } 版本1\r#\r当我们将区间[l, r]划分成[l, mid - 1]和[mid, r]时，其更新操作是r = mid - 1或者l = mid;，此时为了防止死循环，计算mid时需要加1。\nC++ 代码模板：\nint bsearch_2(int l, int r) { while (l \u0026lt; r) { int mid = l + r + 1 \u0026gt;\u0026gt; 1; if (check(mid)) l = mid; else r = mid - 1; } return l; } check(mid)函数一般表示数组的mid位是否大于等于要找的值，包含等于的情况则后边修改边界时是l或r等于mid。 两组差别是当更新边界时有l = mid;r = mid - 1;时，在计算mid时需要多加一来向上取整。\n实数二分\r#\r比如求某个数开根号的结果，可以使用二分。 举个例子，求实数n开三次方的结果，保留6位小数。\ndouble q(double a){return a*a*a;}//求三次方 double sancigen(double n){ double l = -n; double r = n; double mid = 0; while(l - r \u0026gt; 1e-7){//当左右边界很接近的时候 就已经满足了答案。 if(q(mid) \u0026gt; n) r = mid; else l = mid; mid = (l + r) / 2; } return l; } 高精度\r#\r应用场景\r#\r如果一个数据很大，大于int与long long的数据表示范围，即[-$2^{31}$,$2^{31} - 1$]和[-$2^{63}$,$2^{63} - 1$]无法表示.那么则需要进行高精度计算.c++中进行长数据运算会出现溢出为负的情况，而java、python没有这种问题（因为一般会自动转换为更大变量）。 一般情况为四种情况，大整数的加减乘除。\n计算前预处理\r#\r一般情况下，大数据int甚至long long存不下，我们可以使用数组存。一般使用大端模式，即高位存高位，低位存低位，便于高位进位，否则进位时需要把数组整体后移。 用vector存比较方便，因为有size()函数返回长度。 数据12345，在数组中存储的顺序是54321。\n加法\r#\r计算过程就是类似模拟加减法运算。\nvector\u0026lt;int\u0026gt; addBigInteger(vector\u0026lt;int\u0026gt; \u0026amp;A,vector\u0026lt;int\u0026gt; \u0026amp;B) { vector\u0026lt;int\u0026gt; C; int t = 0; for(int i = 0; i \u0026lt; A.size()|| i \u0026lt; B.size();i++) { if(i \u0026lt; A.size()) t += A[i]; if(i \u0026lt; B.size()) t += B[i]; C.push_back(t%10); t /= 10;//大于10则有进位。 } if(t)//最高位有进位，则再加一。 C.push_back(1); return C; } 减法\r#\r减法先考虑两个正数相减，其他情况可以转换为绝对值相加减，如两个负数相减可以转换为绝对值相加然后取反，正数负数相减可以转换为绝对值相减然后根据情况添加正负号。 可以先判断两个数哪个更大，用大的减去小的，再根据情况添加正负号。如果出现两个相同的数相减，需要处理前导0。\nbool cmp(vector\u0026lt;int\u0026gt; \u0026amp;A,vector\u0026lt;int\u0026gt; \u0026amp;B){ if(A.size() != B.size()) return A.size() \u0026gt; B.size(); for(int i = A.size() - 1; i \u0026gt;= 0;i--){ if(A[i] != B[i]) return A[i] \u0026gt; B[i]; } return true; } vector\u0026lt;int\u0026gt; subBigInteger(vector\u0026lt;int\u0026gt; \u0026amp;A,vector\u0026lt;int\u0026gt; \u0026amp;B) { vector\u0026lt;int\u0026gt; C; int t = 0; for(int i = 0;i \u0026lt; A.size();i++)//默认A.size()\u0026gt;=B.size() { t = A[i] + t; if(i \u0026lt; B.size()) t -= B[i]; C.push_back((t+10)%10); if(t \u0026gt;= 0) t = 0; else t = -1; //if(t \u0026gt;= 0) C.push_back(t); //else {C.push_back(t + 10);t = -1;} } while(C.size()\u0026gt;1\u0026amp;\u0026amp;C.back() == 0) C.pop_back();//处理前导0 return C; } 乘法\r#\r乘法一般考虑大数据与小数据相乘，直接模拟计算乘法的过程。\nvector\u0026lt;int\u0026gt; multBigInteger(vector\u0026lt;int\u0026gt; \u0026amp;A,int B) { vector\u0026lt;int\u0026gt; C; for(int i = 0,t =0;i \u0026lt; A.size() || t != 0;i++)//t != 0确保最高位进位 { if(i \u0026lt; A.size()) t = t + A[i] * B; C.push_back(t%10); t = t/10; } while(C.size() \u0026gt; 1 \u0026amp;\u0026amp; C.back() == 0)C.pop_back();//出现一个乘数为0的情况。 return C; } 除法\r#\r除法也是模拟的方法。不过细节稍微有点不同。\nvector\u0026lt;int\u0026gt; divBigInteger(vector\u0026lt;int\u0026gt; A,int B,int \u0026amp;d) { vector\u0026lt;int\u0026gt; C; d = 0; for(int i = A.size() - 1; i \u0026gt;=0;i--)//除法是从最高位开始除的，所以这里从最高位开始。 { d = A[i] + d*10;//列式除法最下方那个数字 C.push_back(d / B);//列式除法最上方那一行的数字入C； d = d % B;//算完后的余数，留给下一位计算。 } reverse(C.begin(),C.end());//由于C是正向加入，所以这里翻转。 while(C.size() \u0026gt; 1 \u0026amp;\u0026amp; C.back() == 0) C.pop_back();//除去前导0 return C; } 前缀和\r#\r前缀和是指用一个数组来存前i个数据的和，这样方便计算区间和的值。\n一维前缀和\r#\rconst int N = 100010; int s[N]; int a[N]; for(int i = 1; i \u0026lt;= n ;i++) { s[i] = s[i - 1] + a[i]; } 当要计算区间l到r的和时。\nprintf(\u0026#34;%d\u0026#34;,s[r] - s[l - 1]); 二维前缀和\r#\r计算前缀和数组\nconst int N = 1010; int a[N][N]; int s[N][N]; for(int i = 1;i \u0026lt;= n ;i++){ for(int j = 1;j \u0026lt;= m ;j++){ s[i][j] = a[i][j] + s[i][j - 1] + s[i-1][j] - s[i-1][j-1]; } } 求区间(i,j)到(k,l)内矩形内的和\nprintf(\u0026#34;%d\\n\u0026#34;,s[k][l] - s[k][j - 1] - s[i - 1][l] + s[i - 1][j - 1]); 差分\r#\r差分是指用一个数组来存相邻数的差，这样方便处理对区间内的数都加上某个数的操作。\n一维差分\r#\r定义插入函数\nconst int N = 100010; int arr[N]; int b[N]; void insert(int l,int r,int c) { b[l] += c; b[r + 1] -= c; } 区间内减去C\nb[l] = b[l] + c; b[r + 1] = b[r + 1] - c; ``` 求原数组，输出结果 ```cpp for(int i = 1;i \u0026lt;= n ;i++) { b[i] += b[i-1]; } for(int i = 1;i \u0026lt;= n ;i++) { printf(\u0026#34;%d \u0026#34;,b[i]); } 二维差分\r#\r定义插入函数\nconst int N = 1010; int n,m,q; int arr[N][N]; int b[N][N]; void insert(int x1,int y1,int x2,int y2,int c){ b[x1][y1] += c; b[x2 + 1][y1] -= c; b[x1][y2 + 1] -= c; b[x2 + 1][y2 + 1] += c; } 计算差分数组。\nwhile(q--){ int x1,x2,y1,y2,c; scanf(\u0026#34;%d%d%d%d%d\u0026#34;,\u0026amp;x1,\u0026amp;y1,\u0026amp;x2,\u0026amp;y2,\u0026amp;c); insert(x1,y1,x2,y2,c); } 逆运算求原数组并输出。\nfor(int i = 1; i\u0026lt;=n;i++) for(int j = 1;j\u0026lt;=m;j++){ b[i][j] += b[i-1][j] + b[i][j-1] - b[i-1][j-1]; } for(int i = 1;i \u0026lt;= n;i++){ for(int j = 1; j\u0026lt;=m;j++){ printf(\u0026#34;%d \u0026#34;,b[i][j]); } printf(\u0026#34;\\n\u0026#34;); } 双指针算法\r#\r一般用i,j两个指针来遍历数组。快速排序也使用了双指针的思想。 核心思想：\n将下面的朴素算法$O(n^2)$优化到$O(n)$\nfor(int i = 0;i\u0026lt;n;i++) { for(int j = 0; j \u0026lt; n ;j ++){ //具体逻辑 check(i,j); } } 基本模板：\nfor(int i = 0,j=0;i\u0026lt;n;i++) { while(i \u0026lt; j\u0026amp;\u0026amp;check(i,j))j++; //具体逻辑 } 求最长不重复子列长度\r#\r数组不含重复数字的最长子列的长度。 朴素做法是遍历所有i，j。但是根据分析后发现，如果区间内无重复子列，i往后移动出现了重复子列，那么j只有往后移动才可能消去这个子列。往左则不满足i移动前的条件，即当前是最长无重复子列。\nint a[N]; int s[N];//用于确定区间内是否有重复数组，这也可以使用哈希表来判断。 for(int i = 0,j = 0;i \u0026lt; n;i++){ s[a[i]] ++ ; while(s[a[i]] \u0026gt; 1){ //如果存在重复数，则j往前移动 //为什么不往后移动？因为当前j已经是满足上一个i的最右距离，只能往左了。 s[a[j]] --; j ++; } res = max(res,i - j + 1); } 位运算\r#\r常用操作\r#\r求n的二进制数的第k位，和第一个1的位置。\nint res = n\u0026gt;\u0026gt;k \u0026amp; 1;//将第k位右移到个位，然后与000001进行和运算。个位为1输出1否则输出0。 int lowbit(int n){ return n\u0026amp;(-n); //return n\u0026amp;(~x + 1); } int num = lowbit(n); 用例 判断一个数的二进制数有多少个1。\nint num = 0; while(x \u0026gt; 0){ x -= lowbit(x); num ++; } printf(\u0026#34;%d \u0026#34;,num); 离散化\r#\r主要思想\r#\r在一个长区间，是很长很长的区间中，存在零散的数据。这种情况下找区间内的值，如果一个个遍历会很费时（因为区间很长），所以有了离散化的想法。\n一般是将数据依照顺序来与自然数一一对应.如果有区间那么也添加到其中.\n以一个题目为例: 802. 区间和 - AcWing题库\n全部代码\r#\r#include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; typedef pair\u0026lt;int, int\u0026gt; PII; const int N = 300010; int n, m; int a[N], s[N];//定义离散化后的数组,与前缀和数组. vector\u0026lt;int\u0026gt; alls;//存储需要离散化的值,并将其与自然数映射. vector\u0026lt;PII\u0026gt; add, query;//存储添加数据对,与查询数据范围. int find(int x)//根据离散化的数查询自然数对应的位置. { int l = 0, r = alls.size() - 1; while (l \u0026lt; r) { int mid = l + r \u0026gt;\u0026gt; 1; if (alls[mid] \u0026gt;= x) r = mid; else l = mid + 1; } return r + 1;//因为要使用前缀和,所以一般数组以1开头,所以这里加一. } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 0; i \u0026lt; n; i ++ ) { int x, c; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; c; add.push_back({x, c}); alls.push_back(x);// } for (int i = 0; i \u0026lt; m; i ++ ) { int l, r; cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r; query.push_back({l, r}); alls.push_back(l); alls.push_back(r); } // 去重 sort(alls.begin(), alls.end()); alls.erase(unique(alls.begin(), alls.end()), alls.end()); //担心一个点加两次数却被去重? //这里只存储位置,加数在后边遍历添加数据对中, //如果一个点多加两次,那么add中也有两条对应的. // 处理插入 for (auto item : add) { int x = find(item.first); a[x] += item.second; } // 预处理前缀和 for (int i = 1; i \u0026lt;= alls.size(); i ++ ) s[i] = s[i - 1] + a[i]; // 处理询问 for (auto item : query) { int l = find(item.first), r = find(item.second); cout \u0026lt;\u0026lt; s[r] - s[l - 1] \u0026lt;\u0026lt; endl; } return 0; } 区间合并\r#\r问题提出\r#\r给出n个区间范围,如果区间有公共范围,则合并.求最终剩下几个区间.\n主要思路\r#\r可以按照左端点大小进行排序,然后检查右端点与下一个区间的左端点的关系,如果包含则并入,否则不处理,划分到下一个区间,\n主要代码\r#\r#include\u0026lt;iostream\u0026gt; #include\u0026lt;vector\u0026gt; #include\u0026lt;algorithm\u0026gt; using namespace std; const int N = 100010; typedef pair\u0026lt;int,int\u0026gt; PAIR; vector\u0026lt;PAIR\u0026gt; seg; void merged(vector\u0026lt;PAIR\u0026gt;\u0026amp; seg){ vector\u0026lt;PAIR\u0026gt; res; int st, ed; st = -2e9; ed = -2e9; sort(seg.begin(),seg.end()); for(auto item:seg){ if(ed \u0026lt; item.first){ if(ed != -2e9){ res.push_back({st,ed}); } st = item.first; ed = item.second; }else ed = max(ed,item.second); } if(st != -2e9) res.push_back({st,ed}); seg = res; } int main(){ int n; cin \u0026gt;\u0026gt; n; for(int i = 0 ; i \u0026lt; n ;i ++){ int l , r; cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r; seg.push_back({l,r}); } merged(seg); cout \u0026lt;\u0026lt; seg.size(); return 0; } 大概就是这样了\n"},{"id":12,"href":"/docs/chapter03/DS/cpter08/","title":"排序算法","section":"数据结构","content":"\r1.0 十大经典排序算法 | 菜鸟教程\n常用排序算法\r#\r冒泡排序 选择排序 插入排序 希尔排序 归并排序 快速排序 堆排序 基数排序 桶排序 计数排序 排序算法的稳定性\r#\r什么是稳定性？\r#\r稳定的算法是在排序后，相同排序属性的元素预期的前后顺序是已知的，不稳定的排序算法是未知的，即有可能是稳定算法的顺序，也有可能不是。 如果一个排序算法是稳定的，那么对于两个数值相同的元素而言，它们的相对位置是不变的。这对于只考虑排序属性的排序而言是无意义的，因为该排序是需要考虑排序属性的前后问题。但是如果排序的每个元素含有其他属性，这些属性需要保持一定的前后顺序，例如在排序含有姓名与年龄属性的用户时（待排序的用户是按照姓氏首字母的顺序排列），按照用户年龄排序，但是需要保证排序后相同年龄的用户前后顺序依旧是按照姓氏首字母来排，那么就需要保证排序算法的稳定性。\n什么排序算法是稳定的？\r#\r稳定的排序算法如果细节未处理好就会变成不稳定的排序算法，而不稳定的排序算法得出的结果就是不稳定的。 稳定的排序算法有： 直接插入排序、冒泡排序、归并排序、基数排序 不稳定的排序算法： 希尔排序、选择排序、堆排序、快速排序\n冒泡排序\r#\r基本思想\r#\r重复走访要排序的数列，一次比较两个相邻的数字大小，如果不符合顺序就交换，交换后移动到下一位进行比较。遍历遍历完一次数组后，重新从头操作，直到没有任何一对数字需要比较。\n代码实现\r#\rvoid buble_sort(vector\u0026lt;int\u0026gt;\u0026amp; array){ int len = array.size(); int flag = 0; //定义标志位,判断是否已经排好。 for(int i = 0;i \u0026lt; len - 1;++i){ for(int j = 0;j \u0026lt; len - 1;++j){ if(array[j] \u0026gt; array[j+1]){ array[j] ^= array[j+1]; array[j+1] ^= array[j]; array[j] ^= array[j+1];// 交换 flag = 1;//如果有交换则证明排序未结束。 } } if(flag == 0) break;//一次遍历中无交换则证明排序已完成。 else flag = 0; } } 时空损耗\r#\r时间复杂度\n平均时间复杂度\nO(n^2) 最好情况\nO(n)，刚好就是预期的顺序。 最坏情况\nO(n^2)，刚好就是反着的顺序。 空间复杂度\nO(1)，只使用了循环所需要的变量。 选择排序\r#\r基本思想\n首先在数组中找最小（大）的元素，找到了放到数组起始位置，然后开始在除去起始位置的数组中寻找第二小（大）的元素，然后放到第二位置，如此重复直到最后一个位置。 插入排序\r#\r希尔排序\r#\r归并排序\r#\r快速排序\r#\r基本思想\r#\r快速排序采用了分治算法的思想，即分而治之。如果要排序一个数组，我可以先随意挑选选一个基准值（通常为数组的第一个元素，因为数组第一个元素一般是一般情况下都有的，取值方便），然后把比它大的放左边，比它小的放右边，然后这个问题就变成了基准值左边的小数组的排序和基准值右边的小数组的排序。然后我们可以对两个小数组进行快速排序，如此重复。\n代码实现\r#\rint Paritition1(int A[], int low, int high){ int pivot = A[low]; //设定基准值 while (low \u0026lt; high){ while (low \u0026lt; high \u0026amp;\u0026amp; A[high] \u0026gt;= pivot){ --high; } A[low] = A[high]; while (low \u0026lt; high \u0026amp;\u0026amp; A[low] \u0026lt;= pivot){ ++low; } A[high] = A[low]; } A[low] = pivot; return low; }//以基准来划分两边的数组。 void QuickSort(int A[], int low, int high){ //快排母函数 if (low \u0026lt; high){ int pivot = Paritition1(A, low, high); QuickSort(A, low, pivot - 1); QuickSort(A, pivot + 1, high); } } 堆排序\r#\r基数排序\r#\r桶排序\r#\r计数排序\r#\r"},{"id":13,"href":"/docs/chapter02/acwing/math/others/","title":"其他","section":"Math","content":"\r秦九韶算法\r#\r使用秦九韶算法可以计算多项式的值，或进制转换。 例子：计算多项式的值。a[i]表示多项式中的x的i次幂的系数。\n#include\u0026lt;iostream\u0026gt; using namespace std; int n,x,ans,a[21]; int main(){ cin\u0026gt;\u0026gt;n; for(int i=0;i\u0026lt;=n;i++) cin\u0026gt;\u0026gt;a[i]; cin\u0026gt;\u0026gt;x; ans=a[n]; for(int i=1;i\u0026lt;=n;i++) ans=ans*x+a[n-i]; cout\u0026lt;\u0026lt;ans; return 0; } "},{"id":14,"href":"/docs/chapter02/acwing/base/datestruct/","title":"数据结构","section":"Base","content":"\r链表\r#\r拿数组模拟链表,其实也就是静态链表. 静态链表的优点是快,但是缺点是必须要提前分配足够空间,并且可能会出现假满状态,即idx到最后但是前边还有很多未使用的节点,\n单链表\r#\r#include\u0026lt;iostream\u0026gt; using namespace std; const int N = 100010; int e[N]; int ne[N]; int idx,head; void init(){ head = -1; idx = 0; } void add_to_head(int x){ e[idx] = x; ne[idx] = head; head = idx++; } //插入到下标为k的后面 void add(int k,int x){ e[idx] = x; ne[idx] = ne[k]; ne[k] = idx ++; } void del(int k){ if(k == -1) head = ne[head]; else ne[k] = ne[ne[k]]; } int main(){ int m; cin \u0026gt;\u0026gt; m; init(); while(m--){ char opt; cin \u0026gt;\u0026gt; opt; if(opt == \u0026#39;H\u0026#39;){ int x; cin \u0026gt;\u0026gt; x; add_to_head(x); }else if(opt == \u0026#39;D\u0026#39;){ int k; cin \u0026gt;\u0026gt; k; del(k-1); }else{ int k,x; cin \u0026gt;\u0026gt; k \u0026gt;\u0026gt;x; add(k - 1,x); } } int index = head; while(index != -1){ cout \u0026lt;\u0026lt; e[index] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; index = ne[index]; } return 0; } 双链表\r#\r所谓双链表就是每个节点含有前结点位置进而后节点位置.\n#include\u0026lt;iostream\u0026gt; using namespace std; const int N = 100010; int pre[N],ne[N],e[N]; int idx; // 定义0号位为头结点 // 定义1号位为尾结点 void init(){ ne[0] = 1; pre[0] = -1; ne[1] = -1; pre[1] = 0; idx = 2; } void add_head(int x){ e[idx] = x; ne[idx] = ne[0]; pre[idx] = 0; pre[ne[0]] = idx; ne[0] = idx; idx ++; } void add_tail(int x){ e[idx] = x; ne[idx] = 1; pre[idx] = pre[1]; ne[pre[1]] = idx; pre[1] = idx; idx++; } void del(int k){ ne[pre[k]] = ne[k]; pre[ne[k]] = pre[k]; } void add_left(int k,int x){ e[idx] = x; ne[idx] = k; pre[idx] = pre[k]; ne[pre[k]] = idx; pre[k] = idx; idx ++; } void add_right(int k,int x){ e[idx] = x; ne[idx] = ne[k]; pre[idx] = k; pre[ne[k]] = idx; ne[k] = idx; idx++; } int main(){ int m; cin \u0026gt;\u0026gt; m; init(); while(m --){ string opt; int k,x; cin \u0026gt;\u0026gt; opt; if(opt == \u0026#34;L\u0026#34;){ cin \u0026gt;\u0026gt; x; add_head(x); }if(opt == \u0026#34;R\u0026#34;){ cin \u0026gt;\u0026gt; x; add_tail(x); }if(opt == \u0026#34;D\u0026#34;){ cin \u0026gt;\u0026gt; k; del(k + 1); }if(opt == \u0026#34;IL\u0026#34;){ cin \u0026gt;\u0026gt; k \u0026gt;\u0026gt; x; add_left(k + 1,x); }if(opt == \u0026#34;IR\u0026#34;){ cin \u0026gt;\u0026gt; k \u0026gt;\u0026gt; x; add_right(k + 1,x); } } int j = 0; for(int i = ne[0]; ne[i] != -1; i = ne[i]){ cout\u0026lt;\u0026lt; e[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } return 0; } 栈和队列\r#\r使用数组实现基本的栈与队列\n模拟栈\r#\rconst int N = 1010; //栈 int stk[N],tt = -1; //入栈 stk[++tt] = elem; //出栈 stk[tt--]; //栈是否为空 if tt \u0026lt; 0 stack is empty else stack is not empty 完整操作代码\nconst int N = 100010; int stk[N],idx; //初始化 void init(){ idx = -1; } //插入元素 void push(int x){ stk[++idx] = x; } //取出栈顶元素 int pop(){ int res = stk[idx--]; return res; } //判断是否为空 bool isEmpty(){ if(idx \u0026lt; 0) return true; else return false; } //获取栈顶元素 int pull(){ return stk[idx]; } 模拟队列\r#\rconst int N = 1010; //栈 int queue[N],tt,hh; //入队 queue[tail++] = elem; //出队 queue[top++]; 完整操作\nconst int N = 100010; int queue[N],top,tail; //初始化 void init(){ top = -1; tail = -1; } //插入元素到队尾 void push(int x){ queue[++tail] = x; } //弹出队列队首元素 int pop(){ int res = queue[++top]; return res; } //队列是否空 bool isEmpty(){ if(top \u0026gt;= tail) return true; else return false; } //返回队列队首元素 int pull(){ return queue[top + 1]; } 单调栈与单调队列\r#\r单调栈\r#\r定义\r#\r什么是单调栈? 栈中的数据具有单调性.现在有一组数10,3,7,4,12从左到右依次入栈，则如果栈为空或入栈元素值小于栈顶元素值，则入栈；否则，如果入栈则会破坏栈的单调性，则需要把比入栈元素小的元素全部出栈。单调递减的栈反之。\n应用场景\r#\r给定一个序列,求每个元素左边(或右边)最近的比它小(或大)的元素.其实就是找逆序对,最近的两个构成逆序就输出,未找到就返回-1.\n如下图所示, 4找3,满足,则返回3; 2往前找4,不满足,找3,也不满足,则返回-1; 7往前找2(如果2满足,则无需考虑2之前的数据),满足则返回2. 5往前找7,不满足,则去找2,满足,则返回2. 如果满足逆序则保留,不满足则不保留 (因为如果保留,则当前点不满足,上一个点也不满足,需要多遍历, 例如序列5 4 3 1 2, 考虑3时,5 4是非逆序,那么4不满足,5同样不满足) 这种情况使用栈最好,因为考虑的数据是按照后进先出的顺序读取.\n主要代码\r#\r#include\u0026lt;iostream\u0026gt; using namespace std; const int N = 10010; int stk[N].idx = 0; int main(){ int n; cin \u0026gt;\u0026gt; n; for(int i = 0 ; i \u0026lt; n ; i++){ int x; cin \u0026gt;\u0026gt; x; while(idx \u0026amp;\u0026amp; stk[idx] \u0026gt;= x) idx--; if(idx) cout \u0026lt;\u0026lt; stk[idx] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; else cout \u0026lt;\u0026lt; \u0026#34;-1\u0026#34; \u0026lt;\u0026lt; \u0026#34; \u0026#34;; stk[++idx] = x; } return 0; } 单调队列\r#\r定义\r#\r什么是单调队列? 有单调性的队列!\n应用场景\r#\r输入一个数组,并且有长度为k的滑动窗口不断向右移动,求每移动一次后窗口中元素的最大(小)值.滑动窗口求最值.\n先考虑暴力解法,再进行优化,考虑哪些没有用到却被操作.\n#include\u0026lt;iostream\u0026gt; using namespace std; const int N = 1000010; int n,k; int a[N],q[N]; int hh,tt; int main(){ scanf(\u0026#34;%d%d\u0026#34;,\u0026amp;n,\u0026amp;k); for(int i = 0 ; i \u0026lt; n ; i++) scanf(\u0026#34;%d\u0026#34;,\u0026amp;a[i]); int hh = 0, tt = 0; for(int i = 0 ; i \u0026lt; n ; i++ ){ //判断队头是否已经滑出窗口,即当窗口长度为3时 //,i = 3,hh = 0时,这个3长度的窗口 已经不包括 队首了 所以需要hh++ //一般情况只需要加一次,所以用的是if 不是while if(hh \u0026lt;= tt \u0026amp;\u0026amp; i - k + 1 \u0026gt; q[hh]) hh++; //队列如果加入新元素后不是单调的,就要出队, //直到满足队列为单调的 // 比如 当前窗口内为 3 -1 -3 , //那么3 -1 就是属于无效数据,因为-3是最小的 //在往后移动的过程中,只要有-3 前边都不考虑 //这种情况 也可以看成 不满足单调性 while(hh \u0026lt;= tt \u0026amp;\u0026amp; a[q[tt]] \u0026gt;= a[i]) tt--; //入队新元素 q[++tt] = i; //只要过了k个数 就要输出队头元素 if(i \u0026gt;= k - 1) printf(\u0026#34;%d \u0026#34;,a[q[hh]]); } printf(\u0026#34;\\n\u0026#34;); hh = tt = 0; for(int i = 0 ; i \u0026lt; n ; i ++){ if(hh \u0026lt;= tt \u0026amp;\u0026amp; i - k + 1 \u0026gt; q[hh]) hh++; while(hh \u0026lt;= tt \u0026amp;\u0026amp; a[q[tt]]\u0026lt;= a[i]) tt--; q[++tt] = i; if(i \u0026gt;= k - 1) printf(\u0026#34;%d \u0026#34;,a[q[hh]]); } return 0; } KMP\r#\rKMP是一种字符串匹配算法,该算法充分体现了利用已有信息降低操作数,即时间复杂度. 完整代码\n#include\u0026lt;iostream\u0026gt; using namespace std; const int M = 1e6 + 10, N = 1e5 + 10; //定义 字符串 str 与 模板串 ptn char str[M],ptn[N]; int n,m; // 定义next数组 int ne[N]; int main() { scanf(\u0026#34;%d%s%d%s\u0026#34;,\u0026amp;n,ptn + 1,\u0026amp;m,str+1); //next数组第一位是0 所以从第二位开始 // 计算next数组 for(int i = 2 , j = 0 ; i \u0026lt;= n ; i++) { // 如果j是0 就没办法再往前了 // 如果当前与 while(j \u0026amp;\u0026amp; ptn[i] != ptn[j + 1])j = ne[j]; if(ptn[i] == ptn[j+1]) j ++; ne[i] = j; } for(int i = 1 , j = 0 ; i \u0026lt;= m ; i++) { while(j \u0026amp;\u0026amp; str[i] != ptn[j + 1]) j = ne[j]; if(str[i] == ptn[j + 1]) j ++; if(j == n) { printf(\u0026#34;%d \u0026#34;,i - n); j = ne[j]; } } return 0; } Trie树(字典树)\r#\r“Trie这个名字取自“retrieval”，检索，因为Trie可以只用一个前缀便可以在一部字典中找到想要的单词。”\n什么是Trie树\r#\r高效地存储与查找字符串集合的数据结构.用树结构来存储字符串集合,举例: 对于某字符串集合{\u0026quot;abcde\u0026quot;,\u0026quot;abdcf\u0026quot;,\u0026quot;acde\u0026quot;,\u0026quot;acfd\u0026quot;,\u0026quot;abc\u0026quot;,\u0026quot;bd\u0026quot;}.有下面这种存储方法.带星号表示从头往下查找到这个地方算一个字符串, 基本思想\r#\r如果是存小写字母组成的字符串集合,那么a-z对应的是0-25,如果是大写字母或其他情况同理.每次新加一个字符串中的一个字符,都要给这个字符上一个序号idx.每个需要都要记录它的子节点.比如son[idx][u]记录了序号为idx的子节点u的下一个节点指向的序号.\n打个比方:字符串abcd存入时有这种情况\nson[0][\u0026#39;a\u0026#39; - \u0026#39;a\u0026#39;] = 1;//初始节点的后继节点a的序号是1 son[1][\u0026#39;b\u0026#39; - \u0026#39;a\u0026#39;] = 2;//序号为1的后继节点b的序号是2 son[2][\u0026#39;c\u0026#39; - \u0026#39;a\u0026#39;] = 3;//序号为2的后继节点c的序号是3 son[3][\u0026#39;d\u0026#39; - \u0026#39;a\u0026#39;] = 4;//序号为3的后继节点d的序号是4 如果我继续存入abcf\nson[0][\u0026#39;a\u0026#39; - \u0026#39;a\u0026#39;] = 1;//初始节点的后继节点a的序号是1 son[1][\u0026#39;b\u0026#39; - \u0026#39;a\u0026#39;] = 2;//序号为1的后继节点b的序号是2 son[2][\u0026#39;c\u0026#39; - \u0026#39;a\u0026#39;] = 3;//序号为2的后继节点c的序号是3 //abcf中abc节点都已经存过,所以不需要增加序号 //f属于abc这一子树的新节点,所以需要赋予新序号5 //如果要查找abcf后续节点x,则需要从5开始 //即son[5][x - \u0026#39;a\u0026#39;] = idx; idx表示 x 的序号,如果不存在则为0; son[3][\u0026#39;f\u0026#39; - \u0026#39;a\u0026#39;] = 5;//序号为3的后继节点f的序号是5 那么又一个问题来了。我怎么知道往下哪个是字符串结束呢？比如我存入abc和abcd两个字符串。怎么判断abc在里面。这里我们使用一个cnt[p]数组，该数组存的是以序号p的字符结尾的字符串个数. 。 依托这个数组,我们可以得到在字符串集合{\u0026quot;abc\u0026quot;,\u0026quot;abcd\u0026quot;}中cnt[3] = 1; cnt[4] = 1;代表以字符序号为3和4结尾的字符串各出现了一次.\n主要代码\r#\r#include\u0026lt;iostream\u0026gt; using namespace std; const int N = 1e5 + 10; //son[i][j] 表示编号为i的j儿子的后继节点数 int son[N][26],cnt[N]; char str[N]; int n,idx; void insert(char x[]) { int p = 0; for(int i = 0 ; x[i] ;i++) { int u = x[i] - \u0026#39;a\u0026#39;; //如果不存在节点，则新建一个，然后新节点标号为++idx。 //++idx表示给新节点上个序号,盖个出生证明 if(!son[p][u]) son[p][u] = ++idx; //如何找到下一个节点? //son[p][u]为节点序号为 //p的节点的子节点为u的节点的下一个节点序号 p = son[p][u]; } //表示以节点序号为p结尾的字符串个数. cnt[p] ++; } int query(char x[]) { int p = 0; for(int i = 0 ; x[i] ; i++) { int u = x[i] - \u0026#39;a\u0026#39;; if(!son[p][u]) return 0 ; p = son[p][u]; } return cnt[p]; } int main() { scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); while(n --){ char opt; cin \u0026gt;\u0026gt; opt \u0026gt;\u0026gt; str; if(opt == \u0026#39;I\u0026#39;)insert(str); else printf(\u0026#34;%d\\n\u0026#34;,query(str)); } return 0; } 并查集\r#\r应用场景\r#\r适用于维护集合之间的合并，与查询两个数是否在同一个集合内的情况。\n核心代码\r#\rint p[N]; // 压缩路径版本 // 即每次查询 都将集合中的节点指向根节点 int find(int x){ if (p[x] != x) p[x] = find(p[x]); return p[x]; } // 预处理，代表每一个数都属于单独的集合，集合编号为i for(int i = 1 ; i \u0026lt;= n ; i++) p[i] = i; //合并操作 void merge(int a,int b) { p[find(a)] = find(b); } //查询操作 void query(int a,int b) { if(find(a) == find(b)) puts(\u0026#34;Yes\u0026#34;); else puts(\u0026#34;No\u0026#34;); } 哈希表\r#\r哈希表存储结构\r#\r将一个集合中的数通过一个函数映射到另外一个集合中。例如离散化中，将大范围中的数据映射到小范围的区间上，这是一种哈希映射，但这种映射需要保存前后顺序，属于特殊的哈希映射。哈希表一般指比较一般情况下的映射。\n但是哈希映射函数可能会出现哈希冲突的情况，比如有一个数据范围为0~1e9的数组，映射到0~1e5范围内，使用的映射函数为h(x) = x MOD 1e5，这种情况可能会出现某两个数经过哈希映射函数计算的哈希值相同，就发生了冲突。这就是所谓的哈希冲突，解决哈希冲突一般有两种方法：开放寻址法和拉链法。\n开放寻址法\r#\r所谓开放寻址，就是某个点如果发生哈希冲突，就在这个点哈希值加一位置插入数据，如果这个点还有数，就继续往后加，直到为空。\n#include\u0026lt;iostream\u0026gt; #include \u0026lt;cstring\u0026gt; using namespace std; //一般取质数情况下，发生哈希冲突的概率较低。 //开放寻址法 一般要数组开大一点. //因为h[N]存的是哈希值为N的值是多少 const int N = 200003,null = 0x3f3f3f3f; //按位寻址法 int h[N]; int find(int x) { //负数模后是负数，所以加N int k = (x % N + N) % N; while(h[k] != null \u0026amp;\u0026amp; h[k] != x){ k++; //找到头还没找到 就从0开始 //一般不会出现找不到的情况，有的话就把数组开大 if(k == N) k = 0; } return k; } int main(){ int n; scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); //初始化全部为null 以便标记该位置没存过数 memset (h, null , sizeof h); while(n --) { char opt[2]; int x; scanf(\u0026#34;%s%d\u0026#34;,opt,\u0026amp;x); //先找到位置，如果是没有的话就返回null。 //插入就是把null赋值为x //查找的话 是null就是没找到 int k = find(x); if(*opt == \u0026#39;I\u0026#39;) h[k] = x; else { if(h[k] != null) puts(\u0026#34;Yes\u0026#34;); else puts(\u0026#34;No\u0026#34;); } } return 0; } 拉链法\r#\r所谓拉链法，就是某个点如果发生哈希冲突，就在这个点上建立一个链表，然后把数加到链表上。\n#include\u0026lt;iostream\u0026gt; #include \u0026lt;cstring\u0026gt; using namespace std; //一般取质数情况下，发生哈希冲突的概率较低。 const int N = 100003; // 拉链法 //定义链表，e[idx]存序号为idx的数值，ne[idx]存序号为idx的下一项; // h[k]存哈希值为k的第一个数的idx序号 int h[N],e[N],ne[N],idx; void insert(int x) { //负数模后是负数，所以加N int k = (x % N + N) % N; e[idx] = x; ne[idx] = h[k]; h[k] = idx ++; } bool find(int x) { int k = (x % N + N) % N; for(int i = h[k]; i != -1 ; i = ne[i]) { if(e[i] == x) return true; } return false; } int main(){ int n; scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); //初始化全部为-1 以便标记为空 memset (h, -1 , sizeof h); while(n --) { char opt[2]; int x; scanf(\u0026#34;%s%d\u0026#34;,opt,\u0026amp;x); if(*opt == \u0026#39;I\u0026#39;) insert(x); else { if(find(x)) puts(\u0026#34;Yes\u0026#34;); else puts(\u0026#34;No\u0026#34;); } } return 0; } 字符串哈希\r#\r将字符串转换为一串数字然后计算哈希值存入哈希表，如abcde中每个字母对应的ASCII码中的编号按顺序为1 2 3 4 5（计算方法为'a' - 'a' + 1，'b' - 'a' + 1，'c' - 'a' + 1等）那么可以将这段数字转换为P进制数，这样就可以区分不同字符串对应的哈希值。但是如果字符串位数比较多，会出现哈希值溢出的情况，那么就需要取模Q运算！\n//一般情况下 P = 131;//P = 131; Q = 1 \u0026lt;\u0026lt; 64; 也可以利用这个算法实现前缀哈希，即某个字符串前i位的哈希值。然后我们就可以通过这个数组计算某个子串的哈希值。\n"},{"id":15,"href":"/docs/chapter02/acwing/math/shulun/","title":"数论","section":"Math","content":"\r质数\r#\r针对所有大于1的自然数定义的，只包含1和本身两个约数的自然数叫做质数（素数）。\n质数的判定\r#\r试除法\r#\rbool is_prime(int n){ if(n \u0026lt; 2) return false; for(int i = 2; i \u0026lt;= n ; i++){ if(n % i == 0) return false; } return true; } O(n); 如果i包含其他因子，那么这因子应该是成双成对出现的。比如12的因子有{1,2,3,4,6,12}。 这里只需要遍历成对中的第一个就可以了， 如果n可以被d整除，证明d是n的一个因子，那么另外一个与其对应的因子是n除以n除以d的商。所以我只需要遍历到第一个因子就可以了，即d满足大于n除以d的商，d大于根号n就OK。时间复杂度可以降到根号n。\nbool is_prime(int n){ if(n \u0026lt; 2) return false; for(int i = 2; i \u0026lt;= n / i ; i++){ if(n % i == 0) return false; } return true; } O(sqrt(n)); 不使用sqrt(i)可以降低时间复杂度，每次循环都会计算一次。如果使用i * i \u0026lt;= n，则可能存在 i * i溢出风险，变成负值。\n分解质因数\r#\r什么是质因数？\n一个数的某对因子均为质数。比如6的因子有2和3，这对因子就是质因数。 从小到大枚举所有约数。\n试除法\r#\rvoid divide(int n){ for(int i = 2; i \u0026lt;= n; i++) { if(n % i == 0) { } } } "},{"id":16,"href":"/docs/chapter02/acwing/base/search_and_graph/","title":"搜索与图论","section":"Base","content":"\r图论\r#\rFloyd算法\r#\r主要思想是: 循环邻接矩阵中查找每个点到另外一个点的最短距离，不仅是看直接距离，也还要通过计算中转点。比如计算A到B的距离，要比较A到C的距离与C到B的距离的和、A到B的直接距离的最小值来判断，中转点可以是其他节点，所以代码实现中出现了三重循环。\n//n为顶点个数 //第一轮循环为 选取中间点的个数 //第二三轮循环为 void floyd(){ for(int k = 1 ; k \u0026lt;=n ; k++) for(int i = 1 ; i \u0026lt;= n ;i ++) for(int j = 1 ; j \u0026lt;=n ;j ++) dic[i][j] = min(dic[i][j],dic[i][k] + dic[k][j]); } 模板题代码：\n#include\u0026lt;iostream\u0026gt; using namespace std; const int N = 210,INF = 1e9; int dic[N][N]; int n,m,Q; void floyd(){ for(int k = 1 ; k \u0026lt;=n ; k++) for(int i = 1 ; i \u0026lt;= n ;i ++) for(int j = 1 ; j \u0026lt;=n ;j ++) dic[i][j] = min(dic[i][j],dic[i][k] + dic[k][j]); } int main(){ scanf(\u0026#34;%d%d%d\u0026#34;,\u0026amp;n,\u0026amp;m,\u0026amp;Q); for(int i = 1 ; i \u0026lt;= n ;i ++) for(int j = 1 ; j\u0026lt;=n;j++) if(i == j) dic[i][j] = 0; else dic[i][j] = INF; while(m--) { int a,b,w; scanf(\u0026#34;%d%d%d\u0026#34;,\u0026amp;a,\u0026amp;b,\u0026amp;w); dic[a][b] = min(dic[a][b],w); } floyd(); while(Q--) { int a,b; scanf(\u0026#34;%d%d\u0026#34;,\u0026amp;a,\u0026amp;b); if(dic[a][b] \u0026lt; INF / 2) printf(\u0026#34;%d\u0026#34;,dic[a][b]); else printf(\u0026#34;impossible\u0026#34;); printf(\u0026#34;\\n\u0026#34;); } return 0; } "},{"id":17,"href":"/docs/chapter01/argo-datastru/","title":"算法竞赛常用STL","section":"第一章|基本语法储备","content":"\r数据结构\r#\rvector[可变数组]\r#\rvector是一种变长数组，即可以自动改变长度的数组。 头文件\n#include\u0026lt;vector\u0026gt; 初始化\n#include\u0026lt;iostream\u0026gt; #include\u0026lt;vector\u0026gt; using namespace std; int main () { //几种初始化的方法 vector\u0026lt;int\u0026gt; a;//定义一个vector 未初始化 输出》 0 vector\u0026lt;int\u0026gt; a(3);//定义一个长度为3的vector 未初始化 输出》0 0 0 vector\u0026lt;int\u0026gt; a(10, 3); //定义一个长度为10，且每个数赋值为3 //将向量b中从下标0 1 2（共三个）的元素赋值给a，a的类型为int型 //它的初始化不和数组一样 vector\u0026lt;int\u0026gt;a(b.begin(),b.begin+3); //从数组中获得初值 int b[7]={1,2,3,4,5,6,7}; vector\u0026lt;int\u0026gt; a(b,b+7）; for(auto x : a) {//遍历输出 cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } return 0; } 相关函数\na.size();//返回元素个数 a.resize();//改变大小 a.empty();//判断a是否为空，空则返回true，非空则返回false a.front(); //返回a的第1个元素,当且仅当a存在 a.back(); //返回vector的最后一个数 a.clear(); //清空a中的元素 a.pop_back(); //删除a向量的最后一个元素 a.push_back(5); //在a的最后一个向量后插入一个元素，其值为5 a.begin();// vector的第0个数 a.end();// vector的最后一个的数的后面一个数 //通常与for循环结合使用 ⑦倍增的思想\n[C++]系统为某一程序分配空间的所需时间，与空间大小无关，与申请次数有关如申请一个空间为1000 和 空间为1 申请1000次的所需时间差别是很大的，申请次数越多，越耗时间 支持比较运算 比较操作如==，！=，\u0026lt;，\u0026lt;，\u0026lt;=，\u0026gt;，\u0026gt;=\nint main () { //支持比较运算 vector\u0026lt;int\u0026gt; a(4, 3), b(3, 4); //a: 3 3 3 3 b:4 4 4 //比较原理字典序 (根据最前面那个判断，如果一样就往后比较) if (a \u0026lt; b) { puts(\u0026#34;a \u0026lt; b\u0026#34;); } return 0; } 遍历方法\nint main () { vector\u0026lt;int\u0026gt; a; for (int i = 0; i \u0026lt; 10; i ++) { a.push_back(i); } //三种遍历vector的方法 for (int i = 0; i \u0026lt; a.size(); i ++) { cout \u0026lt;\u0026lt; a[i] \u0026lt;\u0026lt; \u0026#39; \u0026#39;; } cout \u0026lt;\u0026lt; endl; for (auto i = a.begin(); i != a.end(); i ++) { cout \u0026lt;\u0026lt; *i \u0026lt;\u0026lt; \u0026#39; \u0026#39;; } cout \u0026lt;\u0026lt; endl; //C++11的新语法 for (auto x : a) { cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#39; \u0026#39;; } cout \u0026lt;\u0026lt; endl; return 0; } 结合算法库中的erase() reverse()\na.erase(p)//从a中删除迭代器p指定的元素，p必须指向c中的一个真实元素，不能是最后一个元素end() a.erase(b,e)//从a中删除迭代器对b和e所表示的范围中的元素，返回e vector\u0026lt;int\u0026gt; a={1,2,3,4,5}; reverse(a.begin(),a.end());//a的值为5，4，3，2，1 倒置 string[字符串]\r#\r支持比较运算 比较操作如==，！=，\u0026lt;，\u0026lt;，\u0026lt;=，\u0026gt;，\u0026gt;= 头文件\n#include\u0026lt;string\u0026gt; 初始化\nstring a = \u0026#34;abc\u0026#34;; queue[队列]和priority_queue[优先队列，堆]\r#\rstack[栈]\r#\rdeque[双向队列]\r#\rset[集合]和multiset\r#\rset（集合），是一个内部自动有序且不含重复元素的容器。 set可以在需要去重复元素的情况大放异彩，节省时间，减少思维量。 要使用set，需要添加头文件： 头文件\n#include\u0026lt;set\u0026gt; 初始化\nset\u0026lt;int\u0026gt; gather; map[映射]和multiset\r#\runordered[哈希表]\r#\rbitset[压位]\r#\r算法\r#\rAlgorithm[常用算法函数]\r#\r其他\r#\rC++ pair的基本用法总结（整理） - 知乎 `\n"},{"id":18,"href":"/docs/chapter02/acwing/base/greedy/","title":"贪心","section":"Base","content":"\r与区间有关的问题\r#\r"},{"id":19,"href":"/docs/chapter03/machine-learning/LinerRegression/","title":"线性回归","section":"机器学习","content":"数据集\nurl = \u0026#34;https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data\u0026#34; names = [\u0026#39;花萼-length\u0026#39;, \u0026#39;花萼-width\u0026#39;, \u0026#39;花瓣-length\u0026#39;, \u0026#39;花瓣-width\u0026#39;, \u0026#39;class\u0026#39;] dataset = pd.read_csv(url, names=names) # 下面我们提取数据集中花瓣宽度与花瓣长度数据，将花瓣数据分为训练数据与测试数据， # 训练数据用于训练线性回归模型，测试数据用于检测我们的模型的准确率。 # 最终我们要达到的效果是：输入花瓣宽度，通过模型预测花瓣宽度。 X = dataset[\u0026#34;花瓣-length\u0026#34;] Y = dataset[\u0026#34;花瓣-width\u0026#34;] X = X.values.reshape(len(X), 1) Y = Y.values.reshape(len(Y), 1) # 将数据集拆分数据集成训练集、测试集 from sklearn.model_selection import train_test_split X_train, X_test, Y_train, Y_test = train_test_split(X, Y, test_size=0.2, random_state=0) # 线性回归模型 regression = LinearRegression() regression.fit(X_train, Y_train) # 拟合 # LinearRegression(copy_X=True, fit_intercept=True, n_jobs=1, normalize=False) print(regression.intercept_) # 截距，以下画线结束 print(regression.coef_) # 斜率，回归系数 # 反映了x对y影响的大小 # 以下画线结束，表示模型自身的属性 # 区别于用户设置的参数 # array([ 0.2]) regression.predict([[6]]) # 对未知点进行预测，结果为数组 # array([ 1.6]) import matplotlib.pyplot as plt plt.scatter(X_train, Y_train, color=\u0026#39;red\u0026#39;) plt.plot(X_train, regression.predict(X_train), color=\u0026#39;green\u0026#39;) plt.xlabel(\u0026#34;Iris-length\u0026#34;) plt.ylabel(\u0026#34;Iris-width\u0026#34;) plt.title(\u0026#34;This is train dataset-kzb\u0026#34;) plt.show() plt.scatter(X_test, Y_test, color=\u0026#39;blue\u0026#39;) plt.plot(X_train, regression.predict(X_train), color=\u0026#39;green\u0026#39;) plt.xlabel(\u0026#34;Iris-length\u0026#34;) plt.ylabel(\u0026#34;Iris-width\u0026#34;) plt.title(\u0026#34;This is test dataset-kzb\u0026#34;) plt.show() "}]