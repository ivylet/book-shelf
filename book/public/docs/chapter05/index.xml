<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>其他 on QBook</title>
    <link>http://ivylet.github.io/docs/chapter05/</link>
    <description>Recent content in 其他 on QBook</description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="http://ivylet.github.io/docs/chapter05/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>寻找数组的中心索引</title>
      <link>http://ivylet.github.io/docs/chapter05/%E5%AF%BB%E6%89%BE%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E5%BF%83%E7%B4%A2%E5%BC%95/</link>
      <pubDate>Mon, 27 Feb 2023 18:18:19 +0800</pubDate>
      
      <guid>http://ivylet.github.io/docs/chapter05/%E5%AF%BB%E6%89%BE%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E5%BF%83%E7%B4%A2%E5%BC%95/</guid>
      <description>题目#给你一个整数数组&amp;nbsp;nums ，请计算数组的 中心下标 。
数组 中心下标 是数组的一个下标，其左侧所有元素相加的和等于右侧所有元素相加的和。
如果中心下标位于数组最左端，那么左侧数之和视为 0 ，因为在下标的左侧不存在元素。这一点对于中心下标位于数组最右端同样适用。
如果数组有多个中心下标，应该返回 最靠近左边 的那一个。如果数组不存在中心下标，返回 -1 。
&amp;nbsp;
示例 1：
输入：nums = [1, 7, 3, 6, 5, 6] 输出：3 解释： 中心下标是 3 。 左侧数之和 sum = nums[0] + nums[1] + nums[2] = 1 + 7 + 3 = 11 ， 右侧数之和 sum = nums[4] + nums[5] = 5 + 6 = 11 ，二者相等。 示例 2：
输入：nums = [1, 2, 3] 输出：-1 解释： 数组中不存在满足此条件的中心下标。 示例 3：</description>
    </item>
    
    <item>
      <title>搜索插入位置</title>
      <link>http://ivylet.github.io/docs/chapter05/%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/</link>
      <pubDate>Mon, 27 Feb 2023 18:17:27 +0800</pubDate>
      
      <guid>http://ivylet.github.io/docs/chapter05/%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/</guid>
      <description>题目#给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。
请必须使用时间复杂度为 O(log n) 的算法。
&amp;nbsp;
示例 1:
输入: nums = [1,3,5,6], target = 5 输出: 2 示例&amp;nbsp;2:
输入: nums = [1,3,5,6], target = 2 输出: 1 示例 3:
输入: nums = [1,3,5,6], target = 7 输出: 4 &amp;nbsp;
提示:
1 &amp;lt;= nums.length &amp;lt;= 104 -104 &amp;lt;= nums[i] &amp;lt;= 104 nums 为&amp;nbsp;无重复元素&amp;nbsp;的&amp;nbsp;升序&amp;nbsp;排列数组 -104 &amp;lt;= target &amp;lt;= 104 分析#这题主要是用二分查找来解决。直接进行遍历没有充分考虑到所给的数组有序的条件，以及时间复杂度的要求~
题解#class Solution { public: int searchInsert(vector&amp;lt;int&amp;gt;&amp;amp; nums, int target) { int high = nums.</description>
    </item>
    
    <item>
      <title>第一章</title>
      <link>http://ivylet.github.io/docs/chapter05/part1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://ivylet.github.io/docs/chapter05/part1/</guid>
      <description>线性表
#include&amp;lt;stdio.h&amp;gt; #define ElementType int #define MAXSIZE 10 typedef struct SqList{ ElementType data[MAXSIZE]; int length; }SqList; void InitSqueList(SqList sq){ sq.length = 0; } void InsertSqueList(SqList* sq, int x){ (*sq).data[0] = x; } int main() { SqList sq; InitSqueList(sq); InsertSqueList(&amp;amp;sq,1); printf(&amp;#34;%d\n&amp;#34;,sq.length); printf(&amp;#34;%d&amp;#34;,sq.data[0]); return 0; } 线性存储 链式存储</description>
    </item>
    
  </channel>
</rss>
