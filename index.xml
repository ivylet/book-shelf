<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>首页 on QBook</title><link>http://ivylet.github.io/</link><description>Recent content in 首页 on QBook</description><generator>Hugo -- gohugo.io</generator><atom:link href="http://ivylet.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>STL中常用算法</title><link>http://ivylet.github.io/docs/chapter01/cpp-stl-argo/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://ivylet.github.io/docs/chapter01/cpp-stl-argo/</guid><description> STL中常用算法 # STL中定义了常用的一些算法，比如遍历，查找，排序等一些算法。
遍历 # for_each 查找 # count_if # 函数原型为count_if(v.begin(),v.end(),comp)
v.begin()为开始，v.end()为结束，comp为自定义判断函数。
举个例子：
排序 # 复制与拷贝 # 算术生成 # 集合算法 #</description></item><item><title>STL中常用算法1</title><link>http://ivylet.github.io/docs/chapter01/cpp/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://ivylet.github.io/docs/chapter01/cpp/</guid><description> STL 中常用算法 # STL 中定义了常用的一些算法，比如遍历，查找，排序等一些算法。
遍历 # for_each 查找 # count_if # 函数原型为count_if(v.begin(),v.end(),comp)
v.begin()为开始，v.end()为结束，comp为自定义判断函数。
举个例子：
排序 # 复制与拷贝 # 算术生成 # 集合算法 #</description></item><item><title>常用算法储备知识</title><link>http://ivylet.github.io/docs/chapter01/datastru/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://ivylet.github.io/docs/chapter01/datastru/</guid><description>时间复杂度 # 对数 ： 每轮排除一半情况 常用于二分法 指数：每轮分别出两倍情况 线性对数：一般为两层循环相互独立，一层为n一层为对数 常常出现在快速排序 空间复杂度 # 位运算 # 位运算有（&amp;amp;、|、^、~、&amp;raquo;、&amp;laquo;）这几种方法，以下为正且位数相同的二进制数进行的位运算，但是还会有其他特殊情况，比如二进制数非正，位数不同的情况。
符号 描述 运算规则 &amp;amp; 与 两个位都为1时，结果才为1 | 或 两个位都为0时，结果才为0 ^ 异或 两个位相同为0，相异为1 ~ 取反 0变1，1变0 &amp;laquo; 左移 各二进位全部左移若干位，高位丢弃，低位补0 &amp;raquo; 右移 各二进位全部右移若干位，对无符号数，高位补0，有符号数，各编译器处理方法不同 按位与运算符（&amp;amp;） # 定义：参加运算的两个数据，按二进制位进行&amp;quot;与&amp;quot;运算。
运算规则：同时为1才为1，
0&amp;amp;0=0 0&amp;amp;1=0 1&amp;amp;0=0 1&amp;amp;1=1 //两位同时为1，结果才为1，否则结果为0。 例如：5&amp;amp;7 即 0000 0101&amp;amp; 0000 0111 = 0000 0101，因此 5&amp;amp;7 的值为5。
注意：负数按补码形式参加按位与运算。
与运算的用途：
清零 如果想将一个单元清零，即使其全部二进制位为0，只要与一个各位都为零的数值相与，结果为零。 取一个数的指定位 比如取数 X=1011 1001 的低4位，只需要另找一个数Y，令Y的低4位为1，其余位为0，即Y=0000 1111，然后将X与Y进行按位与运算（X&amp;amp;Y=0000 1001）即可得到X的指定位。 判断奇偶 二进制的奇偶数只需要根据最未位是0还是1来决定，为0就是偶数，为1就是奇数。因此可以用if ((a &amp;amp; 1) == 0)代替if (a % 2 == 0)来判断a是不是偶数。 按位或运算符（|） # 定义：参加运算的两个对象，按二进制位进行&amp;quot;或&amp;quot;运算。</description></item><item><title>无意识？！</title><link>http://ivylet.github.io/docs/notes/other/00001/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://ivylet.github.io/docs/notes/other/00001/</guid><description>无意识是什么？ 自动机 循环运动
怎么计组这么多东西？ 还有两门课没学呢!</description></item><item><title>暂且第一记</title><link>http://ivylet.github.io/docs/notes/thinknote/00001/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://ivylet.github.io/docs/notes/thinknote/00001/</guid><description>不是为了个文凭吧，还是要自己想要去做什么东西？
不要焦虑
进一步学习 当前国内计算机现状，
如何成神？ 做大佬 所谓大佬 都是努力
知道努力很重要的人，并为之努力的人。
超越别人努力就行了。
焦虑来源：看错书，走弯路。我要学习，考研是顺带的东西。 拖延症，今天事情今天做完。
专注，有事情 就只考研。
考研没时间玩
化压力为动力
成神
别想着抄底！
别估分洗脑自己
说自己考70 70 130 130 想着想着以为自己真能考那么多？
复试焦虑？初试过了担心？ 初试有信心能过，复试为什么不能？
找研友，适当玩一小会，放空大脑 出去逛逛，有个兴趣爱好，
如何高效学习 正确的心态 瞄准目标使劲打 终身学习 培养自己 平复自己 任务拆解能力 整体任务 暑期任务 周报 日报 月报 时间管理能力 合理的学习计划 有学习梯度， 定一下计划吧，比如高数强化，是不是赶得有点紧了， 这也是一门学问。 做完之后能给自己带来多少收益。 学习技巧 给别人讲解 模拟考对自己狠一点 模拟考就是要严格考自己。该扣分就扣， 复习范围大于考试范围 自拍复习法 外接的支持 后期重要 前期准备好，后期才不慌。 对自己狠点
引用西游记中： 如果三心二意 就去看西游记。
得之泰然，
失之淡然，
争其必然，
顺其自然。
费曼学习法 我有学习动力，掌握方法工具。 及时输出。总结也是一种学习，备周！
2023年6月26日 22:33:39 # 不知道在搞什么 害!</description></item><item><title>C++ STL</title><link>http://ivylet.github.io/docs/chapter01/cpp-stl-intro/</link><pubDate>Thu, 10 Nov 2022 11:18:29 +0800</pubDate><guid>http://ivylet.github.io/docs/chapter01/cpp-stl-intro/</guid><description>什么是C++标准模板库（STL）？ # 标准模板库 STL（Standard Template Library），是 C++ 标准库的一部分，不需要单独安装，只需要#include 头文件。
C++ 对模板（Template）支持得很好，STL 就是借助模板把常用的数据结构及其算法都实现了一遍，并且做到了数据结构和算法的分离。
C++ 语言的核心优势之一就是便于软件的复用。
C++ 语言有两个方面体现了复用：
面向对象的继承和多态机制 通过模板的概念实现了对泛型程序设计的支持 C++中的模板，就好比英语作文的模板，只换主题，不换句式和结构。对应到C++模板，就是只换类型，不换方法。
STL有什么优势？ # STL封装了很多实用的容器，省时省力，能够让你将更多心思放到解决问题的步骤上，而非费力去实现数据结构诸多细节上，像极了用python时候的酣畅淋漓。
STL到底有什么？ # 六大部件:
容器 分配器 算法 迭代器 适配器 仿函数 自定义 # vector 矢量 # 定义 # 使用前需添加头文件
#include&amp;lt;vector&amp;gt; using namespace std; 像定义变量一样定义vector变量：
vector&amp;lt;类型名&amp;gt; 变量名; 类型名可以是int、double、char、struct，也可以是STL容器：vector、set、queue。
vector&amp;lt;int&amp;gt; name; vector&amp;lt;double&amp;gt; name; vector&amp;lt;char&amp;gt; name; vector&amp;lt;struct node&amp;gt; name; vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; name; vector数组就是一个一维数组,如果定义成vector数组的数组，那就是二维数组**。**
vector&amp;lt;int&amp;gt; array[SZIE]; //二维变长数组 在此，我送你一句话非常受用的话：低维是高维的地址。
二维数组中，它的一维形式就是地址。例如：
#include &amp;lt;iostream&amp;gt; using namespace std; int main(){ int arr[3][2];//定义一个3行2列的地址 cout&amp;lt;&amp;lt;arr[0]&amp;lt;&amp;lt;endl; //输出arr第1行的地址 cout&amp;lt;&amp;lt;arr[1]&amp;lt;&amp;lt;endl; //输出arr第2行的地址 cout&amp;lt;&amp;lt;arr[2]&amp;lt;&amp;lt;endl; //输出arr第3行的地址 return 0; } 输出：</description></item><item><title>一些话</title><link>http://ivylet.github.io/docs/notes/thinknote/00002/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://ivylet.github.io/docs/notes/thinknote/00002/</guid><description>2023-07-03 01:02:34+08:00 感觉自己还是没有十分投入吧，有点自己骗自己的感觉。学习考研没那么容易，明天再接再厉，找回状态。</description></item><item><title>《大问题》阅读随笔</title><link>http://ivylet.github.io/docs/notes/readingnotes/0001/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://ivylet.github.io/docs/notes/readingnotes/0001/</guid><description>The Big Questions
&amp;ldquo;哲学就是对智慧的爱。它是对价值重要性的坚持，是对完全陷入生活琐事而仅仅随波逐流的拒斥。我们渴望洞察，企盼理解，但我们的生活被常规攫住了，不时会被那些所谓的“消遣”或“娱乐”活动分神。我们失去的是思考的快乐、理解的挑战、灵感，以及哲学的慰藉。我们都是借着思想而生活的，所以问题的关键不在于是否从事哲学，而在于是接受一种廉价的、没有挑战的替代品，还是试图进行真正的思考。&amp;rdquo;</description></item><item><title>DP</title><link>http://ivylet.github.io/docs/chapter02/acwing/DP/DP/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://ivylet.github.io/docs/chapter02/acwing/DP/DP/</guid><description>背包DP # 01背包 # 每件物品最多只用一次。
有 N 件物品和一个容量是 V 的背包。每件物品只能使用一次。 第 i 件物品的体积是 vi，价值是 wi。 求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。
输出最大价值。 2. 01背包问题 - AcWing题库
#include&amp;lt;iostream&amp;gt; using namespace std; const int N = 1010; int v[N],w[N]; int m,n; int f[N][N]; int main(){ cin &amp;gt;&amp;gt; m &amp;gt;&amp;gt; n; for(int i = 1; i &amp;lt;= m;i++ ){ cin &amp;gt;&amp;gt; v[i] &amp;gt;&amp;gt; w[i]; } for(int i = 1; i &amp;lt;= m;i++){ for(int j = 0;j&amp;lt;= n;j++) { f[i][j] = f[i - 1][j]; if( j &amp;gt;= v[i]) //当可以装下的空间比第i个大才有可能存在装第i个物品的情况。 f[i][j] = max(f[i][j],f[i - 1][j - v[i]] + w[i]); } } cout &amp;lt;&amp;lt; f[m][n]; return 0; } 优化为二维</description></item><item><title>背包问题</title><link>http://ivylet.github.io/docs/chapter02/acwing/DP/package/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://ivylet.github.io/docs/chapter02/acwing/DP/package/</guid><description>01 背包问题 # 每件物品最多只用一次。
有 N 件物品和一个容量是 V 的背包。每件物品只能使用一次。 第 i 件物品的体积是 vi，价值是 wi。 求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。
输出最大价值。 2. 01背包问题 - AcWing题库
#include&amp;lt;iostream&amp;gt; using namespace std; const int N = 1010; int v[N],w[N]; int m,n; int f[N][N]; int main(){ cin &amp;gt;&amp;gt; m &amp;gt;&amp;gt; n; for(int i = 1; i &amp;lt;= m;i++ ){ cin &amp;gt;&amp;gt; v[i] &amp;gt;&amp;gt; w[i]; } for(int i = 1; i &amp;lt;= m;i++){ for(int j = 0;j&amp;lt;= n;j++) { f[i][j] = f[i - 1][j]; if( j &amp;gt;= v[i]) //当可以装下的空间比第i个大才有可能存在装第i个物品的情况。 f[i][j] = max(f[i][j],f[i - 1][j - v[i]] + w[i]); } } cout &amp;lt;&amp;lt; f[m][n]; return 0; } 优化为二维</description></item><item><title>常用工具</title><link>http://ivylet.github.io/docs/chapter03/machine-learning/tools/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://ivylet.github.io/docs/chapter03/machine-learning/tools/</guid><description>数据集网站 # UC Irvine Machine Learning Repository</description></item><item><title>常用思想方法</title><link>http://ivylet.github.io/docs/chapter02/commonSolution/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://ivylet.github.io/docs/chapter02/commonSolution/</guid><description>双指针思想 # 常用于对数组链表的处理，比如找两个和为定值的数。</description></item><item><title>基础算法一</title><link>http://ivylet.github.io/docs/chapter02/acwing/base/base-1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://ivylet.github.io/docs/chapter02/acwing/base/base-1/</guid><description>快速排序 # 主要思想: # 在数组中选择一个值，然后遍历数组，比这个值大的放到这个值后边，比这个值小的放到这个值的前边。
代码实现 # void quick_sort(int q[], int l, int r){ if(l &amp;gt;= r) return; int x = q[(l + r) &amp;gt;&amp;gt; 1], i = l - 1, j = r + 1; while(i &amp;lt; j) { do i ++ ; while(q[i] &amp;lt; x); do j -- ; while(q[j] &amp;gt; x); if(i &amp;lt; j) swap(q[i],q[j]); } quick_sort(q,l, j); quick_sort(q,j+1,r); } 为什么最后是j与j+1呢?
因为范围确保的是左边是小于等于x，右边大于等于x。而循环判断结束的限制是i&amp;lt;j,则可能出现的情况是i=j或i = j + 1。如果是i=j+1那么左边为l到i不满足左边都小于等于x，因为q[i]&amp;gt;x。那为什么不是l到i-1呢？如果是l到i-1那么可能出现只有两个数的情况，然后划分的时候右边化为空集，左边为两个数的数组，此时陷入无尽循环。</description></item><item><title>拉康</title><link>http://ivylet.github.io/docs/notes/readingnotes/0002/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://ivylet.github.io/docs/notes/readingnotes/0002/</guid><description>人们可以因为完全不同的原因对同一个人产生兴趣，并把他安插到各自生命的故事中的不同位置上。
科学只有一个目标，就是去知道，它不会考虑欲望、负罪感和享乐(jouissance)。对此，拉康说道：“科学会对所谓的人性造成一种不可呼吸的效果。”而精神分析相比科学的话语，处在例外的位置，它具有一种“人工肺的功能”。相比科学普遍化的尝试，精神分析的伦理学强调个体差异和每个人的独特性，这方面极端的例子是对于一些严重的精神病患者，有些分析家会主张针对每一个主体发明一种适合他的诊断，而不是将他对应到某个现有的诊断中。
精神分析能够利用到自身，对人性的反应。
三条岔路 # 另一个女人和男&amp;quot;工具人&amp;quot; #</description></item><item><title>其他</title><link>http://ivylet.github.io/docs/chapter02/acwing/math/others/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://ivylet.github.io/docs/chapter02/acwing/math/others/</guid><description> 秦九韶算法 # 使用秦九韶算法可以计算多项式的值，或进制转换。 例子：计算多项式的值。a[i]表示多项式中的x的i次幂的系数。
#include&amp;lt;iostream&amp;gt; using namespace std; int n,x,ans,a[21]; int main(){ cin&amp;gt;&amp;gt;n; for(int i=0;i&amp;lt;=n;i++) cin&amp;gt;&amp;gt;a[i]; cin&amp;gt;&amp;gt;x; ans=a[n]; for(int i=1;i&amp;lt;=n;i++) ans=ans*x+a[n-i]; cout&amp;lt;&amp;lt;ans; return 0; }</description></item><item><title>生活</title><link>http://ivylet.github.io/docs/notes/thinknote/00003/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://ivylet.github.io/docs/notes/thinknote/00003/</guid><description>记得东西有些杂乱，可以细分一下内容，归类，然后有空的时候整理一下，maybe换个主题？
关于生活的意义， 且听下回分解！
只喜欢一面，那只是占有欲啊！不是爱
我在想什么?! 好没用啊 明明我之前也不是这样的 这是不想承认自己不行吗
如果你想找回思考能力，可以尝试阅读一些挑战思维的书籍，如哲学、经济学、物理学、心理学等领域的经典著作。以下是一些建议：
哲学类：柏拉图的《理想国》、尼采的《查拉图斯特拉如是说》、笛卡尔的《第一哲学沉思》等。 经济学类：亚当·斯密的《国富论》、约翰·梅纳德·凯恩斯的《就业、利息和货币通论》等。 物理学类：艾萨克·牛顿的《自然哲学的数学原理》、爱因斯坦的《相对论》等。 心理学类：弗洛伊德的《精神分析导论》、卡尔·罗杰斯的《成为人》等。 这些书籍可以激发你的思维，让你思考一些深层次的问题，提高你的逻辑思考和判断能力。当然，也可以选择其他类型的书籍，只要是能够激发你思维的书籍都可以尝试阅读。
能够激发思维的书籍是指这些书籍可以激发读者的思维，让读者思考一些问题，探索一些新的想法，从而提升读者的认知水平和思考能力。这些书籍通常包含深刻的洞见、新颖的观点、严密的逻辑和清晰的语言表达。它们可以引发读者的兴趣，激发读者的好奇心和探究欲望，促使读者主动思考和探索。这些书籍不仅可以扩展读者的知识面，还可以提高读者的思考能力和思维方式。</description></item><item><title>数据结构</title><link>http://ivylet.github.io/docs/chapter02/acwing/base/datestruct/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://ivylet.github.io/docs/chapter02/acwing/base/datestruct/</guid><description>链表 # 拿数组模拟链表,其实也就是静态链表. 静态链表的优点是快,但是缺点是必须要提前分配足够空间,并且可能会出现假满状态,即idx到最后但是前边还有很多未使用的节点,
单链表 # #include&amp;lt;iostream&amp;gt; using namespace std; const int N = 100010; int e[N]; int ne[N]; int idx,head; void init(){ head = -1; idx = 0; } void add_to_head(int x){ e[idx] = x; ne[idx] = head; head = idx++; } //插入到下标为k的后面 void add(int k,int x){ e[idx] = x; ne[idx] = ne[k]; ne[k] = idx ++; } void del(int k){ if(k == -1) head = ne[head]; else ne[k] = ne[ne[k]]; } int main(){ int m; cin &amp;gt;&amp;gt; m; init(); while(m--){ char opt; cin &amp;gt;&amp;gt; opt; if(opt == &amp;#39;H&amp;#39;){ int x; cin &amp;gt;&amp;gt; x; add_to_head(x); }else if(opt == &amp;#39;D&amp;#39;){ int k; cin &amp;gt;&amp;gt; k; del(k-1); }else{ int k,x; cin &amp;gt;&amp;gt; k &amp;gt;&amp;gt;x; add(k - 1,x); } } int index = head; while(index !</description></item><item><title>数论</title><link>http://ivylet.github.io/docs/chapter02/acwing/math/shulun/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://ivylet.github.io/docs/chapter02/acwing/math/shulun/</guid><description>质数 # 针对所有大于1的自然数定义的，只包含1和本身两个约数的自然数叫做质数（素数）。
质数的判定 # 试除法 # bool is_prime(int n){ if(n &amp;lt; 2) return false; for(int i = 2; i &amp;lt;= n ; i++){ if(n % i == 0) return false; } return true; } O(n); 如果i包含其他因子，那么这因子应该是成双成对出现的。比如12的因子有{1,2,3,4,6,12}。 这里只需要遍历成对中的第一个就可以了， 如果n可以被d整除，证明d是n的一个因子，那么另外一个与其对应的因子是n除以n除以d的商。所以我只需要遍历到第一个因子就可以了，即d满足大于n除以d的商，d大于根号n就OK。时间复杂度可以降到根号n。
bool is_prime(int n){ if(n &amp;lt; 2) return false; for(int i = 2; i &amp;lt;= n / i ; i++){ if(n % i == 0) return false; } return true; } O(sqrt(n)); 不使用sqrt(i)可以降低时间复杂度，每次循环都会计算一次。如果使用i * i &amp;lt;= n，则可能存在 i * i溢出风险，变成负值。</description></item><item><title>搜索与图论</title><link>http://ivylet.github.io/docs/chapter02/acwing/base/search_and_graph/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://ivylet.github.io/docs/chapter02/acwing/base/search_and_graph/</guid><description> 图论 # Floyd算法 # 主要思想是: 循环邻接矩阵中查找每个点到另外一个点的最短距离，不仅是看直接距离，也还要通过计算中转点。比如计算A到B的距离，要比较A到C的距离与C到B的距离的和、A到B的直接距离的最小值来判断，中转点可以是其他节点，所以代码实现中出现了三重循环。
//n为顶点个数 //第一轮循环为 选取中间点的个数 //第二三轮循环为 void floyd(){ for(int k = 1 ; k &amp;lt;=n ; k++) for(int i = 1 ; i &amp;lt;= n ;i ++) for(int j = 1 ; j &amp;lt;=n ;j ++) dic[i][j] = min(dic[i][j],dic[i][k] + dic[k][j]); } 模板题代码：
#include&amp;lt;iostream&amp;gt; using namespace std; const int N = 210,INF = 1e9; int dic[N][N]; int n,m,Q; void floyd(){ for(int k = 1 ; k &amp;lt;=n ; k++) for(int i = 1 ; i &amp;lt;= n ;i ++) for(int j = 1 ; j &amp;lt;=n ;j ++) dic[i][j] = min(dic[i][j],dic[i][k] + dic[k][j]); } int main(){ scanf(&amp;#34;%d%d%d&amp;#34;,&amp;amp;n,&amp;amp;m,&amp;amp;Q); for(int i = 1 ; i &amp;lt;= n ;i ++) for(int j = 1 ; j&amp;lt;=n;j++) if(i == j) dic[i][j] = 0; else dic[i][j] = INF; while(m--) { int a,b,w; scanf(&amp;#34;%d%d%d&amp;#34;,&amp;amp;a,&amp;amp;b,&amp;amp;w); dic[a][b] = min(dic[a][b],w); } floyd(); while(Q--) { int a,b; scanf(&amp;#34;%d%d&amp;#34;,&amp;amp;a,&amp;amp;b); if(dic[a][b] &amp;lt; INF / 2) printf(&amp;#34;%d&amp;#34;,dic[a][b]); else printf(&amp;#34;impossible&amp;#34;); printf(&amp;#34;\n&amp;#34;); } return 0; }</description></item><item><title>算法竞赛常用STL</title><link>http://ivylet.github.io/docs/chapter01/argo-datastru/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://ivylet.github.io/docs/chapter01/argo-datastru/</guid><description>数据结构 # vector[可变数组] # vector是一种变长数组，即可以自动改变长度的数组。 头文件
#include&amp;lt;vector&amp;gt; 初始化
#include&amp;lt;iostream&amp;gt; #include&amp;lt;vector&amp;gt; using namespace std; int main () { //几种初始化的方法 vector&amp;lt;int&amp;gt; a;//定义一个vector 未初始化 输出》 0 vector&amp;lt;int&amp;gt; a(3);//定义一个长度为3的vector 未初始化 输出》0 0 0 vector&amp;lt;int&amp;gt; a(10, 3); //定义一个长度为10，且每个数赋值为3 //将向量b中从下标0 1 2（共三个）的元素赋值给a，a的类型为int型 //它的初始化不和数组一样 vector&amp;lt;int&amp;gt;a(b.begin(),b.begin+3); //从数组中获得初值 int b[7]={1,2,3,4,5,6,7}; vector&amp;lt;int&amp;gt; a(b,b+7）; for(auto x : a) {//遍历输出 cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &amp;#34; &amp;#34;; } return 0; } 相关函数
a.size();//返回元素个数 a.resize();//改变大小 a.empty();//判断a是否为空，空则返回true，非空则返回false a.front(); //返回a的第1个元素,当且仅当a存在 a.back(); //返回vector的最后一个数 a.clear(); //清空a中的元素 a.pop_back(); //删除a向量的最后一个元素 a.</description></item><item><title>贪心</title><link>http://ivylet.github.io/docs/chapter02/acwing/base/greedy/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://ivylet.github.io/docs/chapter02/acwing/base/greedy/</guid><description> 与区间有关的问题 #</description></item><item><title>原初号</title><link>http://ivylet.github.io/docs/notes/thinknote/00000/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://ivylet.github.io/docs/notes/thinknote/00000/</guid><description>为什么要记录？
借用知乎上某位网友对问题“语言和文字有本质上的区别吗？”的回答：
“文字又是对语言的记录。是为了从时间上，把过去的思维记录下来。所以本质上看文字是语言的扩张，是又一次信息传递的生产力革命。通过文字对语言的记录，使得瞬间的思维得以固定下来，这带来更多的经验。”
“文字操纵思想，思想操控文字。”
许多想法总是会在闲余时，在脑子中涌现，这些想法可能包括了一些自己经常思考的问题，比如对自己的某些问题的评价，一些事情的态度等等，但过后又会忘记。所以就想不如有什么思考或者想法，就记录下来吧。
学习别人之长。
现在是2023-06-18 00:16:38，午夜。当下目标是考研，大约还有188天，约莫6个月。是当前最要紧之事， 暂且先列一下吧，
阅读计划（根据当前手里的书）：
乔布斯专 沙丘 中央重大决策背后的故事（党史） 矛盾论导读 &amp;hellip;.. 当然是有空了读，眼下最重要的还是刷题，学习。 还有就是一个心理问题，下次说）
努力和努力有用？
生活处处有机会，看路（找准路子，这个路子可能并不是你以为正确的路子，可能需要超出自己当前的认知，所以说要适时扩大自己的认知，不要被周围的人所困）！
123
2023年8月9日
关于生活，
家人、朋友、自己、
时间线 # 2023-07-02 # 记得滚动复习！少抽点时间给线代和概论。
今天听了高数强化课 因为各种事情学习时间少吧。明天步入正轨
2023-07-01 # 下半年第一天！不要急躁，一步步来。
值班 莫得运动 今日 # 高数强化定积分，做例题。 408同步与互斥! 英语单词加阅读，阅读做的不好，不够细致。 明日 # 想一下定目标，每天线性代数和概率论小推进一点。 408继续往后推进 英语 细心！ 。。。。 2023-06-30 # 运动 但是室内 哇，六月最后一天，下半年第一天。 今日 # 高数强化跟进到定积分哩，习题也都跟着做，不过自习室调换确实有点小影响心情 408 操作系统 听完调度算法，题还没做。 英语背了单词，新背了三十多个 好多不会、、 明日 # 晚上可能要值班 不运动了 高数强化把定积分例题做完，快速把强化课过一遍。 408做完课后题，课往后推进一节。 英语背单词加阅读。 2023-06-29 # 小运动 今天原来都周四了。 今日 # 880第二章综合篇剩大题了，然后第三章积分开了，但是有点小困难。 英语只背了单词，因为开会没做题 408计组结束啦，操作系统第一章也结束了。但是和计组联系还是挺多的。 。。。。 明天 # 上午把积分例题做完搞懂，下午多花一个小时做数学， 英语中午抽会时间背单词。 下午加晚上看408 适量运动！ 2023-06-28 # 运动 今日完成 # 880第二章基础篇完成了！ 辅导讲义例题推进了一点。 英语一篇阅读&amp;amp;单词背诵 408 计组 I/O 加中断 计组剩最后一章啦！ 。。 明天 # 880第二章选择题&amp;amp;辅导讲义例题 英语一篇阅读&amp;amp;单词背诵 计组收尾！ 。。。 2023-06-27 # 运动 今日完成 # 880第二章基础题 做不动 因为很多证明题。 概率论基础阶段完成，高数基础阶段全部完成。 英语背单词 到一千词 408 进度到计组 第五章末尾 。 明日任务 # 880第二章基础题做完。 辅导讲义例题推进。</description></item></channel></rss>