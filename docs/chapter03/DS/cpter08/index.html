<!doctype html><html lang=zh dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="1.0 十大经典排序算法 | 菜鸟教程
常用排序算法 # 冒泡排序 选择排序 插入排序 希尔排序 归并排序 快速排序 堆排序 基数排序 桶排序 计数排序 排序算法的稳定性 # 什么是稳定性？ # 稳定的算法是在排序后，相同排序属性的元素预期的前后顺序是已知的，不稳定的排序算法是未知的，即有可能是稳定算法的顺序，也有可能不是。 如果一个排序算法是稳定的，那么对于两个数值相同的元素而言，它们的相对位置是不变的。这对于只考虑排序属性的排序而言是无意义的，因为该排序是需要考虑排序属性的前后问题。但是如果排序的每个元素含有其他属性，这些属性需要保持一定的前后顺序，例如在排序含有姓名与年龄属性的用户时（待排序的用户是按照姓氏首字母的顺序排列），按照用户年龄排序，但是需要保证排序后相同年龄的用户前后顺序依旧是按照姓氏首字母来排，那么就需要保证排序算法的稳定性。
什么排序算法是稳定的？ # 稳定的排序算法如果细节未处理好就会变成不稳定的排序算法，而不稳定的排序算法得出的结果就是不稳定的。 稳定的排序算法有： 直接插入排序、冒泡排序、归并排序、基数排序 不稳定的排序算法： 希尔排序、选择排序、堆排序、快速排序
冒泡排序 # 基本思想 # 重复走访要排序的数列，一次比较两个相邻的数字大小，如果不符合顺序就交换，交换后移动到下一位进行比较。遍历遍历完一次数组后，重新从头操作，直到没有任何一对数字需要比较。
代码实现 # void buble_sort(vector<int>& array){ int len = array.size(); int flag = 0; //定义标志位,判断是否已经排好。 for(int i = 0;i < len - 1;++i){ for(int j = 0;j < len - 1;++j){ if(array[j] > array[j+1]){ array[j] ^= array[j+1]; array[j+1] ^= array[j]; array[j] ^= array[j+1];// 交换 flag = 1;//如果有交换则证明排序未结束。 } } if(flag == 0) break;//一次遍历中无交换则证明排序已完成。 else flag = 0; } } 时空损耗 # 时间复杂度"><meta name=theme-color content="#FFFFFF"><meta name=color-scheme content="light dark"><meta property="og:title" content="排序算法"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:url" content="http://ivylet.github.io/docs/chapter03/DS/cpter08/"><title>排序算法 | QBook</title><link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png type=image/x-icon><link rel=stylesheet href=/book.min.4b35fed0bea034bbc19c89c71e14b73fb9c68cfcc586b9382adfb9b7b103ba06.css integrity="sha256-SzX+0L6gNLvBnInHHhS3P7nGjPzFhrk4Kt+5t7EDugY=" crossorigin=anonymous><script defer src=/flexsearch.min.js></script>
<script defer src=/zh.search.min.4eb7993ef63f5c2c50e865c42dbdf9b032a352d679f97f19b434aa9de80d3717.js integrity="sha256-TreZPvY/XCxQ6GXELb35sDKjUtZ5+X8ZtDSqnegNNxc=" crossorigin=anonymous></script>
<script defer src=/sw.min.6f6f90fcb8eb1c49ec389838e6b801d0de19430b8e516902f8d75c3c8bd98739.js integrity="sha256-b2+Q/LjrHEnsOJg45rgB0N4ZQwuOUWkC+NdcPIvZhzk=" crossorigin=anonymous></script>
<link rel=alternate type=application/rss+xml href=http://ivylet.github.io/docs/chapter03/DS/cpter08/index.xml title=QBook></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>QBook</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=搜索 aria-label=搜索 maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul class=book-languages><li><input type=checkbox id=languages class=toggle>
<label for=languages class="flex justify-between"><a role=button class="flex align-center"><img src=/svg/translate.svg class=book-icon alt=Languages>
Chinese</a></label><ul><li><a href=http://ivylet.github.io/en/>English</a></li></ul></li></ul><ul><li><input type=checkbox id=section-903d3e7635db560eef69c6ad03432b92 class=toggle>
<label for=section-903d3e7635db560eef69c6ad03432b92 class="flex justify-between"><a role=button>第一章|基础知识储备</a></label><ul><li><a href=/docs/chapter01/cpp-stl-argo/>STL中常用算法</a></li><li><a href=/docs/chapter01/cpp/>STL中常用算法1</a></li><li><a href=/docs/chapter01/datastru/>常用算法储备知识</a></li><li><a href=/docs/chapter01/cpp-stl-intro/>C++ STL</a></li><li><a href=/docs/chapter01/argo-datastru/>算法竞赛常用STL</a></li></ul></li><li><input type=checkbox id=section-144f7b511d4fbbff231a670ff00b5f9e class=toggle>
<label for=section-144f7b511d4fbbff231a670ff00b5f9e class="flex justify-between"><a role=button>第二章|基础算法</a></label><ul><li><input type=checkbox id=section-9db364c0dccf0502e8049e61bd8b0d86 class=toggle>
<label for=section-9db364c0dccf0502e8049e61bd8b0d86 class="flex justify-between"><a role=button>Acwing</a></label><ul><li><input type=checkbox id=section-96943a9cc0137d53acdca869bdf27124 class=toggle>
<label for=section-96943a9cc0137d53acdca869bdf27124 class="flex justify-between"><a role=button>Base</a></label><ul><li><a href=/docs/chapter02/acwing/base/base-1/>基础算法一</a></li><li><a href=/docs/chapter02/acwing/base/datestruct/>数据结构</a></li><li><a href=/docs/chapter02/acwing/base/search_and_graph/>搜索与图论</a></li><li><a href=/docs/chapter02/acwing/base/greedy/>贪心</a></li></ul></li><li><input type=checkbox id=section-88eae5c1d766baf874d32d1908707564 class=toggle>
<label for=section-88eae5c1d766baf874d32d1908707564 class="flex justify-between"><a role=button>Dp</a></label><ul><li><a href=/docs/chapter02/acwing/DP/DP/>DP</a></li><li><a href=/docs/chapter02/acwing/DP/package/>背包问题</a></li></ul></li><li><input type=checkbox id=section-a50d07f316054aeee9419b25ddf950a0 class=toggle>
<label for=section-a50d07f316054aeee9419b25ddf950a0 class="flex justify-between"><a role=button>Math</a></label><ul><li><a href=/docs/chapter02/acwing/math/others/>其他</a></li><li><a href=/docs/chapter02/acwing/math/shulun/>数论</a></li></ul></li></ul></li><li><a href=/docs/chapter02/commonSolution/>常用思想方法</a></li></ul></li><li><input type=checkbox id=section-fca257306a653a028d58c47b763ab4c5 class=toggle checked>
<label for=section-fca257306a653a028d58c47b763ab4c5 class="flex justify-between"><a role=button>第三章|计算机基础知识</a></label><ul><li><input type=checkbox id=section-c6a658a9eab81ef20c403bdfcfbb322f class=toggle checked>
<label for=section-c6a658a9eab81ef20c403bdfcfbb322f class="flex justify-between"><a role=button>数据结构</a></label><ul><li><a href=/docs/chapter03/DS/cpter08/ class=active>排序算法</a><ul></ul></li></ul></li><li><input type=checkbox id=section-40effe6a2504b41caa4ca2922e36dd2a class=toggle>
<label for=section-40effe6a2504b41caa4ca2922e36dd2a class="flex justify-between"><a role=button>计算机组成原理</a></label><ul><li><a href=/docs/chapter03/CO/cpt02/>第二章|数据的表示与运算</a><ul></ul></li><li><a href=/docs/chapter03/CO/cpt03/>第三章|存储系统</a><ul></ul></li><li><a href=/docs/chapter03/CO/cpt04/>第四章|指令系统</a><ul></ul></li><li><a href=/docs/chapter03/CO/cpt05/>第五章|中央控制器</a><ul></ul></li></ul></li><li><input type=checkbox id=section-90808d88c5fb0a7411c304bba41a80d8 class=toggle>
<label for=section-90808d88c5fb0a7411c304bba41a80d8 class="flex justify-between"><a role=button>操作系统</a></label><ul><li><span>第一章|计算机系统概述</span><ul></ul></li><li><span>第二章|进程与线程</span><ul></ul></li><li><span>第三章|内存管理</span><ul></ul></li><li><span>第四章|文佳管理</span><ul></ul></li><li><span>第五章|I/O管理</span><ul></ul></li></ul></li><li><input type=checkbox id=section-25823a2461316869125b231cfddbbdc4 class=toggle>
<label for=section-25823a2461316869125b231cfddbbdc4 class="flex justify-between"><a role=button>机器学习</a></label><ul><li><a href=/docs/chapter03/machine-learning/tools/>常用工具</a></li><li><a href=/docs/chapter03/machine-learning/LinerRegression/>线性回归</a><ul></ul></li></ul></li></ul></li><li><input type=checkbox id=section-574b1a2b668b65d846660d1f8c5a4bfb class=toggle>
<label for=section-574b1a2b668b65d846660d1f8c5a4bfb class="flex justify-between"><a role=button>记录和其他</a></label><ul><li><input type=checkbox id=section-c1536e74d6e5fb6bc2e23ae4a04a06df class=toggle>
<label for=section-c1536e74d6e5fb6bc2e23ae4a04a06df class="flex justify-between"><a role=button>暂时没名字</a></label><ul><li><a href=/docs/notes/other/00001/>无意识？！</a></li></ul></li><li><input type=checkbox id=section-a3b6ca56f01a783b7e83028f9b977c5b class=toggle>
<label for=section-a3b6ca56f01a783b7e83028f9b977c5b class="flex justify-between"><a role=button>小记</a></label><ul><li><a href=/docs/notes/thinknote/00001/>暂且第一记</a></li><li><a href=/docs/notes/thinknote/00002/>一些话</a></li><li><a href=/docs/notes/thinknote/00003/>生活</a></li><li><a href=/docs/notes/thinknote/00000/>原初号</a></li></ul></li><li><span>notes</span><ul><li><a href=/docs/notes/readingnotes/0001/>《大问题》阅读随笔</a></li><li><a href=/docs/notes/readingnotes/0002/>拉康</a></li></ul></li></ul></li></ul><ul><li><a href=https://github.com/ivylet target=_blank rel=noopener>Github</a></li><li><a href=https://leetcode.cn/ target=_blank rel=noopener>Leetcode</a></li><li><a href=https://themes.gohugo.io/hugo-book/ target=_blank rel=noopener>Hugo Themes</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label>
<strong>排序算法</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><ul><li><a href=#常用排序算法>常用排序算法</a></li><li><a href=#排序算法的稳定性>排序算法的稳定性</a><ul><li></li><li><a href=#什么排序算法是稳定的>什么排序算法是稳定的？</a></li></ul></li><li><a href=#冒泡排序>冒泡排序</a><ul><li></li></ul></li><li><a href=#选择排序>选择排序</a></li><li><a href=#插入排序>插入排序</a></li><li><a href=#希尔排序>希尔排序</a></li><li><a href=#归并排序>归并排序</a></li><li><a href=#快速排序>快速排序</a><ul><li></li></ul></li><li><a href=#堆排序>堆排序</a></li><li><a href=#基数排序>基数排序</a></li><li><a href=#桶排序>桶排序</a></li><li><a href=#计数排序>计数排序</a></li></ul></li></ul></nav></aside></header><article class=markdown><p><a href=https://www.runoob.com/w3cnote/ten-sorting-algorithm.html>1.0 十大经典排序算法 | 菜鸟教程</a></p><h2 id=常用排序算法>常用排序算法
<a class=anchor href=#%e5%b8%b8%e7%94%a8%e6%8e%92%e5%ba%8f%e7%ae%97%e6%b3%95>#</a></h2><ul><li>冒泡排序</li><li>选择排序</li><li>插入排序</li><li>希尔排序</li><li>归并排序</li><li>快速排序</li><li>堆排序</li><li>基数排序</li><li>桶排序</li><li>计数排序</li></ul><h2 id=排序算法的稳定性>排序算法的稳定性
<a class=anchor href=#%e6%8e%92%e5%ba%8f%e7%ae%97%e6%b3%95%e7%9a%84%e7%a8%b3%e5%ae%9a%e6%80%a7>#</a></h2><h4 id=什么是稳定性>什么是稳定性？
<a class=anchor href=#%e4%bb%80%e4%b9%88%e6%98%af%e7%a8%b3%e5%ae%9a%e6%80%a7>#</a></h4><p>稳定的算法是在排序后，相同排序属性的元素预期的前后顺序是已知的，不稳定的排序算法是未知的，即有可能是稳定算法的顺序，也有可能不是。
如果一个排序算法是稳定的，那么对于两个数值相同的元素而言，它们的相对位置是不变的。这对于只考虑排序属性的排序而言是无意义的，因为该排序是需要考虑排序属性的前后问题。但是如果排序的每个元素含有其他属性，这些属性需要保持一定的前后顺序，例如在排序含有姓名与年龄属性的用户时（待排序的用户是按照姓氏首字母的顺序排列），按照用户年龄排序，但是需要保证排序后相同年龄的用户前后顺序依旧是按照姓氏首字母来排，那么就需要保证排序算法的稳定性。</p><h3 id=什么排序算法是稳定的>什么排序算法是稳定的？
<a class=anchor href=#%e4%bb%80%e4%b9%88%e6%8e%92%e5%ba%8f%e7%ae%97%e6%b3%95%e6%98%af%e7%a8%b3%e5%ae%9a%e7%9a%84>#</a></h3><p>稳定的排序算法如果细节未处理好就会变成不稳定的排序算法，而不稳定的排序算法得出的结果就是不稳定的。
稳定的排序算法有：
直接插入排序、冒泡排序、归并排序、基数排序
不稳定的排序算法：
希尔排序、选择排序、堆排序、快速排序</p><h2 id=冒泡排序>冒泡排序
<a class=anchor href=#%e5%86%92%e6%b3%a1%e6%8e%92%e5%ba%8f>#</a></h2><h4 id=基本思想>基本思想
<a class=anchor href=#%e5%9f%ba%e6%9c%ac%e6%80%9d%e6%83%b3>#</a></h4><p>重复走访要排序的数列，一次比较两个相邻的数字大小，如果不符合顺序就交换，交换后移动到下一位进行比较。遍历遍历完一次数组后，重新从头操作，直到没有任何一对数字需要比较。</p><h4 id=代码实现>代码实现
<a class=anchor href=#%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b0>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>buble_sort</span>(vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&amp;</span> array){  
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>int</span> len <span style=color:#f92672>=</span> array.size();  
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>int</span> flag <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;  <span style=color:#75715e>//定义标志位,判断是否已经排好。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;i <span style=color:#f92672>&lt;</span> len <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>;<span style=color:#f92672>++</span>i){  
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;j <span style=color:#f92672>&lt;</span> len <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>;<span style=color:#f92672>++</span>j){  
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>if</span>(array[j] <span style=color:#f92672>&gt;</span> array[j<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>]){  
</span></span><span style=display:flex><span>				array[j] <span style=color:#f92672>^=</span> array[j<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>];  
</span></span><span style=display:flex><span>				array[j<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>] <span style=color:#f92672>^=</span> array[j];  
</span></span><span style=display:flex><span>				array[j] <span style=color:#f92672>^=</span> array[j<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>];<span style=color:#75715e>// 交换  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>				flag <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;<span style=color:#75715e>//如果有交换则证明排序未结束。  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			}  
</span></span><span style=display:flex><span>		}  
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span>(flag <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) <span style=color:#66d9ef>break</span>;<span style=color:#75715e>//一次遍历中无交换则证明排序已完成。  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#66d9ef>else</span> flag <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;  
</span></span><span style=display:flex><span>	}  
</span></span><span style=display:flex><span>}  
</span></span></code></pre></div><h4 id=时空损耗>时空损耗
<a class=anchor href=#%e6%97%b6%e7%a9%ba%e6%8d%9f%e8%80%97>#</a></h4><p>时间复杂度</p><ul><li>平均时间复杂度<br>O(n^2)</li><li>最好情况<br>O(n)，刚好就是预期的顺序。</li><li>最坏情况<br>O(n^2)，刚好就是反着的顺序。
空间复杂度<br>O(1)，只使用了循环所需要的变量。</li></ul><h2 id=选择排序>选择排序
<a class=anchor href=#%e9%80%89%e6%8b%a9%e6%8e%92%e5%ba%8f>#</a></h2><ul><li>基本思想<br>首先在数组中找最小（大）的元素，找到了放到数组起始位置，然后开始在除去起始位置的数组中寻找第二小（大）的元素，然后放到第二位置，如此重复直到最后一个位置。</li></ul><h2 id=插入排序>插入排序
<a class=anchor href=#%e6%8f%92%e5%85%a5%e6%8e%92%e5%ba%8f>#</a></h2><h2 id=希尔排序>希尔排序
<a class=anchor href=#%e5%b8%8c%e5%b0%94%e6%8e%92%e5%ba%8f>#</a></h2><h2 id=归并排序>归并排序
<a class=anchor href=#%e5%bd%92%e5%b9%b6%e6%8e%92%e5%ba%8f>#</a></h2><h2 id=快速排序>快速排序
<a class=anchor href=#%e5%bf%ab%e9%80%9f%e6%8e%92%e5%ba%8f>#</a></h2><h4 id=基本思想-1>基本思想
<a class=anchor href=#%e5%9f%ba%e6%9c%ac%e6%80%9d%e6%83%b3-1>#</a></h4><p>快速排序采用了分治算法的思想，即分而治之。如果要排序一个数组，我可以先随意挑选选一个基准值（通常为数组的第一个元素，因为数组第一个元素一般是一般情况下都有的，取值方便），然后把比它大的放左边，比它小的放右边，然后这个问题就变成了基准值左边的小数组的排序和基准值右边的小数组的排序。然后我们可以对两个小数组进行快速排序，如此重复。</p><h4 id=代码实现-1>代码实现
<a class=anchor href=#%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b0-1>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>Paritition1</span>(<span style=color:#66d9ef>int</span> A[], <span style=color:#66d9ef>int</span> low, <span style=color:#66d9ef>int</span> high){
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>int</span> pivot <span style=color:#f92672>=</span> A[low]; <span style=color:#75715e>//设定基准值
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>while</span> (low <span style=color:#f92672>&lt;</span> high){
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>while</span> (low <span style=color:#f92672>&lt;</span> high <span style=color:#f92672>&amp;&amp;</span> A[high] <span style=color:#f92672>&gt;=</span> pivot){
</span></span><span style=display:flex><span>			<span style=color:#f92672>--</span>high;
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		A[low] <span style=color:#f92672>=</span> A[high];
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>while</span> (low <span style=color:#f92672>&lt;</span> high <span style=color:#f92672>&amp;&amp;</span> A[low] <span style=color:#f92672>&lt;=</span> pivot){
</span></span><span style=display:flex><span>			<span style=color:#f92672>++</span>low;
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		A[high] <span style=color:#f92672>=</span> A[low];
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	A[low] <span style=color:#f92672>=</span> pivot;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> low;
</span></span><span style=display:flex><span>}<span style=color:#75715e>//以基准来划分两边的数组。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>QuickSort</span>(<span style=color:#66d9ef>int</span> A[], <span style=color:#66d9ef>int</span> low, <span style=color:#66d9ef>int</span> high){ <span style=color:#75715e>//快排母函数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>if</span> (low <span style=color:#f92672>&lt;</span> high){
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>int</span> pivot <span style=color:#f92672>=</span> Paritition1(A, low, high);
</span></span><span style=display:flex><span>		QuickSort(A, low, pivot <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>		QuickSort(A, pivot <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>, high);
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=堆排序>堆排序
<a class=anchor href=#%e5%a0%86%e6%8e%92%e5%ba%8f>#</a></h2><h2 id=基数排序>基数排序
<a class=anchor href=#%e5%9f%ba%e6%95%b0%e6%8e%92%e5%ba%8f>#</a></h2><h2 id=桶排序>桶排序
<a class=anchor href=#%e6%a1%b6%e6%8e%92%e5%ba%8f>#</a></h2><h2 id=计数排序>计数排序
<a class=anchor href=#%e8%ae%a1%e6%95%b0%e6%8e%92%e5%ba%8f>#</a></h2></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/ivylet/book-shelf/commit/f5e95a7f908fe05690e362f3a6998be43c14196f title='最后修改者 saytaytay | August 6, 2024' target=_blank rel=noopener><img src=/svg/calendar.svg class=book-icon alt=Calendar>
<span>August 6, 2024</span></a></div><div><a class="flex align-center" href=https://github.com/ivylet/book-shelf/edit/main/exampleSite/content/docs/chapter03/DS/cpter08/_index.md target=_blank rel=noopener><img src=/svg/edit.svg class=book-icon alt=Edit>
<span>编辑本页</span></a></div><footer id=footer><div class=container>&copy; 2024, By ivylet</a>。</div></footer></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><ul><li><a href=#常用排序算法>常用排序算法</a></li><li><a href=#排序算法的稳定性>排序算法的稳定性</a><ul><li></li><li><a href=#什么排序算法是稳定的>什么排序算法是稳定的？</a></li></ul></li><li><a href=#冒泡排序>冒泡排序</a><ul><li></li></ul></li><li><a href=#选择排序>选择排序</a></li><li><a href=#插入排序>插入排序</a></li><li><a href=#希尔排序>希尔排序</a></li><li><a href=#归并排序>归并排序</a></li><li><a href=#快速排序>快速排序</a><ul><li></li></ul></li><li><a href=#堆排序>堆排序</a></li><li><a href=#基数排序>基数排序</a></li><li><a href=#桶排序>桶排序</a></li><li><a href=#计数排序>计数排序</a></li></ul></li></ul></nav></div></aside></main></body></html>