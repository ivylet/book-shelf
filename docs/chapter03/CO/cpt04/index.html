<!doctype html><html lang=zh dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="指令系统 # 指令（机器指令）：是指计算机执行某种操作的命令，是计算机运行的最小功能单位。 一台计算机的所有指令集合构成该计算机的指令系统，也称指令集。一台计算机只能执行自己指令系统中的指令，不能执行其他系统的指令。x86架构（一般是PC机）与ARM架构（一般是手机）的指令集不同。
指令格式 # 操作码：做什么 地址码（操作数）：对谁做 一条指令通常包括操作码字段和地址码字段两部分。
一条指令可能包括0、1、2、3、4个地址码。
根据地址码数量不同，可以将指令分为零地址指令，一地址指令，二地址指令&mldr;..
零地址指令 # 只有操作码，没有操作数。 这种指令有两种可能：
不需要操作数的指令，比如空操作指令，停机指令，关中断指令等。 在堆栈计算机中，通常将两个操作数隐含存放在栈顶和次栈顶，计算结构压回栈顶。 一地址指令 # 有操作码和一个操作数。
只需要单操作数，如加1、减1、取反，求补等 OP(A1)->A1，完成一条指令需要3次访存：取指->读A1->写A1 需要两个操作数， 需要两个操作数，但其中一个操作数隐含在某个寄存器（如隐含在ACC） (ACC)OP(A1)->ACC，完成一条指令需要2次访存，取指->读A1 二地址指令 # 常用于需要两个操作数的算术运算、逻辑运算相关指令。
(A1)OP(A2)->A1，完成一条指令通常需要访存4次，取指->读A1->读A2->写A1
三地址指令 # 常用于需要两个操作数的算术运算、逻辑运算相关指令。
(A1)OP(A2)->A3，完成一条指令通常需要访存4次，取指->读A1->读A2->写A3
四地址指令 # (A1)OP(A2)->A3，A4为下一条将要执行的地址，完成一条指令通常需要访存4次，取指->读A1->读A2->写A3
正常情况下：取指令后PC+1，指向下一条指令。
四地址指令：执行指令后，将PC值修改为A4所指地址。
n位地址码的直接寻址范围为2n ，若指令总长度固定不变，则地址吗数量越多，寻址能力越差。
指令分类 # 按指令长度分类 # 例如双字长指令在取指时需要两次访存 定长指令字结构： 指令系统中所有指令的长度都相等。定长操作码可以简化计算机硬件设计，提高指令译码和识别速度。 变长指令字结构： 指令系统中各种指令的长度不等。
按操作码长度分类 # 定长操作码： 指令系统中所有指令的操作码长度都相同。 例如n位操作码，最多支持2n条指令。 可变长操作码： 指令系统中所有指令的操作码长度可变。 按操作类型分类 # 数据传送 （数据传送类） LOAD 把存储器中的数据放到寄存器中 STORE 把寄存器中的数据放到存储器中 算数逻辑运算 （运算类） 算数运算：加、减、乘、除、增一、减一、求补、浮点运算、十进制运算等
逻辑运算：与或非异或位操作、位测试、位清除、位求反。 移位操作 （运算类） 算术移位、逻辑移位、循环移位（带进位和不带进位） 转移操作 （程序执行流的改变） 无条件转移 JMP"><meta name=theme-color content="#FFFFFF"><meta name=color-scheme content="light dark"><meta property="og:title" content="第四章|指令系统"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:url" content="http://ivylet.github.io/docs/chapter03/CO/cpt04/"><title>第四章|指令系统 | QBook</title><link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png type=image/x-icon><link rel=stylesheet href=/book.min.4b35fed0bea034bbc19c89c71e14b73fb9c68cfcc586b9382adfb9b7b103ba06.css integrity="sha256-SzX+0L6gNLvBnInHHhS3P7nGjPzFhrk4Kt+5t7EDugY=" crossorigin=anonymous><script defer src=/flexsearch.min.js></script>
<script defer src=/zh.search.min.4eb7993ef63f5c2c50e865c42dbdf9b032a352d679f97f19b434aa9de80d3717.js integrity="sha256-TreZPvY/XCxQ6GXELb35sDKjUtZ5+X8ZtDSqnegNNxc=" crossorigin=anonymous></script>
<script defer src=/sw.min.6f6f90fcb8eb1c49ec389838e6b801d0de19430b8e516902f8d75c3c8bd98739.js integrity="sha256-b2+Q/LjrHEnsOJg45rgB0N4ZQwuOUWkC+NdcPIvZhzk=" crossorigin=anonymous></script>
<link rel=alternate type=application/rss+xml href=http://ivylet.github.io/docs/chapter03/CO/cpt04/index.xml title=QBook></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>QBook</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=搜索 aria-label=搜索 maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul class=book-languages><li><input type=checkbox id=languages class=toggle>
<label for=languages class="flex justify-between"><a role=button class="flex align-center"><img src=/svg/translate.svg class=book-icon alt=Languages>
Chinese</a></label><ul><li><a href=http://ivylet.github.io/en/>English</a></li></ul></li></ul><ul><li><input type=checkbox id=section-903d3e7635db560eef69c6ad03432b92 class=toggle>
<label for=section-903d3e7635db560eef69c6ad03432b92 class="flex justify-between"><a role=button>第一章|基础知识储备</a></label><ul><li><a href=/docs/chapter01/cpp-stl-argo/>STL中常用算法</a></li><li><a href=/docs/chapter01/cpp/>STL中常用算法1</a></li><li><a href=/docs/chapter01/datastru/>常用算法储备知识</a></li><li><a href=/docs/chapter01/cpp-stl-intro/>C++ STL</a></li><li><a href=/docs/chapter01/argo-datastru/>算法竞赛常用STL</a></li></ul></li><li><input type=checkbox id=section-144f7b511d4fbbff231a670ff00b5f9e class=toggle>
<label for=section-144f7b511d4fbbff231a670ff00b5f9e class="flex justify-between"><a role=button>第二章|基础算法</a></label><ul><li><input type=checkbox id=section-9db364c0dccf0502e8049e61bd8b0d86 class=toggle>
<label for=section-9db364c0dccf0502e8049e61bd8b0d86 class="flex justify-between"><a role=button>Acwing</a></label><ul><li><input type=checkbox id=section-96943a9cc0137d53acdca869bdf27124 class=toggle>
<label for=section-96943a9cc0137d53acdca869bdf27124 class="flex justify-between"><a role=button>Base</a></label><ul><li><a href=/docs/chapter02/acwing/base/base-1/>基础算法一</a></li><li><a href=/docs/chapter02/acwing/base/datestruct/>数据结构</a></li><li><a href=/docs/chapter02/acwing/base/search_and_graph/>搜索与图论</a></li><li><a href=/docs/chapter02/acwing/base/greedy/>贪心</a></li></ul></li><li><input type=checkbox id=section-88eae5c1d766baf874d32d1908707564 class=toggle>
<label for=section-88eae5c1d766baf874d32d1908707564 class="flex justify-between"><a role=button>Dp</a></label><ul><li><a href=/docs/chapter02/acwing/DP/DP/>DP</a></li><li><a href=/docs/chapter02/acwing/DP/package/>背包问题</a></li></ul></li><li><input type=checkbox id=section-a50d07f316054aeee9419b25ddf950a0 class=toggle>
<label for=section-a50d07f316054aeee9419b25ddf950a0 class="flex justify-between"><a role=button>Math</a></label><ul><li><a href=/docs/chapter02/acwing/math/others/>其他</a></li><li><a href=/docs/chapter02/acwing/math/shulun/>数论</a></li></ul></li></ul></li><li><a href=/docs/chapter02/commonSolution/>常用思想方法</a></li></ul></li><li><input type=checkbox id=section-fca257306a653a028d58c47b763ab4c5 class=toggle checked>
<label for=section-fca257306a653a028d58c47b763ab4c5 class="flex justify-between"><a role=button>第三章|计算机基础知识</a></label><ul><li><input type=checkbox id=section-c6a658a9eab81ef20c403bdfcfbb322f class=toggle>
<label for=section-c6a658a9eab81ef20c403bdfcfbb322f class="flex justify-between"><a role=button>数据结构</a></label><ul><li><a href=/docs/chapter03/DS/cpter08/>排序算法</a><ul></ul></li></ul></li><li><input type=checkbox id=section-40effe6a2504b41caa4ca2922e36dd2a class=toggle checked>
<label for=section-40effe6a2504b41caa4ca2922e36dd2a class="flex justify-between"><a role=button>计算机组成原理</a></label><ul><li><a href=/docs/chapter03/CO/cpt02/>第二章|数据的表示与运算</a><ul></ul></li><li><a href=/docs/chapter03/CO/cpt03/>第三章|存储系统</a><ul></ul></li><li><a href=/docs/chapter03/CO/cpt04/ class=active>第四章|指令系统</a><ul></ul></li><li><a href=/docs/chapter03/CO/cpt05/>第五章|中央控制器</a><ul></ul></li></ul></li><li><input type=checkbox id=section-90808d88c5fb0a7411c304bba41a80d8 class=toggle>
<label for=section-90808d88c5fb0a7411c304bba41a80d8 class="flex justify-between"><a role=button>操作系统</a></label><ul><li><span>第一章|计算机系统概述</span><ul></ul></li><li><span>第二章|进程与线程</span><ul></ul></li><li><span>第三章|内存管理</span><ul></ul></li><li><span>第四章|文佳管理</span><ul></ul></li><li><span>第五章|I/O管理</span><ul></ul></li></ul></li><li><input type=checkbox id=section-25823a2461316869125b231cfddbbdc4 class=toggle>
<label for=section-25823a2461316869125b231cfddbbdc4 class="flex justify-between"><a role=button>机器学习</a></label><ul><li><a href=/docs/chapter03/machine-learning/tools/>常用工具</a></li><li><a href=/docs/chapter03/machine-learning/LinerRegression/>线性回归</a><ul></ul></li></ul></li></ul></li><li><input type=checkbox id=section-574b1a2b668b65d846660d1f8c5a4bfb class=toggle>
<label for=section-574b1a2b668b65d846660d1f8c5a4bfb class="flex justify-between"><a role=button>记录和其他</a></label><ul><li><input type=checkbox id=section-c1536e74d6e5fb6bc2e23ae4a04a06df class=toggle>
<label for=section-c1536e74d6e5fb6bc2e23ae4a04a06df class="flex justify-between"><a role=button>暂时没名字</a></label><ul><li><a href=/docs/notes/other/00001/>无意识？！</a></li></ul></li><li><input type=checkbox id=section-a3b6ca56f01a783b7e83028f9b977c5b class=toggle>
<label for=section-a3b6ca56f01a783b7e83028f9b977c5b class="flex justify-between"><a role=button>小记</a></label><ul><li><a href=/docs/notes/thinknote/00001/>暂且第一记</a></li><li><a href=/docs/notes/thinknote/00002/>一些话</a></li><li><a href=/docs/notes/thinknote/00003/>生活</a></li><li><a href=/docs/notes/thinknote/00000/>原初号</a></li></ul></li><li><span>notes</span><ul><li><a href=/docs/notes/readingnotes/0001/>《大问题》阅读随笔</a></li><li><a href=/docs/notes/readingnotes/0002/>拉康</a></li></ul></li></ul></li></ul><ul><li><a href=https://github.com/ivylet target=_blank rel=noopener>Github</a></li><li><a href=https://leetcode.cn/ target=_blank rel=noopener>Leetcode</a></li><li><a href=https://themes.gohugo.io/hugo-book/ target=_blank rel=noopener>Hugo Themes</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label>
<strong>第四章|指令系统</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#指令系统>指令系统</a><ul><li><a href=#指令格式>指令格式</a><ul><li><a href=#零地址指令>零地址指令</a></li><li><a href=#一地址指令>一地址指令</a></li><li><a href=#二地址指令>二地址指令</a></li><li><a href=#三地址指令>三地址指令</a></li><li><a href=#四地址指令>四地址指令</a></li></ul></li><li><a href=#指令分类>指令分类</a><ul><li><a href=#按指令长度分类>按指令长度分类</a></li><li><a href=#按操作码长度分类>按操作码长度分类</a></li><li><a href=#按操作类型分类>按操作类型分类</a></li></ul></li><li><a href=#扩展操作码指令格式>扩展操作码指令格式</a></li></ul></li><li><a href=#指令的寻址方式>指令的寻址方式</a><ul><li><a href=#指令寻址和数据寻址>指令寻址和数据寻址</a><ul><li><a href=#指令寻址>指令寻址</a></li><li><a href=#数据寻址>数据寻址</a></li></ul></li><li><a href=#常见数据寻址方式>常见数据寻址方式</a><ul><li><a href=#直接寻址>直接寻址</a></li><li><a href=#间接寻址>间接寻址</a></li><li><a href=#寄存器寻址>寄存器寻址</a></li><li><a href=#寄存器间接寻址>寄存器间接寻址</a></li><li><a href=#隐含寻址>隐含寻址</a></li><li><a href=#立即寻址>立即寻址</a></li><li><a href=#基址寻址>基址寻址</a></li><li><a href=#变址寻址>变址寻址</a></li><li><a href=#相对寻址>相对寻址</a></li><li><a href=#堆栈寻址>堆栈寻址</a></li></ul></li></ul></li><li><a href=#程序的机器级代码表示>程序的机器级代码表示</a></li><li><a href=#cisc和risc的基本概念>CISC和RISC的基本概念</a></li></ul></nav></aside></header><article class=markdown><h1 id=指令系统>指令系统
<a class=anchor href=#%e6%8c%87%e4%bb%a4%e7%b3%bb%e7%bb%9f>#</a></h1><p>指令（机器指令）：是指计算机执行某种操作的命令，是计算机运行的最小功能单位。<br>一台计算机的所有指令集合构成该计算机的指令系统，也称指令集。一台计算机只能执行自己指令系统中的指令，不能执行其他系统的指令。x86架构（一般是PC机）与ARM架构（一般是手机）的指令集不同。</p><h2 id=指令格式>指令格式
<a class=anchor href=#%e6%8c%87%e4%bb%a4%e6%a0%bc%e5%bc%8f>#</a></h2><p>操作码：做什么<br>地址码（操作数）：对谁做<br>一条指令通常包括操作码字段和地址码字段两部分。<br><img src=https://cdn.staticaly.com/gh/ivylet/blog_picg-@master/img/202306161652839.png alt=image.png>
一条指令可能包括0、1、2、3、4个地址码。<br>根据地址码数量不同，可以将指令分为零地址指令，一地址指令，二地址指令&mldr;..</p><h3 id=零地址指令>零地址指令
<a class=anchor href=#%e9%9b%b6%e5%9c%b0%e5%9d%80%e6%8c%87%e4%bb%a4>#</a></h3><p><img src=https://cdn.staticaly.com/gh/ivylet/blog_picg-@master/img/202306161714778.png alt=image.png><br>只有操作码，没有操作数。<br>这种指令有两种可能：</p><ol><li>不需要操作数的指令，比如空操作指令，停机指令，关中断指令等。</li><li>在堆栈计算机中，通常将两个操作数隐含存放在栈顶和次栈顶，计算结构压回栈顶。</li></ol><h3 id=一地址指令>一地址指令
<a class=anchor href=#%e4%b8%80%e5%9c%b0%e5%9d%80%e6%8c%87%e4%bb%a4>#</a></h3><p><img src=https://cdn.staticaly.com/gh/ivylet/blog_picg-@master/img/202306161714092.png alt=image.png><br>有操作码和一个操作数。</p><ol><li>只需要单操作数，如加1、减1、取反，求补等
OP(A1)->A1，完成一条指令需要3次访存：取指->读A1->写A1
需要两个操作数，</li><li>需要两个操作数，但其中一个操作数隐含在某个寄存器（如隐含在ACC）
(ACC)OP(A1)->ACC，完成一条指令需要2次访存，取指->读A1</li></ol><h3 id=二地址指令>二地址指令
<a class=anchor href=#%e4%ba%8c%e5%9c%b0%e5%9d%80%e6%8c%87%e4%bb%a4>#</a></h3><p><img src=https://cdn.staticaly.com/gh/ivylet/blog_picg-@master/img/202306161712233.png alt=image.png><br>常用于需要两个操作数的算术运算、逻辑运算相关指令。<br>(A1)OP(A2)->A1，完成一条指令通常需要访存4次，取指->读A1->读A2->写A1</p><h3 id=三地址指令>三地址指令
<a class=anchor href=#%e4%b8%89%e5%9c%b0%e5%9d%80%e6%8c%87%e4%bb%a4>#</a></h3><p><img src=https://cdn.staticaly.com/gh/ivylet/blog_picg-@master/img/202306161712560.png alt=image.png><br>常用于需要两个操作数的算术运算、逻辑运算相关指令。<br>(A1)OP(A2)->A3，完成一条指令通常需要访存4次，取指->读A1->读A2->写A3</p><h3 id=四地址指令>四地址指令
<a class=anchor href=#%e5%9b%9b%e5%9c%b0%e5%9d%80%e6%8c%87%e4%bb%a4>#</a></h3><p><img src=https://cdn.staticaly.com/gh/ivylet/blog_picg-@master/img/202306161716149.png alt=image.png>
(A1)OP(A2)->A3，A4为下一条将要执行的地址，完成一条指令通常需要访存4次，取指->读A1->读A2->写A3<br>正常情况下：取指令后PC+1，指向下一条指令。<br>四地址指令：执行指令后，将PC值修改为A4所指地址。<br>n位地址码的直接寻址范围为2<sup>n</sup> ，若指令总长度固定不变，则地址吗数量越多，寻址能力越差。</p><h2 id=指令分类>指令分类
<a class=anchor href=#%e6%8c%87%e4%bb%a4%e5%88%86%e7%b1%bb>#</a></h2><h3 id=按指令长度分类>按指令长度分类
<a class=anchor href=#%e6%8c%89%e6%8c%87%e4%bb%a4%e9%95%bf%e5%ba%a6%e5%88%86%e7%b1%bb>#</a></h3><p>例如双字长指令在取指时需要两次访存<br>定长指令字结构： 指令系统中所有指令的长度都相等。定长操作码可以简化计算机硬件设计，提高指令译码和识别速度。<br>变长指令字结构： 指令系统中各种指令的长度不等。</p><h3 id=按操作码长度分类>按操作码长度分类
<a class=anchor href=#%e6%8c%89%e6%93%8d%e4%bd%9c%e7%a0%81%e9%95%bf%e5%ba%a6%e5%88%86%e7%b1%bb>#</a></h3><ul><li>定长操作码：
指令系统中所有指令的操作码长度都相同。
例如n位操作码，最多支持2<sup>n</sup>条指令。</li><li>可变长操作码：
指令系统中所有指令的操作码长度可变。</li></ul><h3 id=按操作类型分类>按操作类型分类
<a class=anchor href=#%e6%8c%89%e6%93%8d%e4%bd%9c%e7%b1%bb%e5%9e%8b%e5%88%86%e7%b1%bb>#</a></h3><ul><li>数据传送 （数据传送类）
LOAD 把存储器中的数据放到寄存器中
STORE 把寄存器中的数据放到存储器中</li><li>算数逻辑运算 （运算类）
算数运算：加、减、乘、除、增一、减一、求补、浮点运算、十进制运算等<br>逻辑运算：与或非异或位操作、位测试、位清除、位求反。</li><li>移位操作 （运算类）
算术移位、逻辑移位、循环移位（带进位和不带进位）</li><li>转移操作 （程序执行流的改变）
无条件转移 JMP<br>条件转移 JZ：结果为0；JZ：结果溢出；JC：结果有进位；<br>调用和返回 CALL和RETURN<br>陷阱和陷阱指令</li><li>输入输出操作 （输入输出类）
CPU寄存器与IO端口之间的数据传送（端口即IO接口中的寄存器）</li></ul><h2 id=扩展操作码指令格式>扩展操作码指令格式
<a class=anchor href=#%e6%89%a9%e5%b1%95%e6%93%8d%e4%bd%9c%e7%a0%81%e6%8c%87%e4%bb%a4%e6%a0%bc%e5%bc%8f>#</a></h2><p>为了使指令字长有限的前提下仍保持比较丰富的指令种类，可采取可变长操作码，即全部指令的操作码字段的位数不固定，且分散地放在指令字的不同位置上。
举例：<br><img src=https://cdn.staticaly.com/gh/ivylet/blog_picg-@master/img/202306161935378.png alt=image.png><br>设计扩展操作码指令格式时，必须注意：</p><ol><li>不允许短码是长码的前缀，即短操作码不能与长操作码的前面部分的代码相同（类哈夫曼编码）</li><li>各指令的操作码一定不能重复
通常情况对于使用频率较高的指令，分配较短的操作码，对使用频率较低的指令，分配较长的操作码，从而尽可能减少指令译码和分析的时间。<br>扩展操作码举例：<br><img src=https://cdn.staticaly.com/gh/ivylet/blog_picg-@master/img/202306162012979.png alt></li></ol><ul><li>对于三地址指令，前四位为操作码，后十二位为三个操作数。操作码从0000开始到1110，留1111一种提供给三地址指令扩展。共有16-1 = 15种状态。</li><li>对于二地址指令，前5-8位为操作码，后八位为两个操作数，操作码从0000-1011，留下1100、1101、1110、1111四种提供给一地址指令扩展，共有1* 16 - 4= 12种。</li><li>对于一地址指令，二地址指令留下的前7-8位和前9-12位为操作码，最后4位为操作数，操作码从00 0000-11 1101，留下11 1110和11 1111两种提供给零地址指令扩展，共有4 * 16 - 2= 62种。</li><li>对于零地址指令，一地址指令留下的第12位和最后四位为操作码，无操作数，操作码从0 0000-1 1111，共有2 * 16 = 32种。<br>设地址长度为m，上一层留出m中状态，下一层就可以扩展出m * 2<sup>n</sup>种状态。实际情况根据不同地址指令种类多少进行扩展。</li></ul><h1 id=指令的寻址方式>指令的寻址方式
<a class=anchor href=#%e6%8c%87%e4%bb%a4%e7%9a%84%e5%af%bb%e5%9d%80%e6%96%b9%e5%bc%8f>#</a></h1><h2 id=指令寻址和数据寻址>指令寻址和数据寻址
<a class=anchor href=#%e6%8c%87%e4%bb%a4%e5%af%bb%e5%9d%80%e5%92%8c%e6%95%b0%e6%8d%ae%e5%af%bb%e5%9d%80>#</a></h2><p>每一条指令的执行部分分为“取指令”、”执行指令“两部分，在取完指令后，PC加“1”（一个指令字长）。</p><h3 id=指令寻址>指令寻址
<a class=anchor href=#%e6%8c%87%e4%bb%a4%e5%af%bb%e5%9d%80>#</a></h3><h4 id=顺序寻址>顺序寻址
<a class=anchor href=#%e9%a1%ba%e5%ba%8f%e5%af%bb%e5%9d%80>#</a></h4><p>对于定长指令字结构，通过程序计数器PC加1（1个指令字长），自动形成下一条指令的地址。 如果指令字长与存储字长都为2B，主存按字编址，则每次PC加1，如果指令字长与存储字长都为2B，主存按字节编址，则每条指令占两个地址，则每次PC加2。<br>对于变长指令无法预先判断，所以CPU先读入指令，根据操作码判断这条指令的总字节数n，如果主存按字节编址，那么PC的值加n。</p><h4 id=跳跃寻址>跳跃寻址
<a class=anchor href=#%e8%b7%b3%e8%b7%83%e5%af%bb%e5%9d%80>#</a></h4><p>通过转移指令给出，如果是无条件转移JMP则PC值改为对应数。</p><h3 id=数据寻址>数据寻址
<a class=anchor href=#%e6%95%b0%e6%8d%ae%e5%af%bb%e5%9d%80>#</a></h3><p>确定本条指令的地址码的真实地址。 即指令的地址码中的地址并不一定是真正的地址，是一种真实地址的表现形式。 数据寻址方式很多，但是如何标识让CPU用哪种寻址方式进行解读呢？指令中每个形式地址之前都会有几位二进制代码表示寻址方式。</p><h2 id=常见数据寻址方式>常见数据寻址方式
<a class=anchor href=#%e5%b8%b8%e8%a7%81%e6%95%b0%e6%8d%ae%e5%af%bb%e5%9d%80%e6%96%b9%e5%bc%8f>#</a></h2><h3 id=直接寻址>直接寻址
<a class=anchor href=#%e7%9b%b4%e6%8e%a5%e5%af%bb%e5%9d%80>#</a></h3><p>指令字中的形式地址A就是操作数的真实地址EA，即EA = A。例如进行加法运算，可以直接将A传给MAR。<br><img src=https://cdn.staticaly.com/gh/ivylet/blog_picg-@master/img/202306162112728.png alt=image.png></p><ul><li>优点
简单，指令执行阶段仅访问一次主存，不需要专门计算操作数的地址。</li><li>缺点
A的位数决定了该指令操作数的寻址范围，操作数的地址不易修改。
一条指令的执行，取指令访存一次，执行指令访存一次，暂不考虑存结果，共访存2次</li></ul><h3 id=间接寻址>间接寻址
<a class=anchor href=#%e9%97%b4%e6%8e%a5%e5%af%bb%e5%9d%80>#</a></h3><p>指令中给出的地址码是存放有效地址的主存单元地址，即通过地址码找到真正的地址，通过真正的地址再找到有效地址EA。也可以有多重间接寻址。<br><img src=https://cdn.staticaly.com/gh/ivylet/blog_picg-@master/img/202306162111362.png alt=image.png></p><ul><li>优点
可扩大寻址范围（有效地址EA的位数大于形式地址A的位数），便于编制程序（用于间接寻址可以方便地完成子程序返回）。</li><li>缺点
指令执行的过程中要多次访存（一次间接寻址需要两次访存，多次寻址需根据存储字的最高位确定几次访存）。<br>一条指令的执行：取指令访存一次，执行指令访存两次，暂不考虑存结果，共访存3次。若为多重间接寻址，则执行指令访存多次。</li></ul><h3 id=寄存器寻址>寄存器寻址
<a class=anchor href=#%e5%af%84%e5%ad%98%e5%99%a8%e5%af%bb%e5%9d%80>#</a></h3><p>在指令字中直接给出操作数所在的寄存器编号，即EA=R，其操作数在由R所指的寄存器内。<br><img src=https://cdn.staticaly.com/gh/ivylet/blog_picg-@master/img/202306162118257.png alt=image.png></p><ul><li>优点
在执行阶段不访问主存，只访问寄存器。指令字短且执行速度块，支持向量/矩阵运算。</li><li>缺点
寄存器价格昂贵，计算机中寄存器个数有限。
一条指令的执行，取指令访存一次，执行指令访存零次，暂不考虑存结果，共访存1次。</li></ul><h3 id=寄存器间接寻址>寄存器间接寻址
<a class=anchor href=#%e5%af%84%e5%ad%98%e5%99%a8%e9%97%b4%e6%8e%a5%e5%af%bb%e5%9d%80>#</a></h3><p>通过找寄存器编号，寄存器中的内容就是操作数的地址。 就是寄存器寻址和间接寻址的叠加态！ 比一般间接寻址要快，取指令访存一次，执行指令访存一次（因为操作数在主存中），共访存2次。</p><h3 id=隐含寻址>隐含寻址
<a class=anchor href=#%e9%9a%90%e5%90%ab%e5%af%bb%e5%9d%80>#</a></h3><p>不是明显地给出操作数的地址，而是在指令中隐含着操作数的地址。
<img src=https://cdn.staticaly.com/gh/ivylet/blog_picg-@master/img/202306162126001.png alt=image.png></p><ul><li>优点
有利于缩短指令字长</li><li>缺点
需增加存储操作数或隐含地址的硬件。</li></ul><h3 id=立即寻址>立即寻址
<a class=anchor href=#%e7%ab%8b%e5%8d%b3%e5%af%bb%e5%9d%80>#</a></h3><p>形式地址A就是操作数本身，又称为立即数，一般采取补码形式，#表示立即寻址特征。</p><ul><li>优点
指令执行阶段不访问主存，指令执行时间最短。</li><li>缺点A的位数限制了立即数的范围，如果A的位数为n，且立即数采用补码时，可表示的数据范围为-2<sup>n-1</sup>~2<sup>n-1</sup> - 1。
一条指令的执行，取指令访存一次，执行指令访存零次，暂不考虑存结果，共访存1次。</li></ul><h3 id=基址寻址>基址寻址
<a class=anchor href=#%e5%9f%ba%e5%9d%80%e5%af%bb%e5%9d%80>#</a></h3><p>以程序的起始存放地址作为“起点”。<br>将CPU中基址寄存器（BR）的内容加上指令格式中的形式地址A，从而形成操作数的有效地址，即EA = （BR）+ A；
<img src=https://cdn.staticaly.com/gh/ivylet/blog_picg-@master/img/202306162140502.png alt><br>或在指令中指出要使用哪个通用寄存器作为基址寄存器使用。<br><img src=https://cdn.staticaly.com/gh/ivylet/blog_picg-@master/img/202306162142584.png alt=image.png>
指寄存器编号的位数需要根据寄存器总数来确定，如果有8个通用寄存器，就需要3个bit指明寄存器。<br>例如执行一个四则运算程序，可以将数据和指令放到连续的地址上，那么当要使用某变量时，根据程序开始的地址，这段地址存到基址寄存器中，然后通过基址寻址快速的找到变量的地址，不管这段程序地址在地址空间的哪一个地方。便于程序的“浮动”，方便实现多道程序并发运行。因为多道相同的程序中指令与数据的相对位置都是一样的，只需要修改程序起始位置即可。<br>基址寄存器是面向操作系统的，其内容由操作系统或管理程序确定，在程序执行过程中，基址寄存器的内容不变（作为基地址），形式地址可变（偏移量）。一般BR或选择的某用于基址的通用寄存器中的内容。程序员无法修改。</p><ul><li>优点
可以扩大寻址范围（基址寄存器的位数大于形式地址A的位数），用不不必考虑自己的程序存与主存的哪一空间区域，故有利于多道程序设计，以及可以编写浮动程序（整个程序都在内存中浮动）。</li></ul><h3 id=变址寻址>变址寻址
<a class=anchor href=#%e5%8f%98%e5%9d%80%e5%af%bb%e5%9d%80>#</a></h3><p>以程序员自己决定的位置为“起点”。<br>变址寄存器和基址寻址类似。 有效地址EA等于指令字中形式地址A与变址寄存器IX的内容相加之和，即EA = （IX） + A，其中IX可为变址寄存器（专用），也可以使用通用寄存器作为变址寄存器。<br><img src=https://cdn.staticaly.com/gh/ivylet/blog_picg-@master/img/202306162200727.png alt=image.png></p><p>变址寄存器是面向用户的，在程序执行过程中，变址寄存器的内容可由用户改变，（IX作为偏移量），形式地址A不变，（作为基准值），这点和基址寄存器不一样。<br>例如，要进行对一个数组的求和，可以将指令中的A作为数组开头地址作为基准值，起始时IX的值为0，每次加后将IX中的值加1，直至求和完毕。变址寻址特别适合编址循环程序，偏移量（IX）的位数足以表示整个存储空间。</p><h3 id=相对寻址>相对寻址
<a class=anchor href=#%e7%9b%b8%e5%af%b9%e5%af%bb%e5%9d%80>#</a></h3><p>以程序计数器PC所指地址为“起点”。<br>把程序计数器PC的内容加上指令格式中的形式地址A而形成操作数的有效地址，即EA = (PC) + A，其中A是相对与PC所指地址的位移量，可正可负，<strong>补码</strong>表示。<br><img src=https://cdn.staticaly.com/gh/ivylet/blog_picg-@master/img/202306181457121.png alt=image.png></p><p>主要是面对汇编程序员，当需要调整代码在内存中的位置，若使用直接寻址，需要修改条件跳转的地址，使用基址寻址需要修改基准值，如果使用相对寻址，就无需改变。PC指向当前地址后自动根据A来进行寻址。</p><ul><li>优点
方便代码在程序内存浮动时，不用更改跳转指令的地址码。操作数的地址不是固定的，它随着PC值的变化而变化，并且与指令地址之间总是相差一个固定值，因此便于程序浮动，一段代码在程序内部的浮动。相对寻址广泛应用于转移指令。<br>一般基址寻址用于整个程序在内存中浮动，而相对寻址一般是程序内一段程序在该程序内部的浮动。变址寻址一般应用于程序内部的for循环来查找数组的下一位。</li></ul><h3 id=堆栈寻址>堆栈寻址
<a class=anchor href=#%e5%a0%86%e6%a0%88%e5%af%bb%e5%9d%80>#</a></h3><p>操作数存放在堆栈中，隐含使用堆栈指针（SP）作为操作数地址。堆栈是存储器（或专用寄存器组）中一块特定的按“后进先出（LIFO）”</p><h1 id=程序的机器级代码表示>程序的机器级代码表示
<a class=anchor href=#%e7%a8%8b%e5%ba%8f%e7%9a%84%e6%9c%ba%e5%99%a8%e7%ba%a7%e4%bb%a3%e7%a0%81%e8%a1%a8%e7%a4%ba>#</a></h1><h1 id=cisc和risc的基本概念>CISC和RISC的基本概念
<a class=anchor href=#cisc%e5%92%8crisc%e7%9a%84%e5%9f%ba%e6%9c%ac%e6%a6%82%e5%bf%b5>#</a></h1></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/ivylet/book-shelf/commit/f5e95a7f908fe05690e362f3a6998be43c14196f title='最后修改者 saytaytay | August 6, 2024' target=_blank rel=noopener><img src=/svg/calendar.svg class=book-icon alt=Calendar>
<span>August 6, 2024</span></a></div><div><a class="flex align-center" href=https://github.com/ivylet/book-shelf/edit/main/exampleSite/content/docs/chapter03/CO/cpt04/_index.md target=_blank rel=noopener><img src=/svg/edit.svg class=book-icon alt=Edit>
<span>编辑本页</span></a></div><footer id=footer><div class=container>&copy; 2024, By ivylet</a>。</div></footer></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#指令系统>指令系统</a><ul><li><a href=#指令格式>指令格式</a><ul><li><a href=#零地址指令>零地址指令</a></li><li><a href=#一地址指令>一地址指令</a></li><li><a href=#二地址指令>二地址指令</a></li><li><a href=#三地址指令>三地址指令</a></li><li><a href=#四地址指令>四地址指令</a></li></ul></li><li><a href=#指令分类>指令分类</a><ul><li><a href=#按指令长度分类>按指令长度分类</a></li><li><a href=#按操作码长度分类>按操作码长度分类</a></li><li><a href=#按操作类型分类>按操作类型分类</a></li></ul></li><li><a href=#扩展操作码指令格式>扩展操作码指令格式</a></li></ul></li><li><a href=#指令的寻址方式>指令的寻址方式</a><ul><li><a href=#指令寻址和数据寻址>指令寻址和数据寻址</a><ul><li><a href=#指令寻址>指令寻址</a></li><li><a href=#数据寻址>数据寻址</a></li></ul></li><li><a href=#常见数据寻址方式>常见数据寻址方式</a><ul><li><a href=#直接寻址>直接寻址</a></li><li><a href=#间接寻址>间接寻址</a></li><li><a href=#寄存器寻址>寄存器寻址</a></li><li><a href=#寄存器间接寻址>寄存器间接寻址</a></li><li><a href=#隐含寻址>隐含寻址</a></li><li><a href=#立即寻址>立即寻址</a></li><li><a href=#基址寻址>基址寻址</a></li><li><a href=#变址寻址>变址寻址</a></li><li><a href=#相对寻址>相对寻址</a></li><li><a href=#堆栈寻址>堆栈寻址</a></li></ul></li></ul></li><li><a href=#程序的机器级代码表示>程序的机器级代码表示</a></li><li><a href=#cisc和risc的基本概念>CISC和RISC的基本概念</a></li></ul></nav></div></aside></main></body></html>