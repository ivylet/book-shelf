<!doctype html><html lang=zh dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="存储器概述 # 存储器的层次结构 # 寄存器 Cache(高速缓冲存储器) 主存(内存) 磁盘(辅存) 磁带、光盘。
主存-辅存：实现了虚拟存储系统，结果主存容量不够的问题。辅存与主存内容交换一般是由硬件和操作系统完成，涉及到操作系统中的页面置换算法。
Cache-主存：解决了主存与CPU速度不匹配的问题。是由硬件自动完成的。计算机组成原理主要关注这部分。
辅存的数据必须调入主存后才能被CPU访问。
频繁被访问的数据可以复制一份到Cache中，更方便CPU读取。
CPU进行一些加减运算时，操作数就存在寄存器，寄存器访问更快，但是其价格贵，数量更少。 存储器的分类 # 按层次分类 # 高速缓存
主存储器
辅助存储器
按存储介质分类 # 半导体存储器：主存、Cache
磁表面存储器：磁盘、磁带
光存储器：光盘
按存取方式分类 # 随机存取存储器（Random Acess Memory）： 读写任何一个存储单元所需时间都一样，与物理位置无关。 顺序存取存储器（Sequential Acess Memory）： 读写每一个存储单元所需的时间取决于存储单元所在的物理位置。 直接存取存储器（Direct Acess Memory）： 既有随机读取的特性，又有顺序读取的特性，先随机选取目标数据扇区，再顺序方式读取数据。
顺序存取和直接读取都是串行访问存储器，读写某个存储单元所需时间与存储器单元的物理位置有关。 相联存储器（Associative Memory）： 即可以按内容访问的存储器，也可以按照内容检索到存储位置进行读写，“快表”就是一种。 按信息的更改性分类 # 读写存取器：可读可写（磁盘，内存，Cache等） 只读存储器（Read Only Memory）：只能读，不能写。（BIOS写到ROM上，实体音乐专辑存储到CD-ROM上）
按信息的可保存性分类 # 易失性存储器：断电后存储信息消失，（Cache、主存） 非易失性存储器：断电后存储信息依旧保存，（磁盘、光盘） 破坏性读出：信息读出后，原存储信息被破坏。（DRAM芯片，读出数据后要进行重写） 非破坏性读出：信息读出后，原存储信息不被破坏。（SRAM、磁盘、光盘）
存储器的性能指标 # 存储容量：存储字数 * 字长（如1M*8位) MDR位数反映存储字长，MAR位数反映存储字数。
单位成本：每位(bit)价格 = 总成本 / 总容量
存储速度：数据传输率=数据的宽度/存储周期。 数据宽度位存储字长。"><meta name=theme-color content="#FFFFFF"><meta name=color-scheme content="light dark"><meta property="og:title" content="第三章|存储系统"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:url" content="http://ivylet.github.io/docs/chapter03/CO/cpt03/"><title>第三章|存储系统 | QBook</title><link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png type=image/x-icon><link rel=stylesheet href=/book.min.4b35fed0bea034bbc19c89c71e14b73fb9c68cfcc586b9382adfb9b7b103ba06.css integrity="sha256-SzX+0L6gNLvBnInHHhS3P7nGjPzFhrk4Kt+5t7EDugY=" crossorigin=anonymous><script defer src=/flexsearch.min.js></script>
<script defer src=/zh.search.min.4eb7993ef63f5c2c50e865c42dbdf9b032a352d679f97f19b434aa9de80d3717.js integrity="sha256-TreZPvY/XCxQ6GXELb35sDKjUtZ5+X8ZtDSqnegNNxc=" crossorigin=anonymous></script>
<script defer src=/sw.min.6f6f90fcb8eb1c49ec389838e6b801d0de19430b8e516902f8d75c3c8bd98739.js integrity="sha256-b2+Q/LjrHEnsOJg45rgB0N4ZQwuOUWkC+NdcPIvZhzk=" crossorigin=anonymous></script>
<link rel=alternate type=application/rss+xml href=http://ivylet.github.io/docs/chapter03/CO/cpt03/index.xml title=QBook></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>QBook</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=搜索 aria-label=搜索 maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul class=book-languages><li><input type=checkbox id=languages class=toggle>
<label for=languages class="flex justify-between"><a role=button class="flex align-center"><img src=/svg/translate.svg class=book-icon alt=Languages>
Chinese</a></label><ul><li><a href=http://ivylet.github.io/en/>English</a></li></ul></li></ul><ul><li><input type=checkbox id=section-903d3e7635db560eef69c6ad03432b92 class=toggle>
<label for=section-903d3e7635db560eef69c6ad03432b92 class="flex justify-between"><a role=button>第一章|基础知识储备</a></label><ul><li><a href=/docs/chapter01/cpp-stl-argo/>STL中常用算法</a></li><li><a href=/docs/chapter01/cpp/>STL中常用算法1</a></li><li><a href=/docs/chapter01/datastru/>常用算法储备知识</a></li><li><a href=/docs/chapter01/cpp-stl-intro/>C++ STL</a></li><li><a href=/docs/chapter01/argo-datastru/>算法竞赛常用STL</a></li></ul></li><li><input type=checkbox id=section-144f7b511d4fbbff231a670ff00b5f9e class=toggle>
<label for=section-144f7b511d4fbbff231a670ff00b5f9e class="flex justify-between"><a role=button>第二章|基础算法</a></label><ul><li><input type=checkbox id=section-9db364c0dccf0502e8049e61bd8b0d86 class=toggle>
<label for=section-9db364c0dccf0502e8049e61bd8b0d86 class="flex justify-between"><a role=button>Acwing</a></label><ul><li><input type=checkbox id=section-96943a9cc0137d53acdca869bdf27124 class=toggle>
<label for=section-96943a9cc0137d53acdca869bdf27124 class="flex justify-between"><a role=button>Base</a></label><ul><li><a href=/docs/chapter02/acwing/base/base-1/>基础算法一</a></li><li><a href=/docs/chapter02/acwing/base/datestruct/>数据结构</a></li><li><a href=/docs/chapter02/acwing/base/search_and_graph/>搜索与图论</a></li><li><a href=/docs/chapter02/acwing/base/greedy/>贪心</a></li></ul></li><li><input type=checkbox id=section-88eae5c1d766baf874d32d1908707564 class=toggle>
<label for=section-88eae5c1d766baf874d32d1908707564 class="flex justify-between"><a role=button>Dp</a></label><ul><li><a href=/docs/chapter02/acwing/DP/DP/>DP</a></li><li><a href=/docs/chapter02/acwing/DP/package/>背包问题</a></li></ul></li><li><input type=checkbox id=section-a50d07f316054aeee9419b25ddf950a0 class=toggle>
<label for=section-a50d07f316054aeee9419b25ddf950a0 class="flex justify-between"><a role=button>Math</a></label><ul><li><a href=/docs/chapter02/acwing/math/others/>其他</a></li><li><a href=/docs/chapter02/acwing/math/shulun/>数论</a></li></ul></li></ul></li><li><a href=/docs/chapter02/commonSolution/>常用思想方法</a></li></ul></li><li><input type=checkbox id=section-fca257306a653a028d58c47b763ab4c5 class=toggle checked>
<label for=section-fca257306a653a028d58c47b763ab4c5 class="flex justify-between"><a role=button>第三章|计算机基础知识</a></label><ul><li><input type=checkbox id=section-c6a658a9eab81ef20c403bdfcfbb322f class=toggle>
<label for=section-c6a658a9eab81ef20c403bdfcfbb322f class="flex justify-between"><a role=button>数据结构</a></label><ul><li><a href=/docs/chapter03/DS/cpter08/>排序算法</a><ul></ul></li></ul></li><li><input type=checkbox id=section-40effe6a2504b41caa4ca2922e36dd2a class=toggle checked>
<label for=section-40effe6a2504b41caa4ca2922e36dd2a class="flex justify-between"><a role=button>计算机组成原理</a></label><ul><li><a href=/docs/chapter03/CO/cpt02/>第二章|数据的表示与运算</a><ul></ul></li><li><a href=/docs/chapter03/CO/cpt03/ class=active>第三章|存储系统</a><ul></ul></li><li><a href=/docs/chapter03/CO/cpt04/>第四章|指令系统</a><ul></ul></li><li><a href=/docs/chapter03/CO/cpt05/>第五章|中央控制器</a><ul></ul></li></ul></li><li><input type=checkbox id=section-90808d88c5fb0a7411c304bba41a80d8 class=toggle>
<label for=section-90808d88c5fb0a7411c304bba41a80d8 class="flex justify-between"><a role=button>操作系统</a></label><ul><li><span>第一章|计算机系统概述</span><ul></ul></li><li><span>第二章|进程与线程</span><ul></ul></li><li><span>第三章|内存管理</span><ul></ul></li><li><span>第四章|文佳管理</span><ul></ul></li><li><span>第五章|I/O管理</span><ul></ul></li></ul></li><li><input type=checkbox id=section-25823a2461316869125b231cfddbbdc4 class=toggle>
<label for=section-25823a2461316869125b231cfddbbdc4 class="flex justify-between"><a role=button>机器学习</a></label><ul><li><a href=/docs/chapter03/machine-learning/tools/>常用工具</a></li><li><a href=/docs/chapter03/machine-learning/LinerRegression/>线性回归</a><ul></ul></li></ul></li></ul></li><li><input type=checkbox id=section-574b1a2b668b65d846660d1f8c5a4bfb class=toggle>
<label for=section-574b1a2b668b65d846660d1f8c5a4bfb class="flex justify-between"><a role=button>记录和其他</a></label><ul><li><input type=checkbox id=section-c1536e74d6e5fb6bc2e23ae4a04a06df class=toggle>
<label for=section-c1536e74d6e5fb6bc2e23ae4a04a06df class="flex justify-between"><a role=button>暂时没名字</a></label><ul><li><a href=/docs/notes/other/00001/>无意识？！</a></li></ul></li><li><input type=checkbox id=section-a3b6ca56f01a783b7e83028f9b977c5b class=toggle>
<label for=section-a3b6ca56f01a783b7e83028f9b977c5b class="flex justify-between"><a role=button>小记</a></label><ul><li><a href=/docs/notes/thinknote/00001/>暂且第一记</a></li><li><a href=/docs/notes/thinknote/00002/>一些话</a></li><li><a href=/docs/notes/thinknote/00003/>生活</a></li><li><a href=/docs/notes/thinknote/00000/>原初号</a></li></ul></li><li><span>notes</span><ul><li><a href=/docs/notes/readingnotes/0001/>《大问题》阅读随笔</a></li><li><a href=/docs/notes/readingnotes/0002/>拉康</a></li></ul></li></ul></li></ul><ul><li><a href=https://github.com/ivylet target=_blank rel=noopener>Github</a></li><li><a href=https://leetcode.cn/ target=_blank rel=noopener>Leetcode</a></li><li><a href=https://themes.gohugo.io/hugo-book/ target=_blank rel=noopener>Hugo Themes</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label>
<strong>第三章|存储系统</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#存储器概述>存储器概述</a><ul><li><a href=#存储器的层次结构>存储器的层次结构</a></li><li><a href=#存储器的分类>存储器的分类</a><ul><li></li><li><a href=#存储器的性能指标>存储器的性能指标</a></li></ul></li></ul></li><li><a href=#主存储器>主存储器</a><ul><li><a href=#主存储器的基本组成>主存储器的基本组成</a><ul><li><a href=#基本半导体元件>基本半导体元件</a></li><li><a href=#存储芯片的结构>存储芯片的结构</a></li><li><a href=#寻址>寻址</a></li></ul></li><li><a href=#sram与dram>SRAM与DRAM</a><ul><li><a href=#存储元件不同而导致的特性差异>存储元件不同而导致的特性差异</a></li><li><a href=#dram的刷新>DRAM的刷新</a></li><li><a href=#dram的地址线复用技术>DRAM的地址线复用技术</a></li></ul></li><li><a href=#只读存储器rom>只读存储器ROM</a><ul><li><a href=#常见rom>常见ROM</a></li><li><a href=#计算机内重要的rom>计算机内重要的ROM</a></li></ul></li><li><a href=#双端口ram和多模块存储器>双端口RAM和多模块存储器</a><ul><li></li><li><a href=#双端口ram大纲已删>双端口RAM（大纲已删）</a></li><li><a href=#多模块存储器>多模块存储器</a></li></ul></li></ul></li><li><a href=#主存储器与cpu的连接>主存储器与CPU的连接</a><ul><li><a href=#单块存储芯片与cpu连接>单块存储芯片与CPU连接</a><ul><li></li></ul></li><li><a href=#多块存储芯片与cpu连接>多块存储芯片与CPU连接</a><ul><li></li></ul></li><li><a href=#关于译码器知识补充>关于译码器知识补充</a></li></ul></li><li><a href=#外部存储器>外部存储器</a><ul><li><a href=#磁盘存储器>磁盘存储器</a><ul><li><a href=#磁盘设备的组成>磁盘设备的组成</a></li><li><a href=#磁盘的性能指标>磁盘的性能指标</a></li><li><a href=#磁盘地址>磁盘地址</a></li><li><a href=#磁盘的工作过程>磁盘的工作过程</a></li><li><a href=#磁盘阵列raid>磁盘阵列（RAID）</a></li></ul></li><li><a href=#固态硬盘ssd>固态硬盘SSD</a><ul><li></li></ul></li></ul></li><li><a href=#高速缓冲器cache>高速缓冲器（Cache）</a><ul><li><a href=#局部性原理>局部性原理</a></li><li><a href=#cache的基本工作原理>Cache的基本工作原理</a><ul><li><a href=#cache中的有效位>Cache中的有效位</a></li><li><a href=#cpu找cache中的访问过程>CPU找Cache中的访问过程</a></li><li><a href=#平均访问时间>平均访问时间</a></li><li><a href=#几个问题>几个问题</a></li></ul></li><li><a href=#cache行与主存块之间的映射方式>Cache行与主存块之间的映射方式</a><ul><li><a href=#全相联映射随意映射>全相联映射（随意映射）</a></li><li><a href=#直接映射>直接映射</a></li><li><a href=#组相联映射>组相联映射</a></li></ul></li><li><a href=#cache中主存块的替换算法>Cache中主存块的替换算法</a><ul><li><a href=#随机替换算法rand>随机替换算法RAND</a></li><li><a href=#先进先出算法fifo>先进先出算法FIFO</a></li><li><a href=#最近最少用算法lru>最近最少用算法LRU</a></li><li><a href=#最不常用算法lfu>最不常用算法LFU</a></li></ul></li><li><a href=#cache的一致性问题>Cache的一致性问题</a><ul><li><a href=#写命中>写命中</a></li><li><a href=#写未命中>写未命中</a></li><li><a href=#多级cache>多级Cache</a></li></ul></li></ul></li><li><a href=#虚拟存储器>虚拟存储器</a><ul><li><a href=#虚拟存储器的基本概念>虚拟存储器的基本概念</a></li><li><a href=#页式虚拟存储器>页式虚拟存储器</a><ul><li></li></ul></li><li><a href=#段式虚拟存储器>段式虚拟存储器</a></li><li><a href=#段页式虚拟存储器>段页式虚拟存储器</a></li></ul></li></ul></nav></aside></header><article class=markdown><h1 id=存储器概述>存储器概述
<a class=anchor href=#%e5%ad%98%e5%82%a8%e5%99%a8%e6%a6%82%e8%bf%b0>#</a></h1><h2 id=存储器的层次结构>存储器的层次结构
<a class=anchor href=#%e5%ad%98%e5%82%a8%e5%99%a8%e7%9a%84%e5%b1%82%e6%ac%a1%e7%bb%93%e6%9e%84>#</a></h2><p>寄存器 Cache(高速缓冲存储器) 主存(内存) 磁盘(辅存) 磁带、光盘。</p><p><img src=https://cdn.staticaly.com/gh/ivylet/blog_picg-@master/img/202306121558197.png alt=image.png></p><p>主存-辅存：实现了虚拟存储系统，结果主存容量不够的问题。辅存与主存内容交换一般是由硬件和操作系统完成，涉及到操作系统中的页面置换算法。<br>Cache-主存：解决了主存与CPU速度不匹配的问题。是由硬件自动完成的。计算机组成原理主要关注这部分。<br>辅存的数据必须调入主存后才能被CPU访问。<br>频繁被访问的数据可以复制一份到Cache中，更方便CPU读取。<br>CPU进行一些加减运算时，操作数就存在寄存器，寄存器访问更快，但是其价格贵，数量更少。<br><img src=https://cdn.staticaly.com/gh/ivylet/blog_picg-@master/img/202306121558271.png alt=image.png></p><h2 id=存储器的分类>存储器的分类
<a class=anchor href=#%e5%ad%98%e5%82%a8%e5%99%a8%e7%9a%84%e5%88%86%e7%b1%bb>#</a></h2><h4 id=按层次分类>按层次分类
<a class=anchor href=#%e6%8c%89%e5%b1%82%e6%ac%a1%e5%88%86%e7%b1%bb>#</a></h4><p>高速缓存<br>主存储器<br>辅助存储器<br><img src=https://cdn.staticaly.com/gh/ivylet/blog_picg-@master/img/202306121607679.png alt=image.png></p><h4 id=按存储介质分类>按存储介质分类
<a class=anchor href=#%e6%8c%89%e5%ad%98%e5%82%a8%e4%bb%8b%e8%b4%a8%e5%88%86%e7%b1%bb>#</a></h4><p>半导体存储器：主存、Cache<br>磁表面存储器：磁盘、磁带<br>光存储器：光盘</p><h4 id=按存取方式分类>按存取方式分类
<a class=anchor href=#%e6%8c%89%e5%ad%98%e5%8f%96%e6%96%b9%e5%bc%8f%e5%88%86%e7%b1%bb>#</a></h4><ul><li>随机存取存储器（Random Acess Memory）：
读写任何一个存储单元所需时间都一样，与物理位置无关。</li><li>顺序存取存储器（Sequential Acess Memory）：
读写每一个存储单元所需的时间取决于存储单元所在的物理位置。</li><li>直接存取存储器（Direct Acess Memory）：
既有随机读取的特性，又有顺序读取的特性，先随机选取目标数据扇区，再顺序方式读取数据。<br>顺序存取和直接读取都是串行访问存储器，读写某个存储单元所需时间与存储器单元的物理位置有关。</li><li>相联存储器（Associative Memory）：
即可以按内容访问的存储器，也可以按照内容检索到存储位置进行读写，“快表”就是一种。</li></ul><h4 id=按信息的更改性分类>按信息的更改性分类
<a class=anchor href=#%e6%8c%89%e4%bf%a1%e6%81%af%e7%9a%84%e6%9b%b4%e6%94%b9%e6%80%a7%e5%88%86%e7%b1%bb>#</a></h4><p>读写存取器：可读可写（磁盘，内存，Cache等）<br>只读存储器（Read Only Memory）：只能读，不能写。（BIOS写到ROM上，实体音乐专辑存储到CD-ROM上）</p><h4 id=按信息的可保存性分类>按信息的可保存性分类
<a class=anchor href=#%e6%8c%89%e4%bf%a1%e6%81%af%e7%9a%84%e5%8f%af%e4%bf%9d%e5%ad%98%e6%80%a7%e5%88%86%e7%b1%bb>#</a></h4><p>易失性存储器：断电后存储信息消失，（Cache、主存）<br>非易失性存储器：断电后存储信息依旧保存，（磁盘、光盘）<br>破坏性读出：信息读出后，原存储信息被破坏。（DRAM芯片，读出数据后要进行重写）<br>非破坏性读出：信息读出后，原存储信息不被破坏。（SRAM、磁盘、光盘）</p><h3 id=存储器的性能指标>存储器的性能指标
<a class=anchor href=#%e5%ad%98%e5%82%a8%e5%99%a8%e7%9a%84%e6%80%a7%e8%83%bd%e6%8c%87%e6%a0%87>#</a></h3><p>存储容量：存储字数 * 字长（如1M*8位)<br>MDR位数反映存储字长，MAR位数反映存储字数。<br>单位成本：每位(bit)价格 = 总成本 / 总容量<br>存储速度：数据传输率=数据的宽度/存储周期。<br>数据宽度位存储字长。</p><p><img src=https://cdn.staticaly.com/gh/ivylet/blog_picg-@master/img/202306121635855.png alt=image.png></p><p>存储周期包括存取时间和恢复时间。<br>存取时间是从一次启动存储器操作到完成该操作所经历的时间，分为读出时间和写入时间。<br>存储周期也被称为读写周期或访问周期。指存储器进行一次完整的读写操作所需的全部时间，即连续两次独立地访问存储器操作之间所需的最小时间间隔。</p><p>主存带宽又称为数据传输率。表示每秒从主存进出信息的最大数量。单位为字、字节Byte、位bit 每秒。</p><h1 id=主存储器>主存储器
<a class=anchor href=#%e4%b8%bb%e5%ad%98%e5%82%a8%e5%99%a8>#</a></h1><h2 id=主存储器的基本组成>主存储器的基本组成
<a class=anchor href=#%e4%b8%bb%e5%ad%98%e5%82%a8%e5%99%a8%e7%9a%84%e5%9f%ba%e6%9c%ac%e7%bb%84%e6%88%90>#</a></h2><h3 id=基本半导体元件>基本半导体元件
<a class=anchor href=#%e5%9f%ba%e6%9c%ac%e5%8d%8a%e5%af%bc%e4%bd%93%e5%85%83%e4%bb%b6>#</a></h3><p>MOS管：施加的电压达到某个阈值，MOS管就可以连通。<br><img src=https://cdn.staticaly.com/gh/ivylet/blog_picg-@master/img/202306121641169.png alt=image.png>
MOS管接通后，电容与外部导线连接。<br>电容如果存储的电荷在放电后电荷流出，外部导线监测到高电平即信号1，若电容不存储电荷，则外部导线监测到低电平即信号0。</p><h3 id=存储芯片的结构>存储芯片的结构
<a class=anchor href=#%e5%ad%98%e5%82%a8%e8%8a%af%e7%89%87%e7%9a%84%e7%bb%93%e6%9e%84>#</a></h3><p><img src=https://cdn.staticaly.com/gh/ivylet/blog_picg-@master/img/202306121645513.png alt=image.png>
存储字长与每个存储体设计有关。<br>与CPU相连的地址总线连通MAR，然后通过译码器连接存储的单元的字选线来选择。字选线<br>与CPU与相连的数据总线宽度未存储字长，即图中绿线。位选线。<br>存储体总容量为 存储单元个数 * 存储字长。<br>控制电路<br><img src=https://cdn.staticaly.com/gh/ivylet/blog_picg-@master/img/202306121655339.png alt=image.png></p><p>片选线：一个内存条可能包含多个存储芯片，用片选线来判断选择的存储芯片编号。<br>读写控制线：可能为两根，一根控制写，一根控制读，或只用一根。向外暴露的引脚个数。<br><img src=https://cdn.staticaly.com/gh/ivylet/blog_picg-@master/img/202306121656037.png alt=image.png>
上图中每个线都会对应一个金属引脚。<br>n位地址 对应 2<sup>n</sup>的存储单元。<br>8K * 8位 即2<sup>13</sup> * 8bit容量，地址线有13位，数据线有8位。</p><h3 id=寻址>寻址
<a class=anchor href=#%e5%af%bb%e5%9d%80>#</a></h3><p>现代计算机通常按字节编址，即每个字节对应一个地址。<br>对于总容量为1KB的存储体。地址线为10条，数据线为8条</p><ul><li>按字节寻址，1K个单元，每个单元存储1B的二进制数据。</li><li>按字寻址，将四个连续的字节合并为一个字，一次读取一个字，即256个单元，每个单元4B，字节地址算数左移两位转换为按字寻址的地址。</li><li>按半字寻址，将连续的两个字节合并为一个字。总共512个单元，每个单元存储2B的二进制数据。</li><li>按双字寻址，将连续的八个字节合并为一个字。总共128个单元，每个单元存储8B的二进制数据。</li></ul><h2 id=sram与dram>SRAM与DRAM
<a class=anchor href=#sram%e4%b8%8edram>#</a></h2><p>静态RAM与动态RAM<br>DRAM一般用于主存，SRAM一般用于Cache</p><h3 id=存储元件不同而导致的特性差异>存储元件不同而导致的特性差异
<a class=anchor href=#%e5%ad%98%e5%82%a8%e5%85%83%e4%bb%b6%e4%b8%8d%e5%90%8c%e8%80%8c%e5%af%bc%e8%87%b4%e7%9a%84%e7%89%b9%e6%80%a7%e5%b7%ae%e5%bc%82>#</a></h3><h5 id=栅极电容>栅极电容
<a class=anchor href=#%e6%a0%85%e6%9e%81%e7%94%b5%e5%ae%b9>#</a></h5><p><img src=https://cdn.staticaly.com/gh/ivylet/blog_picg-@master/img/202306121734757.png alt=image.png>
电容放电后，信息会被破坏，是破坏性读出，读出后应该对数据重写。
每个存储元制造成本低，集成度高，功耗低。<br>电容中的电荷信息即使不读取也会丢失，一般只能维持2ms，所以需要频繁对电容进行刷新。</p><h5 id=双稳态触发器>双稳态触发器
<a class=anchor href=#%e5%8f%8c%e7%a8%b3%e6%80%81%e8%a7%a6%e5%8f%91%e5%99%a8>#</a></h5><p><img src=https://cdn.staticaly.com/gh/ivylet/blog_picg-@master/img/202306121735704.png alt=image.png>
有两种稳定的状态：
1：A高电平，B低电平。<br>0：A低电平，B高电平。<br>读出数据后，触发器状态依旧稳定，读数据为非破坏性读出，无需重写。<br>每个存储元制造成本高，器件多，集成度低，功耗高。</p><h5 id=两种器件的特性对比>两种器件的特性对比：
<a class=anchor href=#%e4%b8%a4%e7%a7%8d%e5%99%a8%e4%bb%b6%e7%9a%84%e7%89%b9%e6%80%a7%e5%af%b9%e6%af%94>#</a></h5><p><img src=https://cdn.staticaly.com/gh/ivylet/blog_picg-@master/img/202306121740416.png alt=image.png>
两种断电之后信息都会消失，都是易失性读出。</p><h3 id=dram的刷新>DRAM的刷新
<a class=anchor href=#dram%e7%9a%84%e5%88%b7%e6%96%b0>#</a></h3><h4 id=多久需要刷新一次>多久需要刷新一次？
<a class=anchor href=#%e5%a4%9a%e4%b9%85%e9%9c%80%e8%a6%81%e5%88%b7%e6%96%b0%e4%b8%80%e6%ac%a1>#</a></h4><p>刷新周期一般为2ms，</p><h4 id=每次刷新多少存储单元>每次刷新多少存储单元？
<a class=anchor href=#%e6%af%8f%e6%ac%a1%e5%88%b7%e6%96%b0%e5%a4%9a%e5%b0%91%e5%ad%98%e5%82%a8%e5%8d%95%e5%85%83>#</a></h4><p>以行为单位，每次刷新一行存储单元。<br>简单模型为存储单元按号排序，如果采用20位地址线就，那么就要排0到2<sup>20</sup> - 1号存储单元，也就是需要出2<sup>20</sup>条线，显然很难实现。<br><img src=https://cdn.staticaly.com/gh/ivylet/blog_picg-@master/img/202306121758329.png alt=image.png></p><p>如果用行列地址来定址，那么只需要一个行地址译码器和一个列地址译码器，每个译码器只需要确定0到1023号，相比来说减少了很多。地址分为行地址和列地址，前半部分为行地址，后半部分为列地址。减少了连通线的数量。<br><img src=https://cdn.staticaly.com/gh/ivylet/blog_picg-@master/img/202306121759394.png alt=image.png></p><h4 id=如何刷新>如何刷新？
<a class=anchor href=#%e5%a6%82%e4%bd%95%e5%88%b7%e6%96%b0>#</a></h4><p>有相关硬件支持，由存储器独立完成，不需要CPU控制。每次读取一行存储单元的信息后，重新写入，占用1个读/写周期。</p><h4 id=在什么时候刷新呢>在什么时候刷新呢？
<a class=anchor href=#%e5%9c%a8%e4%bb%80%e4%b9%88%e6%97%b6%e5%80%99%e5%88%b7%e6%96%b0%e5%91%a2>#</a></h4><p>假设DRAM内部结构排列成128x128的形式，读写周期为0.5us，2ms共2ms/0.5us = 4000个周期。</p><ol><li><p>分散刷新
每次读写玩都刷新一行，系统的存储周期会变长，前0.5us时间用于正常读写，后0.5us时间用于刷新，系统存储周期变为1us。<br><img src=https://cdn.staticaly.com/gh/ivylet/blog_picg-@master/img/202306121948120.png alt=image.png></p></li><li><p>集中刷新
选择2ms集中安排时间全部刷新，系统的存储周期不变，但有一段时间专门用于刷新，此时无法访问存储器，称之为“死区”<br><img src=https://cdn.staticaly.com/gh/ivylet/blog_picg-@master/img/202306121950650.png alt=image.png></p></li><li><p>异步刷新
2ms内每行刷新一次即可-> 2ms内需要产生128次刷新请求即，每隔2ms/128 = 15.6us一次，而每15.6us就有0.5us的死时间，相比集中刷新，异步刷新更分散。<br><img src=https://cdn.staticaly.com/gh/ivylet/blog_picg-@master/img/202306121953167.png alt=image.png></p></li></ol><h3 id=dram的地址线复用技术>DRAM的地址线复用技术
<a class=anchor href=#dram%e7%9a%84%e5%9c%b0%e5%9d%80%e7%ba%bf%e5%a4%8d%e7%94%a8%e6%8a%80%e6%9c%af>#</a></h3><p>由上边可知，DRAM如果存储单元过多，会导致译码器所需连接线过多，所以采用了行列地址来定址，每次刷新都是可以直接刷新一行，根据这个特性，可以在送行列地址时，将地址分为两次发送，一次为行，一次为列，通过相同的引脚输入。这样可以使地址线数减半，芯片引脚中地址引脚数减半。</p><h6 id=关于外接引脚个数>关于外接引脚个数
<a class=anchor href=#%e5%85%b3%e4%ba%8e%e5%a4%96%e6%8e%a5%e5%bc%95%e8%84%9a%e4%b8%aa%e6%95%b0>#</a></h6><p>SRAM 的外部引脚线是片选线和读写控制线，以及地址线和数据线。DRAM的外部引脚线是行选通信号线和列选通信号和线，读写控制线，以及地址线和数据线。</p><p>现在主流主存储器采用SDRAM，DRAM被淘汰了。</p><h2 id=只读存储器rom>只读存储器ROM
<a class=anchor href=#%e5%8f%aa%e8%af%bb%e5%ad%98%e5%82%a8%e5%99%a8rom>#</a></h2><h3 id=常见rom>常见ROM
<a class=anchor href=#%e5%b8%b8%e8%a7%81rom>#</a></h3><p>ROM芯片是非易失性的，即断电后数据不会丢失。<br>一般有MROM、PROM、EPROM、闪存、SSD等。</p><ul><li>MROM掩模式只读存储器，
一次写入后，之后任何人不可以重写。可靠性高，集成度高，价格便宜；缺点是灵活性差。</li><li>PROM可编程只读存储器，
用户可以用专门的PROM写入器写入信息，写入一次后就不能更改。</li><li>EPROM可擦除可编程只读存储器
用户可以通过编程器写入信息，也可以进行多次修改，虽然即可读又可以写，但是编程次数有限，不能替代RAM。<br>LIVEPROM 用紫外写照射8-20分钟，可以擦除所有信息。<br>EEPROM 可以用电擦除的方式，擦除特定的字。</li><li>Flash Memory 闪存
由EEPROM发展而来，可用长期保存信息，也可以在线进行快速擦除与重写，既有价格便宜集成度高的特点，断电后可以保存信息，并且可以进行多次快速擦除重写。闪存需要先擦除再写入，因此闪存的“写”速度要比“读”慢。每个存储单元 只需要单个MOS管，位密度比RAM高。</li><li>Soil State Drivers 固态硬盘
由控制单元加存储单元（Flash芯片）构成，与Flash核心区别在于控制单元不同，可以进行多次快速擦除重写，速度快，功耗低，价格高。</li></ul><h3 id=计算机内重要的rom>计算机内重要的ROM
<a class=anchor href=#%e8%ae%a1%e7%ae%97%e6%9c%ba%e5%86%85%e9%87%8d%e8%a6%81%e7%9a%84rom>#</a></h3><p>电脑关机后，RAM不通电，其内部的数据全部丢失，计算机下次开机时需要启动代码，这部分代码存在主板上的一块ROM中（BIOS），逻辑上一般将这一块与主存放到一起。编址时，一般将这块ROM上的内容编写到地址首位。<br><img src=https://cdn.staticaly.com/gh/ivylet/blog_picg-@master/img/202306122026529.png alt=image.png></p><h2 id=双端口ram和多模块存储器>双端口RAM和多模块存储器
<a class=anchor href=#%e5%8f%8c%e7%ab%af%e5%8f%a3ram%e5%92%8c%e5%a4%9a%e6%a8%a1%e5%9d%97%e5%ad%98%e5%82%a8%e5%99%a8>#</a></h2><p>主存的优化技术。</p><h5 id=存取周期>存取周期
<a class=anchor href=#%e5%ad%98%e5%8f%96%e5%91%a8%e6%9c%9f>#</a></h5><p><img src=https://cdn.staticaly.com/gh/ivylet/blog_picg-@master/img/202306122036703.png alt=image.png>
如果有多核CPU都要访存，怎么办？CPU读写速度比主存快很多，主存恢复时间太长怎么办？</p><h3 id=双端口ram大纲已删>双端口RAM（大纲已删）
<a class=anchor href=#%e5%8f%8c%e7%ab%af%e5%8f%a3ram%e5%a4%a7%e7%ba%b2%e5%b7%b2%e5%88%a0>#</a></h3><p>主要作用: 优化多核CPU访问同一根内存条的速度。<br><img src=https://cdn.staticaly.com/gh/ivylet/blog_picg-@master/img/202306122041578.png alt=image.png></p><p>主存需要有完全两组独立的数据线、地址线、控制线。CPU、RAM中也要有更复杂的控制电路。<br>两个端口对同一主存进行操作有4中情况：</p><ol><li>两个端口同时对不同的地址单元存取数据。 允许</li><li>两个端口同时对同一的地址单元读出数据。 允许</li><li>两个端口同时对同一的地址单元写入数据。 写入错误</li><li>两个端口同时对同一的地址单元，一个读入数据，一个写入数据。 读出错误
如果出现3 4的情况，置忙信号，由判断逻辑暂时关闭一个端口（延时接入），另一个端口正常访问。</li></ol><h3 id=多模块存储器>多模块存储器
<a class=anchor href=#%e5%a4%9a%e6%a8%a1%e5%9d%97%e5%ad%98%e5%82%a8%e5%99%a8>#</a></h3><p>利用多个结构相同的存储模块的并行工作来提高存储器的吞吐率。<br>CPU的速度比存储器快，若同时从存储器中取出n条指令，就可以充分利用CPU资源，提高运行速度。多体交叉存储器就是基于这种思想实现的。<br>存储体中存的多数数据是连续存储的，比如数组。</p><h4 id=单体多字存储器>单体多字存储器
<a class=anchor href=#%e5%8d%95%e4%bd%93%e5%a4%9a%e5%ad%97%e5%ad%98%e5%82%a8%e5%99%a8>#</a></h4><p>单体多字存储器就是，存储器中只有一个存储体，每个存储单元存储m个字，总线宽度也为m个字。一次并行读出m个字，地址必须顺序排列并处于同一存储单元。<br>在一个存储周期内，从同一地址取出m条指令，然后将指令逐条送至CPU，即每隔1/m个存取周期，CPU向主存读取一条命令，显然提高了单体存储器的工作速度。但是只有当指令和数据是连续存放的，效果才比较明显。</p><h4 id=多体并行存储器>多体并行存储器
<a class=anchor href=#%e5%a4%9a%e4%bd%93%e5%b9%b6%e8%a1%8c%e5%ad%98%e5%82%a8%e5%99%a8>#</a></h4><p>多体并行存储器由多模块组成，每个模块都有相同的容量和存取速度，每个模块都有独立的读写控制电路、地址寄存器、数据寄存器。既能并行工作，也能交叉工作。<br><img src=https://cdn.staticaly.com/gh/ivylet/blog_picg-@master/img/202306122126242.png alt=image.png></p><h5 id=高位交叉编址顺序方式>高位交叉编址（顺序方式）
<a class=anchor href=#%e9%ab%98%e4%bd%8d%e4%ba%a4%e5%8f%89%e7%bc%96%e5%9d%80%e9%a1%ba%e5%ba%8f%e6%96%b9%e5%bc%8f>#</a></h5><p><img src=https://cdn.staticaly.com/gh/ivylet/blog_picg-@master/img/202306122104248.png alt=image.png>
高位交叉编址其实就还是将多个存储器串行存取，实际上还是顺序存储器。每次读取一次后，需要再等待恢复周期，实际并不能提高效率。<br>以连续访问00000-00100地址为例：<br>设每个存储体存取周期为T，存取时间为r，T=r + 3r<br><img src=https://cdn.staticaly.com/gh/ivylet/blog_picg-@master/img/202306122109750.png alt=image.png><br>则总耗时为5T</p><h5 id=低位交叉编址交叉方式>低位交叉编址（交叉方式）
<a class=anchor href=#%e4%bd%8e%e4%bd%8d%e4%ba%a4%e5%8f%89%e7%bc%96%e5%9d%80%e4%ba%a4%e5%8f%89%e6%96%b9%e5%bc%8f>#</a></h5><p><img src=https://cdn.staticaly.com/gh/ivylet/blog_picg-@master/img/202306122105240.png alt=image.png><br>低位交叉编址是将地址低位设为存储体序号，则CPU读取第一个存储体的内容后，下一个连续地址是下一个存储体的地址，这样可以不用等待前面存储体的恢复周期，从而实现连续读取。 相比高位编址，可以提高效率。<br>以连续访问00000-00100地址为例：<br>设每个存储体存取周期为T，存取时间为r，T=r + 3r<br><img src=https://cdn.staticaly.com/gh/ivylet/blog_picg-@master/img/202306122110146.png alt=image.png><br>则总耗时为T + 4r。 如果连续读取n个存储字，总耗时为T + (n - 1)r，当n足够大时，读取单个存储字的时间约等于r。</p><h6 id=那么应该取几个体>那么应该取几个“体”
<a class=anchor href=#%e9%82%a3%e4%b9%88%e5%ba%94%e8%af%a5%e5%8f%96%e5%87%a0%e4%b8%aa%e4%bd%93>#</a></h6><p>低位交叉编址的方式类似于“流水线”的方式进行并行存取，一个存储周期内，m体交叉存储器可以提供的数据量为单个的m倍。<br>存取周期为T，存取时间为r，为了使刘淑霞不间断，应该保证模块数m >= T/r。
存取周期为T，总线传输周期为r，为了使读取不间断，应该保证模块数m >= T/r。<br><img src=https://cdn.staticaly.com/gh/ivylet/blog_picg-@master/img/202306122122806.png alt=image.png>
如果m = T / r则刚好完美衔接。</p><h1 id=主存储器与cpu的连接>主存储器与CPU的连接
<a class=anchor href=#%e4%b8%bb%e5%ad%98%e5%82%a8%e5%99%a8%e4%b8%8ecpu%e7%9a%84%e8%bf%9e%e6%8e%a5>#</a></h1><p>存储芯片的基本结构：
译码驱动电路、存储矩阵、读写电路、地址线、数据线、控制线、片选线组成<br><img src=https://cdn.staticaly.com/gh/ivylet/blog_picg-@master/img/202306140029807.png alt></p><p>存储芯片需要暴露地址总线和数据总线与CPU进行连接，片选线（一般为CS或CE）供CPU选择，读写控制线（一般为WE或WR，也有可能会拆分为两条线WE和OE）控制对存储芯片的读/写。</p><h2 id=单块存储芯片与cpu连接>单块存储芯片与CPU连接
<a class=anchor href=#%e5%8d%95%e5%9d%97%e5%ad%98%e5%82%a8%e8%8a%af%e7%89%87%e4%b8%8ecpu%e8%bf%9e%e6%8e%a5>#</a></h2><p>例如给定一个8 * 8位的存储芯片，直接与CPU连接。<br><img src=https://cdn.staticaly.com/gh/ivylet/blog_picg-@master/img/202306140041822.png alt=image.png><br>如上图，存储芯片8K* 1位，即主存存储字长1 bit，主存存储单元2<sup>13</sup>个</p><ul><li>13跟地址线A与CPU的16根地址线中的13根地址线接头相连；</li><li>写使能线WE与CPU的控制线中的写使能线相连</li><li>1跟数据线D与CPU的8根数据线中的一根相连；</li><li>片选线CS，由于只有这一个存储芯片与CPU相连接，所以只需要直接给片选线加高电平信号就行</li><li>CPU的最大能力能够处理的是是64K * 64位存储器 ，但是只连接一个存储器，CPU的能力没有被充分利用；不论是机器字长还是地址线。</li></ul><h6 id=现代计算机>现代计算机
<a class=anchor href=#%e7%8e%b0%e4%bb%a3%e8%ae%a1%e7%ae%97%e6%9c%ba>#</a></h6><p>现在的计算机一般的MDR与MAR都在CPU中。<br><img src=https://cdn.staticaly.com/gh/ivylet/blog_picg-@master/img/202306140013309.jpg alt=0e9ee0fe3f0a6af182136e640cfd6ad.jpg><br>现在的存储体一般都是由多块存储芯片组成的。</p><h2 id=多块存储芯片与cpu连接>多块存储芯片与CPU连接
<a class=anchor href=#%e5%a4%9a%e5%9d%97%e5%ad%98%e5%82%a8%e8%8a%af%e7%89%87%e4%b8%8ecpu%e8%bf%9e%e6%8e%a5>#</a></h2><p>单个存储器的数据字长为8位，但是现在CPU可以同时处理的位数为32位，甚至64位，为了最大发挥数据总线的性能，每次多取多读可以减少读写次数，那应该怎么办？即数据总线宽度>存储芯片字长。采用位扩展的方法。</p><h4 id=位扩展扩展位数>位扩展（扩展位数）
<a class=anchor href=#%e4%bd%8d%e6%89%a9%e5%b1%95%e6%89%a9%e5%b1%95%e4%bd%8d%e6%95%b0>#</a></h4><p>例如CPU的数据总线是8位，地址总线有16位，现在有若干个地址线有13位，8K*1位的存储芯片，来进行位扩展，使得CPU的数据总线都用上。<br><img src=https://cdn.staticaly.com/gh/ivylet/blog_picg-@master/img/202306140028744.png alt=image.png></p><p>地址总线与每个存储芯片进行串行地连接，数据总线与这些存储芯片进行并行连接。</p><p><img src=https://cdn.staticaly.com/gh/ivylet/blog_picg-@master/img/202306140012159.jpg alt=d196f66b1b61e06bf8c75562d5f11c3.jpg></p><p>扩展主存的字数？采用字扩展的方法。</p><h4 id=字扩展主存容量扩展>字扩展（主存容量扩展）
<a class=anchor href=#%e5%ad%97%e6%89%a9%e5%b1%95%e4%b8%bb%e5%ad%98%e5%ae%b9%e9%87%8f%e6%89%a9%e5%b1%95>#</a></h4><p>例如CPU的数据总线是8位，地址总线有16位，现在有若干个地址线有13位，8K*8位的存储芯片，由于数据总线都已经被占满，所以不需要进行位扩展。但是还有3根地址线是空闲的，我们可以将这三根地址线利用上。充分利用CPU的寻址能力。<br><img src=https://cdn.staticaly.com/gh/ivylet/blog_picg-@master/img/202306140028470.png alt=image.png></p><p><strong>线选法</strong>：这三根地址线可以连接到3块存储芯片的片选线上。三根地址线信号为001则代表选择第一块存储芯片，010代表选择第二块。电路简单，地址空间不连续。</p><p><img src=https://cdn.staticaly.com/gh/ivylet/blog_picg-@master/img/202306140024796.png alt=image.png></p><p><strong>片选法</strong>：这三根地址线通过3-8译码器，可以连接到8块存储芯片的片选线上。三根地址线信号为000则代表选择第一块存储芯片，001代表选择第二块。这样就实现了字扩展。</p><p><img src=https://cdn.staticaly.com/gh/ivylet/blog_picg-@master/img/202306140026840.png alt=image.png></p><p>这样也就是给这8块存储芯片重新编址，类似于高位交叉编址，第一块存储芯片的地址前加上00，范围为000 0000 0000 0000到001 1111 1111 1111，第二块存储芯片的地址范围为010 0000 0000 0000到011 1111 1111 1111以此类推。设计电路较为复杂，但是地址空间连续。</p><p><img src=https://cdn.staticaly.com/gh/ivylet/blog_picg-@master/img/202306140025856.png alt=image.png></p><p>两种方式的比较：<br><img src=https://cdn.staticaly.com/gh/ivylet/blog_picg-@master/img/202306140050848.png alt=image.png></p><p>字位可以同时扩展！
<img src=https://cdn.staticaly.com/gh/ivylet/blog_picg-@master/img/202306140010294.jpg alt=adc6e5b6cac19eef4cf3c804aafa9fe.jpg></p><h2 id=关于译码器知识补充>关于译码器知识补充
<a class=anchor href=#%e5%85%b3%e4%ba%8e%e8%af%91%e7%a0%81%e5%99%a8%e7%9f%a5%e8%af%86%e8%a1%a5%e5%85%85>#</a></h2><p>译码器也有多个使能信号，CPU可以通过这些使能信号来控制译码器控制片选信号的生效时间。</p><p>译码器 n条线入 ，可以得到2<sup>n</sup>个信号出。<br><img src=https://cdn.staticaly.com/gh/ivylet/blog_picg-@master/img/202306140051543.png alt=image.png><br>高电平有效，低电平有效译码器，与存储芯片连接时需要注意。</p><p>一般连通后，都需要先等一小会，等待信号稳定后再进行片选，读取数据等操作！</p><h1 id=外部存储器>外部存储器
<a class=anchor href=#%e5%a4%96%e9%83%a8%e5%ad%98%e5%82%a8%e5%99%a8>#</a></h1><p>外存又称为辅助存储器，目前主要是使用磁表面存储器（机械硬盘，光盘）</p><p>磁表面存储器是使用最广泛的外存储器。所谓磁表面存储，是用某些磁性材料薄薄地涂在金属铝或塑料表面作载磁体来存储信息。根据记录载体的外形，磁表面存储器有磁鼓、磁带、磁盘、磁卡等。而在计算机系统中广泛使用的是磁盘和磁带；特别是磁盘，几乎是稍具规模系统的基本配置。<br><img src=https://cdn.staticaly.com/gh/ivylet/blog_picg-@master/img/202306141543592.png alt=image.png></p><p>针头上有写线圈与读线圈，划过磁层上方后每次读或写1bit数据，如果要读/写8bit数据，需要转为串行。</p><p>优点：</p><ol><li>存储容量大，位价格低</li><li>记录介质可以重复使用</li><li>记录信息可以长期保存不丢失，甚至可以脱机读档。</li><li>非破坏性读出，读出后不需要重新写入。</li></ol><p>缺点：</p><ol><li>存取数据慢</li><li>机械机构复杂</li><li>对工作环境要求较高（不能处于强磁场区域）</li></ol><p>既可以作为输入设备，也可以作为输出设备。</p><h2 id=磁盘存储器>磁盘存储器
<a class=anchor href=#%e7%a3%81%e7%9b%98%e5%ad%98%e5%82%a8%e5%99%a8>#</a></h2><h3 id=磁盘设备的组成>磁盘设备的组成
<a class=anchor href=#%e7%a3%81%e7%9b%98%e8%ae%be%e5%a4%87%e7%9a%84%e7%bb%84%e6%88%90>#</a></h3><ol><li>存储区域
一块磁盘含有若干个记录面，每个记录面划分为若干条磁道，而每条磁道又划分为若干个扇区，扇区（也叫块）是磁盘读写的最小单位，也就是说磁盘按块读取。</li></ol><ul><li>磁头数
记录面数，表示磁盘总共有多少个磁头，磁头用于读取/写入盘片上记录面的信息，一个记录面对应一个磁头。</li><li>柱面数（从内向外）
表示硬盘每一面上有多少条磁道。在一个盘组中，不同记录面的相同编号（位置）的所有磁道构成一个圆柱面。</li><li>扇区数（圆周分为几部分扇形）
表示每一条磁道有多少个扇区</li></ul><ol start=2><li>硬盘存储器
磁盘驱动器：<br>核心部分是磁头组件和盘片组件。一般为机械硬盘的盘面磁头等一系列组件。<br><img src=https://cdn.staticaly.com/gh/ivylet/blog_picg-@master/img/202306141609365.png alt=image.png></li></ol><p>磁盘控制器：<br>是硬盘存储器与主机的接口。一般是机械硬盘背面的电路板。<br><img src=https://cdn.staticaly.com/gh/ivylet/blog_picg-@master/img/202306141609402.png alt=image.png></p><h3 id=磁盘的性能指标>磁盘的性能指标
<a class=anchor href=#%e7%a3%81%e7%9b%98%e7%9a%84%e6%80%a7%e8%83%bd%e6%8c%87%e6%a0%87>#</a></h3><h6 id=磁盘的容量>磁盘的容量：
<a class=anchor href=#%e7%a3%81%e7%9b%98%e7%9a%84%e5%ae%b9%e9%87%8f>#</a></h6><p>一个磁盘所能存储的字节总数。磁盘容量有非格式化容量和格式化容量之分。<br>非格式化容量是指磁记录表面可以李彤的磁化单元总数。是理论上硬盘的容量。<br>格式化容量是指按照某种特定的记录格式所能存储信息的重量。用户实际能存储数据的容量。<br>格式化容量一般比非格式化容量小。</p><h6 id=记录密度>记录密度：
<a class=anchor href=#%e8%ae%b0%e5%bd%95%e5%af%86%e5%ba%a6>#</a></h6><ul><li>道密度
沿磁盘半径方向单位长度上的磁道数。例如60道/cm</li><li>位密度
磁盘单位长度上能记录的二进制代码位数。例如600bit/cm</li><li>面密度
位密度与道密度的乘积，单位面积上能记录的二进制代码
注意：磁盘上所有磁道记录的信息量是相等的，并非越靠外，磁道越长记录的越多。这也表明每条磁道的位密度不同，越靠外位密度越低，越靠内位密度越高。所以磁盘性能很大情况看最内层磁道所存储的信息量。</li></ul><h6 id=平均存取时间>平均存取时间
<a class=anchor href=#%e5%b9%b3%e5%9d%87%e5%ad%98%e5%8f%96%e6%97%b6%e9%97%b4>#</a></h6><p>平均存取时间 = 寻道时间（磁头移动到要读取的磁道时间） + 旋转延迟时间（磁盘旋转将扇区划到磁头下方） + 传输时间（磁头开始读取数据）。</p><h6 id=数据传输率>数据传输率
<a class=anchor href=#%e6%95%b0%e6%8d%ae%e4%bc%a0%e8%be%93%e7%8e%87>#</a></h6><p>单位时间内磁盘存储器向主机传送数据的字节数。假设磁盘转速为r，每条磁道容量为N个字节，则数据传输率为r*N<br>读取一个扇区的时间 ＝ 找磁道的时间 + 找扇区的时间 + 磁头扫过一个扇区的时间。<br>磁头先移动到 磁道的时间 为寻道时间。磁盘旋转到扇区的时间为旋转延迟时间，一般取磁头扫完整个磁道的时间的一半。 传输时间为 读取的数据除以 数据传输率。</p><h3 id=磁盘地址>磁盘地址
<a class=anchor href=#%e7%a3%81%e7%9b%98%e5%9c%b0%e5%9d%80>#</a></h3><p>主机向磁盘控制器发送寻址信息，
驱动器号（电脑可能有多个硬盘） + 盘面/磁道号（从内到外在哪个圈上） + 盘面号（从上到下在哪个盘上） + 扇区号（确定了哪个盘哪个磁道，再找在哪个扇区）<br><img src=https://cdn.staticaly.com/gh/ivylet/blog_picg-@master/img/202306141638329.png alt=image.png></p><h3 id=磁盘的工作过程>磁盘的工作过程
<a class=anchor href=#%e7%a3%81%e7%9b%98%e7%9a%84%e5%b7%a5%e4%bd%9c%e8%bf%87%e7%a8%8b>#</a></h3><p>硬盘的主要操作是寻址，读盘，写盘，每个操作都对应一个控制字，磁盘工作时，第一步是取控制字，第二步是执行控制字。<br>磁盘属于机械式部件，其读写操作是串行的，不可能同一时刻读和写，也不可能同时读或写两份数据。<br><img src=https://cdn.staticaly.com/gh/ivylet/blog_picg-@master/img/202306141641175.png alt=image.png></p><h3 id=磁盘阵列raid>磁盘阵列（RAID）
<a class=anchor href=#%e7%a3%81%e7%9b%98%e9%98%b5%e5%88%97raid>#</a></h3><p>RAID （ Redundant Array of Independent Disks ）即独立磁盘冗余阵列，简称为「磁盘阵列」，其实就是用多个独立的磁盘组成在一起形成一个大的磁盘系统，从而实现比单块磁盘更好的存储性能和更高的可靠性。避免数据出现错误导致信息丢失。方案不断更新，安全性越高。<br>RAID方案常见的可以分为：</p><ul><li>RAID0：无冗余和无校验（无容错能力）</li><li>RAID1：镜像磁盘阵列（容量减少一半，镜像磁盘互为备份）</li><li>RAID2：采用纠错的海明码的磁盘阵列</li><li>RAID3：位交叉奇偶校验</li><li>RAID4：块交叉奇偶校验</li><li>RAID5：无独立校验的奇偶校验磁盘阵列</li></ul><h2 id=固态硬盘ssd>固态硬盘SSD
<a class=anchor href=#%e5%9b%ba%e6%80%81%e7%a1%ac%e7%9b%98ssd>#</a></h2><h5 id=原理>原理
<a class=anchor href=#%e5%8e%9f%e7%90%86>#</a></h5><p>基于闪存技术，属于电可擦除ROM，即EEPROM。</p><h5 id=组成>组成
<a class=anchor href=#%e7%bb%84%e6%88%90>#</a></h5><ul><li>闪存翻译层
负责翻译逻辑块号，定位到对应页</li><li>存储介质，闪存芯片组（包含一个或多个闪存芯片）。
每个芯片包含多个块，每个块包含多个页。</li></ul><h5 id=读写性能特性>读写性能特性
<a class=anchor href=#%e8%af%bb%e5%86%99%e6%80%a7%e8%83%bd%e7%89%b9%e6%80%a7>#</a></h5><ul><li>以页为单位进行读写，相当于磁盘的扇区。</li><li>以块为单位擦除，擦干净的块，其中的每一页都可以写一次，读无数次。</li><li>支持随机访问，系统给定一个逻辑地址，闪存翻译层可以通过电路迅速定位到对应的物理地址。</li><li>读快、写慢（涉及擦除等操作），要写入的页如果有数据，则不能写入。需要将块内其他页全部复制到一个新的（擦除过的）块中，再写入新的页。</li></ul><h5 id=与机械硬盘相比的特点>与机械硬盘相比的特点
<a class=anchor href=#%e4%b8%8e%e6%9c%ba%e6%a2%b0%e7%a1%ac%e7%9b%98%e7%9b%b8%e6%af%94%e7%9a%84%e7%89%b9%e7%82%b9>#</a></h5><ul><li>SSD读写快，随机访问性能高，用电路控制访问位置。</li><li>SSD安静无噪音，耐摔抗震，能耗低中，造价更贵。</li><li>SSD的一个“块”被擦除次数过多（重复写入同一个块）可能会坏掉，而机械硬盘并不会因为写的次数太多而坏掉。</li></ul><h5 id=磨损均衡技术>磨损均衡技术
<a class=anchor href=#%e7%a3%a8%e6%8d%9f%e5%9d%87%e8%a1%a1%e6%8a%80%e6%9c%af>#</a></h5><ul><li>将擦除平均分布在各个块上，以提升使用寿命。</li><li>动态磨损均衡
写入数据时，优先选择累计擦除次数少的新闪存块。</li><li>静态磨损均衡
SSD监测并自动进行数据分配、迁移、让老旧的块承担以读为主的存储任务，让较新的闪存块承担更多的写任务。</li></ul><h1 id=高速缓冲器cache>高速缓冲器（Cache）
<a class=anchor href=#%e9%ab%98%e9%80%9f%e7%bc%93%e5%86%b2%e5%99%a8cache>#</a></h1><p>通过提高存储芯片本身的速度与采用并行存储器结构可以缓解CPU与主存之间速度不匹配的问题。除了这两种方法，在CPU与主存之间设置高速缓冲器（Cache），即将频繁访问的数据放入高速存储器，这样CPU读取经常访问的数据的速度就快多了，这样也可以提高CPU访问指令和数据的速度！<br>现在Cache一般都被集成到了CPU中，用SRAM实现，速度快，成本高！</p><h2 id=局部性原理>局部性原理
<a class=anchor href=#%e5%b1%80%e9%83%a8%e6%80%a7%e5%8e%9f%e7%90%86>#</a></h2><ul><li>空间局部性：<br>在将要使用的信息（指令和数据），很可能与正在使用的信息存在存储空间中相邻的位置，比如使用的数组元素。</li><li>时间局部性：<br>将要使用的信息中，很可能就是现在正在使用的信息。 比如程序中所使用的循环结构。<br>基于这个原理不难想到，我们可以把CPU目前访问的地址附近的部分数据存到Cache中。<br>访问二维数组内容时，如果先访问列与先访问行内容的空间局部性利用较差！</li></ul><h2 id=cache的基本工作原理>Cache的基本工作原理
<a class=anchor href=#cache%e7%9a%84%e5%9f%ba%e6%9c%ac%e5%b7%a5%e4%bd%9c%e5%8e%9f%e7%90%86>#</a></h2><p>主存的“块”又叫”页/页框/页面“；Cache的“块”又叫“行”；主存块的大小等于Cache行中数据区的大小。<br>主存地址可拆分为（主存块，块内地址）的形式。<br>主存和Cache之间是以块为单位来进行交换的。
每次被访问的主存块，一定会被立即调入Cache中。</p><h3 id=cache中的有效位>Cache中的有效位
<a class=anchor href=#cache%e4%b8%ad%e7%9a%84%e6%9c%89%e6%95%88%e4%bd%8d>#</a></h3><p>系统启动或复位时，每个Cache行都为空，其中的信息无效，只用从主存中转入了数据才有效，为了说明Cache行中的数据是否有效，每个Cache行需要设定一个有效位。有了有效位，可以通过将有效位置为0来淘汰某Cache行中的主存块，称之为“冲刷”，装入时再置为1。</p><h3 id=cpu找cache中的访问过程>CPU找Cache中的访问过程
<a class=anchor href=#cpu%e6%89%becache%e4%b8%ad%e7%9a%84%e8%ae%bf%e9%97%ae%e8%bf%87%e7%a8%8b>#</a></h3><p>CPU在执行程序过程中，需要从主存储器中读取指令或数据时，先检查Cache中有没有要访问的信息，若有则直接从中读取，若没有再从主存中把当前访问信息所在的一个主存块复制到Cache中，因此Cache中的内容是主存中部分内容的副本。</p><h3 id=平均访问时间>平均访问时间
<a class=anchor href=#%e5%b9%b3%e5%9d%87%e8%ae%bf%e9%97%ae%e6%97%b6%e9%97%b4>#</a></h3><p>设t<sub>c</sub>为访问一次Cache所需的时间，t<sub>m</sub>为访问一次主存所需要的时间，命中率H为CPU将要访问的信息在Cache中的比率。<br>则 Cache-主存 系统中平均访问时间为：</p><ol><li>先访问Cache，找不到再访问主存
t = Ht<sub>c</sub> + (1 - H)(t<sub>m</sub> + T)</li><li>同时访问Cache和主存，若Cache命中则停止访问主存
t = Ht<sub>c</sub> + (1 - H)t<sub>m</sub></li></ol><h3 id=几个问题>几个问题
<a class=anchor href=#%e5%87%a0%e4%b8%aa%e9%97%ae%e9%a2%98>#</a></h3><p>如何区分Cache与主存中的数据块对应关系？<br>如果Cache满了要怎么办？<br>CPU修改了Cache中的数据副本，如何确保主存中的数据母本的一致性？</p><h2 id=cache行与主存块之间的映射方式>Cache行与主存块之间的映射方式
<a class=anchor href=#cache%e8%a1%8c%e4%b8%8e%e4%b8%bb%e5%ad%98%e5%9d%97%e4%b9%8b%e9%97%b4%e7%9a%84%e6%98%a0%e5%b0%84%e6%96%b9%e5%bc%8f>#</a></h2><p>Cache中存储的信息为：<br>有效位0/1 + 标记（确定在主存中的地址） + 整块数据<br>如何区分Cache与主存中的数据块对应关系？</p><h3 id=全相联映射随意映射>全相联映射（随意映射）
<a class=anchor href=#%e5%85%a8%e7%9b%b8%e8%81%94%e6%98%a0%e5%b0%84%e9%9a%8f%e6%84%8f%e6%98%a0%e5%b0%84>#</a></h3><p><img src=https://cdn.staticaly.com/gh/ivylet/blog_picg-@master/img/202306142024787.png alt=image.png>
主存块可以放到Cache中的任意位置。
以某计算机的主存地址空间为256MB，按字节编址，其数据Cache有8个Cache行，行长为64B为例。<br>Cache块与主存块大小相等，所以主存块的大小也为64B，由于主存是按字节编址，则块内地址共6位，即0到63，主存块号为共22位。<br>从而映射到Cache中的标记也有22位，再附加1位有效位，置1证明是有效。<br><img src=https://cdn.staticaly.com/gh/ivylet/blog_picg-@master/img/202306142046763.png alt=image.png><br>全相联映射的思想是一个主存块可装到Cache行中的任意一块，每行的标记用于指出该行取自主存的哪个块，主存地址也无需Cache行索引，只有标记和块内地址两个字段。只要有空闲的Cache行，就不会发生冲突。<br>优点： Cache空间利用率充分，命中率高；<br>缺点：查找“标记”锁定内存块慢，有可能需要比对很多行。不适合容量较大的Cache。</p><h3 id=直接映射>直接映射
<a class=anchor href=#%e7%9b%b4%e6%8e%a5%e6%98%a0%e5%b0%84>#</a></h3><p><img src=https://cdn.staticaly.com/gh/ivylet/blog_picg-@master/img/202306142024235.png alt=image.png>
每个主存块只能放到一个特定的位置，Cache块号=主存块号 % Cache总块数 只能放到固定的位置。<br>以某计算机的主存地址空间为256MB，按字节编址，其数据Cache有8个Cache行，行长为64B为例。<br>Cache块与主存块大小相等，所以主存块的大小也为64B，由于主存是按字节编址，则块内地址共6位，即0到63，主存块号为共22位，其中19位为标记，3位为行号。<br>从而映射到Cache中的标记也有19位，再附加1位有效位，置1证明是有效。<br><img src=https://cdn.staticaly.com/gh/ivylet/blog_picg-@master/img/202306142107010.png alt=image.png>
直接映射的优点是容易实现，命中时间短。但是多个块号“同余”的内存块只能映射到同一行Cache，会频繁的调进调出，使其他Cache都空闲，不能够使得Cache存储空间得到充分利用，不够灵活，命中率较低。</p><h3 id=组相联映射>组相联映射
<a class=anchor href=#%e7%bb%84%e7%9b%b8%e8%81%94%e6%98%a0%e5%b0%84>#</a></h3><p><img src=https://cdn.staticaly.com/gh/ivylet/blog_picg-@master/img/202306142026043.png alt=image.png>
Cache块分为若干组，每个主存块可以放到特定分组中的任意一个位置，所属分组 = 主存块号 % 分组数。<br>以某计算机的主存地址空间为256MB，按字节编址，其数据Cache有8个Cache行，行长为64B为例。<br>以2如组相联映射&ndash;2块为一组，分为四组。<br>Cache块与主存块大小相等，所以主存块的大小也为64B，由于主存是按字节编址，则块内地址共6位，即0到63，主存块号为共22位，其中20位为标记，2位为行号。<br>从而映射到Cache中的标记也有20位，再附加1位有效位，置1证明是有效<br><img src=https://cdn.staticaly.com/gh/ivylet/blog_picg-@master/img/202306142114924.png alt=image.png>
对直接映射和全相联映射取长补短，综合效果较好。<br>n路组相联映射&mdash;&ndash;每n个Cache行为一组。</p><h2 id=cache中主存块的替换算法>Cache中主存块的替换算法
<a class=anchor href=#cache%e4%b8%ad%e4%b8%bb%e5%ad%98%e5%9d%97%e7%9a%84%e6%9b%bf%e6%8d%a2%e7%ae%97%e6%b3%95>#</a></h2><p>如果Cache满了要怎么办？<br>对于全相联映射，当Cache完全满了时，需要在全局内选择替换哪一块。对于组相联映射，当分组内Cache满了才需要替换，需要在分组内中选择替换掉哪一块。对于直接映射，如果选择的位置非空，那么直接替换，不用考虑替换算法。</p><h3 id=随机替换算法rand>随机替换算法RAND
<a class=anchor href=#%e9%9a%8f%e6%9c%ba%e6%9b%bf%e6%8d%a2%e7%ae%97%e6%b3%95rand>#</a></h3><p>若Cache满了，随机选择一块替换！<br>设总共有4个Cache块，初始整个Cache行均 为空，采用全相联映射，依次访问主存块{1,2,3,4,1,2,5,1,2,3,4,5}。<br><img src=https://cdn.staticaly.com/gh/ivylet/blog_picg-@master/img/202306142138723.png alt=image.png>
其中替换的块都是随机选择的。<br>随机算法，实现简单，但是没有考虑局部性原理，命中率低，实际效果很不稳定！</p><h3 id=先进先出算法fifo>先进先出算法FIFO
<a class=anchor href=#%e5%85%88%e8%bf%9b%e5%85%88%e5%87%ba%e7%ae%97%e6%b3%95fifo>#</a></h3><p>若Cache满了，则替换最先被调入Cache的块！<br>设总共有4个Cache块，初始整个Cache行均 为空，采用全相联映射，依次访问主存块{1,2,3,4,1,2,5,1,2,3,4,5}。<br><img src=https://cdn.staticaly.com/gh/ivylet/blog_picg-@master/img/202306142142927.png alt=image.png>
其中替换的都是当前最先被调入的。实现也较为简单，最开始是按照#0#1#2#3放入Cache，之后轮流替换#0#1#2#3即可。但是依旧没有考虑局部性原理，因为最先被调用的很可能是频繁被访问的，有可能会出现频繁地被环路换出的情况“抖动”。</p><h3 id=最近最少用算法lru>最近最少用算法LRU
<a class=anchor href=#%e6%9c%80%e8%bf%91%e6%9c%80%e5%b0%91%e7%94%a8%e7%ae%97%e6%b3%95lru>#</a></h3><p>为每一个Cache块设置一个“计数器”，用于记录每个Cache已有多久没被访问到了。若Cache满了，则替换”计数器“中数最大的。<br>设总共有4个Cache块，初始整个Cache行均 为空，采用全相联映射，依次访问主存块{1,2,3,4,1,2,5,1,2,3,4,5}<br><img src=https://cdn.staticaly.com/gh/ivylet/blog_picg-@master/img/202306142158764.png alt=image.png></p><ul><li>命中时，所命中的行的计数器清零，比其低的计数器加一，其余不变。（如访问已有的1，只需把1所在Cache块计数器置零，比它大的没必要加1，因为计数器看大小。这样就可以保证计数器的大小小于4，只需要两个bit存储信息)</li><li>未命中且还有空闲行时，新装入的行的计数器置0，其余非空闲行全加1。</li><li>未命中且无空闲行时，计数值最大的行的信息被淘汰，新装行的块的计数器置0，其余全加1。
如果频繁访问的主存块数量大于Cache行的数量，则有可能发生“抖动”，如{1,2,3,4,5,1,2,3,4,5,1，2,3,4&mldr;&mldr;}。</li></ul><h3 id=最不常用算法lfu>最不常用算法LFU
<a class=anchor href=#%e6%9c%80%e4%b8%8d%e5%b8%b8%e7%94%a8%e7%ae%97%e6%b3%95lfu>#</a></h3><p>为每一个Cache块设置一个“计数器”，用于记录每个Cache被访问过多少次。若Cache满了，则替换”计数器“中数最小的。<br>设总共有4个Cache块，初始整个Cache行均 为空，采用全相联映射，依次访问主存块{1,2,3,4,1,2,5,1,2,3,4,5}<br><img src=https://cdn.staticaly.com/gh/ivylet/blog_picg-@master/img/202306142205643.png alt=image.png>
新调入的块计数器置0，之后每次被访问一次计数器加一。当需要替换时，选择计数器最小的一行。如果有多个计数器最小的行，可以选择按照行号递增或FIFO策略进行替换。<br>计数器中的值可能会很大，所以需要多位bit来存储信息。<br>LFU算法中曾经经常访问的主存块在为了不一定会被用到，比如一段时间内集中使用某段代码，但是这项工作结束后，后续可能很少会用到之前的相关数据。 并没有很好的遵循局部性原理，因此实际运行效果不如LRU。</p><h2 id=cache的一致性问题>Cache的一致性问题
<a class=anchor href=#cache%e7%9a%84%e4%b8%80%e8%87%b4%e6%80%a7%e9%97%ae%e9%a2%98>#</a></h2><p>CPU修改了Cache中的数据副本，如何确保主存中的数据母本的一致性？</p><h3 id=写命中>写命中
<a class=anchor href=#%e5%86%99%e5%91%bd%e4%b8%ad>#</a></h3><h4 id=写回法>写回法
<a class=anchor href=#%e5%86%99%e5%9b%9e%e6%b3%95>#</a></h4><p>当CPU对Cache写命中时，只修改Cache的内容，而不立即写入主存，只有当此时块被换出时才写会主存。Cache行中置一位脏位来表示是否被修改过，没被修改过就不必写回。<br>减少了访存次数，但存在数据不一致的隐患。</p><h4 id=全写法写直通法>全写法（写直通法）
<a class=anchor href=#%e5%85%a8%e5%86%99%e6%b3%95%e5%86%99%e7%9b%b4%e9%80%9a%e6%b3%95>#</a></h4><p>当CPU对Cache写命中时，必须把数据同时写入Cache和主存，一般使用写缓冲。<br>访存次数增加，速度变慢，但更能保持数据一致性。</p><p>可以增加用SRAM制作的写缓冲，利用FIFO策略。CPU对Cache写命中时，对Cache写命中时，同时对写缓冲写入内容。CPU写入SRAM速度是比直接写入主存要快的，SRAM再通过专门的控制电路控制写缓冲逐一写回主存。<br>如果操作不频繁，使用写缓冲的效果会较好，但是如果操作频繁，写缓冲会出现饱和并发生阻塞。</p><h3 id=写未命中>写未命中
<a class=anchor href=#%e5%86%99%e6%9c%aa%e5%91%bd%e4%b8%ad>#</a></h3><h4 id=写分配法>写分配法
<a class=anchor href=#%e5%86%99%e5%88%86%e9%85%8d%e6%b3%95>#</a></h4><p>当CPU对Cache写不命中时，会将主存中的块调入Cache，在Cache中修改，并通常搭配写回法使用。</p><h4 id=非写分配法>非写分配法
<a class=anchor href=#%e9%9d%9e%e5%86%99%e5%88%86%e9%85%8d%e6%b3%95>#</a></h4><p>当CPU对Cache写不命中时，只写入主存，不调入Cache。只对读操作未命中时才调入Cache。并通常搭配全写法使用。</p><h3 id=多级cache>多级Cache
<a class=anchor href=#%e5%a4%9a%e7%ba%a7cache>#</a></h3><p>现代计算机常采用多级 Cache，离CPU越近速度越快，容量越小。离CPU越远速度越慢，容量越大。不同级的Cache中也有数据一致性的问题。<br><img src=https://cdn.staticaly.com/gh/ivylet/blog_picg-@master/img/202306161602632.png alt=image.png></p><h1 id=虚拟存储器>虚拟存储器
<a class=anchor href=#%e8%99%9a%e6%8b%9f%e5%ad%98%e5%82%a8%e5%99%a8>#</a></h1><p>重点在操作系统中体现！<br>主存和辅存共同构成了虚拟存储器，两者在硬件和系统软件的共同管理下工作。对于应用级程序员而言，虚拟存储器是透明的。虚拟存储器具有主存的速度和辅存的容量。<br>手机和电脑有时候同时运行很多软件，这些软件占用的总内存可能超过了主存空间，但是用起来感觉不卡，这就是启用了虚拟存储器。将一些不常用的资源放到了辅存中。</p><h2 id=虚拟存储器的基本概念>虚拟存储器的基本概念
<a class=anchor href=#%e8%99%9a%e6%8b%9f%e5%ad%98%e5%82%a8%e5%99%a8%e7%9a%84%e5%9f%ba%e6%9c%ac%e6%a6%82%e5%bf%b5>#</a></h2><h2 id=页式虚拟存储器>页式虚拟存储器
<a class=anchor href=#%e9%a1%b5%e5%bc%8f%e8%99%9a%e6%8b%9f%e5%ad%98%e5%82%a8%e5%99%a8>#</a></h2><p>操作系统将程序分“页”</p><h4 id=页表>页表
<a class=anchor href=#%e9%a1%b5%e8%a1%a8>#</a></h4><ul><li>逻辑页号</li><li>主存块号</li><li>外存块号</li><li>有效位（装入位）
表示对应页面是否已经被装入主存，1代表该页面已经被从外存调入主存。</li><li>访问位（引用位）
配合页面替换算法设置的。</li><li>脏位
也叫修改位，用来表示页面是否被修改过，虚拟机制一般采用回写策略。利用脏位来表示是否需要写会磁盘。</li></ul><h4 id=快表>快表
<a class=anchor href=#%e5%bf%ab%e8%a1%a8>#</a></h4><h2 id=段式虚拟存储器>段式虚拟存储器
<a class=anchor href=#%e6%ae%b5%e5%bc%8f%e8%99%9a%e6%8b%9f%e5%ad%98%e5%82%a8%e5%99%a8>#</a></h2><p><img src=https://cdn.staticaly.com/gh/ivylet/blog_picg-@master/img/202306161641199.png alt=image.png></p><h2 id=段页式虚拟存储器>段页式虚拟存储器
<a class=anchor href=#%e6%ae%b5%e9%a1%b5%e5%bc%8f%e8%99%9a%e6%8b%9f%e5%ad%98%e5%82%a8%e5%99%a8>#</a></h2></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/ivylet/book-shelf/commit/f5e95a7f908fe05690e362f3a6998be43c14196f title='最后修改者 saytaytay | August 6, 2024' target=_blank rel=noopener><img src=/svg/calendar.svg class=book-icon alt=Calendar>
<span>August 6, 2024</span></a></div><div><a class="flex align-center" href=https://github.com/ivylet/book-shelf/edit/main/exampleSite/content/docs/chapter03/CO/cpt03/_index.md target=_blank rel=noopener><img src=/svg/edit.svg class=book-icon alt=Edit>
<span>编辑本页</span></a></div><footer id=footer><div class=container>&copy; 2024, By ivylet</a>。</div></footer></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#存储器概述>存储器概述</a><ul><li><a href=#存储器的层次结构>存储器的层次结构</a></li><li><a href=#存储器的分类>存储器的分类</a><ul><li></li><li><a href=#存储器的性能指标>存储器的性能指标</a></li></ul></li></ul></li><li><a href=#主存储器>主存储器</a><ul><li><a href=#主存储器的基本组成>主存储器的基本组成</a><ul><li><a href=#基本半导体元件>基本半导体元件</a></li><li><a href=#存储芯片的结构>存储芯片的结构</a></li><li><a href=#寻址>寻址</a></li></ul></li><li><a href=#sram与dram>SRAM与DRAM</a><ul><li><a href=#存储元件不同而导致的特性差异>存储元件不同而导致的特性差异</a></li><li><a href=#dram的刷新>DRAM的刷新</a></li><li><a href=#dram的地址线复用技术>DRAM的地址线复用技术</a></li></ul></li><li><a href=#只读存储器rom>只读存储器ROM</a><ul><li><a href=#常见rom>常见ROM</a></li><li><a href=#计算机内重要的rom>计算机内重要的ROM</a></li></ul></li><li><a href=#双端口ram和多模块存储器>双端口RAM和多模块存储器</a><ul><li></li><li><a href=#双端口ram大纲已删>双端口RAM（大纲已删）</a></li><li><a href=#多模块存储器>多模块存储器</a></li></ul></li></ul></li><li><a href=#主存储器与cpu的连接>主存储器与CPU的连接</a><ul><li><a href=#单块存储芯片与cpu连接>单块存储芯片与CPU连接</a><ul><li></li></ul></li><li><a href=#多块存储芯片与cpu连接>多块存储芯片与CPU连接</a><ul><li></li></ul></li><li><a href=#关于译码器知识补充>关于译码器知识补充</a></li></ul></li><li><a href=#外部存储器>外部存储器</a><ul><li><a href=#磁盘存储器>磁盘存储器</a><ul><li><a href=#磁盘设备的组成>磁盘设备的组成</a></li><li><a href=#磁盘的性能指标>磁盘的性能指标</a></li><li><a href=#磁盘地址>磁盘地址</a></li><li><a href=#磁盘的工作过程>磁盘的工作过程</a></li><li><a href=#磁盘阵列raid>磁盘阵列（RAID）</a></li></ul></li><li><a href=#固态硬盘ssd>固态硬盘SSD</a><ul><li></li></ul></li></ul></li><li><a href=#高速缓冲器cache>高速缓冲器（Cache）</a><ul><li><a href=#局部性原理>局部性原理</a></li><li><a href=#cache的基本工作原理>Cache的基本工作原理</a><ul><li><a href=#cache中的有效位>Cache中的有效位</a></li><li><a href=#cpu找cache中的访问过程>CPU找Cache中的访问过程</a></li><li><a href=#平均访问时间>平均访问时间</a></li><li><a href=#几个问题>几个问题</a></li></ul></li><li><a href=#cache行与主存块之间的映射方式>Cache行与主存块之间的映射方式</a><ul><li><a href=#全相联映射随意映射>全相联映射（随意映射）</a></li><li><a href=#直接映射>直接映射</a></li><li><a href=#组相联映射>组相联映射</a></li></ul></li><li><a href=#cache中主存块的替换算法>Cache中主存块的替换算法</a><ul><li><a href=#随机替换算法rand>随机替换算法RAND</a></li><li><a href=#先进先出算法fifo>先进先出算法FIFO</a></li><li><a href=#最近最少用算法lru>最近最少用算法LRU</a></li><li><a href=#最不常用算法lfu>最不常用算法LFU</a></li></ul></li><li><a href=#cache的一致性问题>Cache的一致性问题</a><ul><li><a href=#写命中>写命中</a></li><li><a href=#写未命中>写未命中</a></li><li><a href=#多级cache>多级Cache</a></li></ul></li></ul></li><li><a href=#虚拟存储器>虚拟存储器</a><ul><li><a href=#虚拟存储器的基本概念>虚拟存储器的基本概念</a></li><li><a href=#页式虚拟存储器>页式虚拟存储器</a><ul><li></li></ul></li><li><a href=#段式虚拟存储器>段式虚拟存储器</a></li><li><a href=#段页式虚拟存储器>段页式虚拟存储器</a></li></ul></li></ul></nav></div></aside></main></body></html>