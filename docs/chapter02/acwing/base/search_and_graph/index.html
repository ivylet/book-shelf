<!doctype html><html lang=zh dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content=" 图论 # Floyd算法 # 主要思想是: 循环邻接矩阵中查找每个点到另外一个点的最短距离，不仅是看直接距离，也还要通过计算中转点。比如计算A到B的距离，要比较A到C的距离与C到B的距离的和、A到B的直接距离的最小值来判断，中转点可以是其他节点，所以代码实现中出现了三重循环。
//n为顶点个数 //第一轮循环为 选取中间点的个数 //第二三轮循环为 void floyd(){ for(int k = 1 ; k <=n ; k++) for(int i = 1 ; i <= n ;i ++) for(int j = 1 ; j <=n ;j ++) dic[i][j] = min(dic[i][j],dic[i][k] + dic[k][j]); } 模板题代码：
#include<iostream> using namespace std; const int N = 210,INF = 1e9; int dic[N][N]; int n,m,Q; void floyd(){ for(int k = 1 ; k <=n ; k++) for(int i = 1 ; i <= n ;i ++) for(int j = 1 ; j <=n ;j ++) dic[i][j] = min(dic[i][j],dic[i][k] + dic[k][j]); } int main(){ scanf(&#34;%d%d%d&#34;,&n,&m,&Q); for(int i = 1 ; i <= n ;i ++) for(int j = 1 ; j<=n;j++) if(i == j) dic[i][j] = 0; else dic[i][j] = INF; while(m--) { int a,b,w; scanf(&#34;%d%d%d&#34;,&a,&b,&w); dic[a][b] = min(dic[a][b],w); } floyd(); while(Q--) { int a,b; scanf(&#34;%d%d&#34;,&a,&b); if(dic[a][b] < INF / 2) printf(&#34;%d&#34;,dic[a][b]); else printf(&#34;impossible&#34;); printf(&#34;\n&#34;); } return 0; } "><meta name=theme-color content="#FFFFFF"><meta name=color-scheme content="light dark"><meta property="og:title" content="搜索与图论"><meta property="og:description" content=" 图论 # Floyd算法 # 主要思想是: 循环邻接矩阵中查找每个点到另外一个点的最短距离，不仅是看直接距离，也还要通过计算中转点。比如计算A到B的距离，要比较A到C的距离与C到B的距离的和、A到B的直接距离的最小值来判断，中转点可以是其他节点，所以代码实现中出现了三重循环。
//n为顶点个数 //第一轮循环为 选取中间点的个数 //第二三轮循环为 void floyd(){ for(int k = 1 ; k <=n ; k++) for(int i = 1 ; i <= n ;i ++) for(int j = 1 ; j <=n ;j ++) dic[i][j] = min(dic[i][j],dic[i][k] + dic[k][j]); } 模板题代码：
#include<iostream> using namespace std; const int N = 210,INF = 1e9; int dic[N][N]; int n,m,Q; void floyd(){ for(int k = 1 ; k <=n ; k++) for(int i = 1 ; i <= n ;i ++) for(int j = 1 ; j <=n ;j ++) dic[i][j] = min(dic[i][j],dic[i][k] + dic[k][j]); } int main(){ scanf(&#34;%d%d%d&#34;,&n,&m,&Q); for(int i = 1 ; i <= n ;i ++) for(int j = 1 ; j<=n;j++) if(i == j) dic[i][j] = 0; else dic[i][j] = INF; while(m--) { int a,b,w; scanf(&#34;%d%d%d&#34;,&a,&b,&w); dic[a][b] = min(dic[a][b],w); } floyd(); while(Q--) { int a,b; scanf(&#34;%d%d&#34;,&a,&b); if(dic[a][b] < INF / 2) printf(&#34;%d&#34;,dic[a][b]); else printf(&#34;impossible&#34;); printf(&#34;\n&#34;); } return 0; } "><meta property="og:type" content="article"><meta property="og:url" content="http://ivylet.github.io/docs/chapter02/acwing/base/search_and_graph/"><meta property="article:section" content="docs"><meta property="article:modified_time" content="2024-08-06T20:08:42+08:00"><title>搜索与图论 | QBook</title><link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png type=image/x-icon><link rel=stylesheet href=/book.min.4b35fed0bea034bbc19c89c71e14b73fb9c68cfcc586b9382adfb9b7b103ba06.css integrity="sha256-SzX+0L6gNLvBnInHHhS3P7nGjPzFhrk4Kt+5t7EDugY=" crossorigin=anonymous><script defer src=/flexsearch.min.js></script>
<script defer src=/zh.search.min.4eb7993ef63f5c2c50e865c42dbdf9b032a352d679f97f19b434aa9de80d3717.js integrity="sha256-TreZPvY/XCxQ6GXELb35sDKjUtZ5+X8ZtDSqnegNNxc=" crossorigin=anonymous></script>
<script defer src=/sw.min.6f6f90fcb8eb1c49ec389838e6b801d0de19430b8e516902f8d75c3c8bd98739.js integrity="sha256-b2+Q/LjrHEnsOJg45rgB0N4ZQwuOUWkC+NdcPIvZhzk=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>QBook</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=搜索 aria-label=搜索 maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul class=book-languages><li><input type=checkbox id=languages class=toggle>
<label for=languages class="flex justify-between"><a role=button class="flex align-center"><img src=/svg/translate.svg class=book-icon alt=Languages>
Chinese</a></label><ul><li><a href=http://ivylet.github.io/en/>English</a></li></ul></li></ul><ul><li><input type=checkbox id=section-903d3e7635db560eef69c6ad03432b92 class=toggle>
<label for=section-903d3e7635db560eef69c6ad03432b92 class="flex justify-between"><a role=button>第一章|基础知识储备</a></label><ul><li><a href=/docs/chapter01/cpp-stl-argo/>STL中常用算法</a></li><li><a href=/docs/chapter01/cpp/>STL中常用算法1</a></li><li><a href=/docs/chapter01/datastru/>常用算法储备知识</a></li><li><a href=/docs/chapter01/cpp-stl-intro/>C++ STL</a></li><li><a href=/docs/chapter01/argo-datastru/>算法竞赛常用STL</a></li></ul></li><li><input type=checkbox id=section-144f7b511d4fbbff231a670ff00b5f9e class=toggle checked>
<label for=section-144f7b511d4fbbff231a670ff00b5f9e class="flex justify-between"><a role=button>第二章|基础算法</a></label><ul><li><input type=checkbox id=section-9db364c0dccf0502e8049e61bd8b0d86 class=toggle checked>
<label for=section-9db364c0dccf0502e8049e61bd8b0d86 class="flex justify-between"><a role=button>Acwing</a></label><ul><li><input type=checkbox id=section-96943a9cc0137d53acdca869bdf27124 class=toggle checked>
<label for=section-96943a9cc0137d53acdca869bdf27124 class="flex justify-between"><a role=button>Base</a></label><ul><li><a href=/docs/chapter02/acwing/base/base-1/>基础算法一</a></li><li><a href=/docs/chapter02/acwing/base/datestruct/>数据结构</a></li><li><a href=/docs/chapter02/acwing/base/search_and_graph/ class=active>搜索与图论</a></li><li><a href=/docs/chapter02/acwing/base/greedy/>贪心</a></li></ul></li><li><input type=checkbox id=section-88eae5c1d766baf874d32d1908707564 class=toggle>
<label for=section-88eae5c1d766baf874d32d1908707564 class="flex justify-between"><a role=button>Dp</a></label><ul><li><a href=/docs/chapter02/acwing/DP/DP/>DP</a></li><li><a href=/docs/chapter02/acwing/DP/package/>背包问题</a></li></ul></li><li><input type=checkbox id=section-a50d07f316054aeee9419b25ddf950a0 class=toggle>
<label for=section-a50d07f316054aeee9419b25ddf950a0 class="flex justify-between"><a role=button>Math</a></label><ul><li><a href=/docs/chapter02/acwing/math/others/>其他</a></li><li><a href=/docs/chapter02/acwing/math/shulun/>数论</a></li></ul></li></ul></li><li><a href=/docs/chapter02/commonSolution/>常用思想方法</a></li></ul></li><li><input type=checkbox id=section-fca257306a653a028d58c47b763ab4c5 class=toggle>
<label for=section-fca257306a653a028d58c47b763ab4c5 class="flex justify-between"><a role=button>第三章|计算机基础知识</a></label><ul><li><input type=checkbox id=section-c6a658a9eab81ef20c403bdfcfbb322f class=toggle>
<label for=section-c6a658a9eab81ef20c403bdfcfbb322f class="flex justify-between"><a role=button>数据结构</a></label><ul><li><a href=/docs/chapter03/DS/cpter08/>排序算法</a><ul></ul></li></ul></li><li><input type=checkbox id=section-40effe6a2504b41caa4ca2922e36dd2a class=toggle>
<label for=section-40effe6a2504b41caa4ca2922e36dd2a class="flex justify-between"><a role=button>计算机组成原理</a></label><ul><li><a href=/docs/chapter03/CO/cpt02/>第二章|数据的表示与运算</a><ul></ul></li><li><a href=/docs/chapter03/CO/cpt03/>第三章|存储系统</a><ul></ul></li><li><a href=/docs/chapter03/CO/cpt04/>第四章|指令系统</a><ul></ul></li><li><a href=/docs/chapter03/CO/cpt05/>第五章|中央控制器</a><ul></ul></li></ul></li><li><input type=checkbox id=section-90808d88c5fb0a7411c304bba41a80d8 class=toggle>
<label for=section-90808d88c5fb0a7411c304bba41a80d8 class="flex justify-between"><a role=button>操作系统</a></label><ul><li><span>第一章|计算机系统概述</span><ul></ul></li><li><span>第二章|进程与线程</span><ul></ul></li><li><span>第三章|内存管理</span><ul></ul></li><li><span>第四章|文佳管理</span><ul></ul></li><li><span>第五章|I/O管理</span><ul></ul></li></ul></li><li><input type=checkbox id=section-25823a2461316869125b231cfddbbdc4 class=toggle>
<label for=section-25823a2461316869125b231cfddbbdc4 class="flex justify-between"><a role=button>机器学习</a></label><ul><li><a href=/docs/chapter03/machine-learning/tools/>常用工具</a></li><li><a href=/docs/chapter03/machine-learning/LinerRegression/>线性回归</a><ul></ul></li></ul></li></ul></li><li><input type=checkbox id=section-574b1a2b668b65d846660d1f8c5a4bfb class=toggle>
<label for=section-574b1a2b668b65d846660d1f8c5a4bfb class="flex justify-between"><a role=button>记录和其他</a></label><ul><li><input type=checkbox id=section-c1536e74d6e5fb6bc2e23ae4a04a06df class=toggle>
<label for=section-c1536e74d6e5fb6bc2e23ae4a04a06df class="flex justify-between"><a role=button>暂时没名字</a></label><ul><li><a href=/docs/notes/other/00001/>无意识？！</a></li></ul></li><li><input type=checkbox id=section-a3b6ca56f01a783b7e83028f9b977c5b class=toggle>
<label for=section-a3b6ca56f01a783b7e83028f9b977c5b class="flex justify-between"><a role=button>小记</a></label><ul><li><a href=/docs/notes/thinknote/00001/>暂且第一记</a></li><li><a href=/docs/notes/thinknote/00002/>一些话</a></li><li><a href=/docs/notes/thinknote/00003/>生活</a></li><li><a href=/docs/notes/thinknote/00000/>原初号</a></li></ul></li><li><span>notes</span><ul><li><a href=/docs/notes/readingnotes/0001/>《大问题》阅读随笔</a></li><li><a href=/docs/notes/readingnotes/0002/>拉康</a></li></ul></li></ul></li></ul><ul><li><a href=https://github.com/ivylet target=_blank rel=noopener>Github</a></li><li><a href=https://leetcode.cn/ target=_blank rel=noopener>Leetcode</a></li><li><a href=https://themes.gohugo.io/hugo-book/ target=_blank rel=noopener>Hugo Themes</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label>
<strong>搜索与图论</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><ul><li><a href=#图论>图论</a><ul><li><a href=#floyd算法>Floyd算法</a></li></ul></li></ul></li></ul></nav></aside></header><article class=markdown><h2 id=图论>图论
<a class=anchor href=#%e5%9b%be%e8%ae%ba>#</a></h2><h3 id=floyd算法>Floyd算法
<a class=anchor href=#floyd%e7%ae%97%e6%b3%95>#</a></h3><p>主要思想是:
循环邻接矩阵中查找每个点到另外一个点的最短距离，不仅是看直接距离，也还要通过计算中转点。比如计算A到B的距离，要比较A到C的距离与C到B的距离的和、A到B的直接距离的最小值来判断，中转点可以是其他节点，所以代码实现中出现了三重循环。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>//n为顶点个数
</span></span></span><span style=display:flex><span><span style=color:#75715e>//第一轮循环为 选取中间点的个数
</span></span></span><span style=display:flex><span><span style=color:#75715e>//第二三轮循环为
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>floyd</span>(){
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> k <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span> ; k <span style=color:#f92672>&lt;=</span>n ; k<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span> ; i <span style=color:#f92672>&lt;=</span> n ;i <span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span> ; j <span style=color:#f92672>&lt;=</span>n ;j <span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>                dic[i][j] <span style=color:#f92672>=</span> min(dic[i][j],dic[i][k] <span style=color:#f92672>+</span> dic[k][j]);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>模板题代码：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span><span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> N <span style=color:#f92672>=</span> <span style=color:#ae81ff>210</span>,INF <span style=color:#f92672>=</span> <span style=color:#ae81ff>1e9</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> dic[N][N];
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> n,m,Q;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>floyd</span>(){
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> k <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span> ; k <span style=color:#f92672>&lt;=</span>n ; k<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span> ; i <span style=color:#f92672>&lt;=</span> n ;i <span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span> ; j <span style=color:#f92672>&lt;=</span>n ;j <span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>                dic[i][j] <span style=color:#f92672>=</span> min(dic[i][j],dic[i][k] <span style=color:#f92672>+</span> dic[k][j]);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(){
</span></span><span style=display:flex><span>    scanf(<span style=color:#e6db74>&#34;%d%d%d&#34;</span>,<span style=color:#f92672>&amp;</span>n,<span style=color:#f92672>&amp;</span>m,<span style=color:#f92672>&amp;</span>Q);
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span> ; i <span style=color:#f92672>&lt;=</span> n ;i <span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span> ; j<span style=color:#f92672>&lt;=</span>n;j<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span>(i <span style=color:#f92672>==</span> j) dic[i][j] <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>else</span> dic[i][j] <span style=color:#f92672>=</span> INF;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span>(m<span style=color:#f92672>--</span>)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> a,b,w;
</span></span><span style=display:flex><span>        scanf(<span style=color:#e6db74>&#34;%d%d%d&#34;</span>,<span style=color:#f92672>&amp;</span>a,<span style=color:#f92672>&amp;</span>b,<span style=color:#f92672>&amp;</span>w);
</span></span><span style=display:flex><span>        dic[a][b] <span style=color:#f92672>=</span> min(dic[a][b],w);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    floyd();
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span>(Q<span style=color:#f92672>--</span>)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> a,b;
</span></span><span style=display:flex><span>        scanf(<span style=color:#e6db74>&#34;%d%d&#34;</span>,<span style=color:#f92672>&amp;</span>a,<span style=color:#f92672>&amp;</span>b);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>(dic[a][b] <span style=color:#f92672>&lt;</span> INF <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>) printf(<span style=color:#e6db74>&#34;%d&#34;</span>,dic[a][b]);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span> printf(<span style=color:#e6db74>&#34;impossible&#34;</span>);
</span></span><span style=display:flex><span>        printf(<span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>                
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/ivylet/book-shelf/commit/f5e95a7f908fe05690e362f3a6998be43c14196f title='最后修改者 saytaytay | August 6, 2024' target=_blank rel=noopener><img src=/svg/calendar.svg class=book-icon alt=Calendar>
<span>August 6, 2024</span></a></div><div><a class="flex align-center" href=https://github.com/ivylet/book-shelf/edit/main/exampleSite/content/docs/chapter02/acwing/base/search_and_graph.md target=_blank rel=noopener><img src=/svg/edit.svg class=book-icon alt=Edit>
<span>编辑本页</span></a></div><footer id=footer><div class=container>&copy; 2024, By ivylet</a>。</div></footer></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><ul><li><a href=#图论>图论</a><ul><li><a href=#floyd算法>Floyd算法</a></li></ul></li></ul></li></ul></nav></div></aside></main></body></html>