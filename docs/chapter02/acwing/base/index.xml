<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>QBook</title><link>http://ivylet.github.io/docs/chapter02/acwing/base/</link><description>Recent content on QBook</description><generator>Hugo -- gohugo.io</generator><atom:link href="http://ivylet.github.io/docs/chapter02/acwing/base/index.xml" rel="self" type="application/rss+xml"/><item><title>基础算法一</title><link>http://ivylet.github.io/docs/chapter02/acwing/base/base-1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://ivylet.github.io/docs/chapter02/acwing/base/base-1/</guid><description>快速排序 # 主要思想: # 在数组中选择一个值，然后遍历数组，比这个值大的放到这个值后边，比这个值小的放到这个值的前边。
代码实现 # void quick_sort(int q[], int l, int r){ if(l &amp;gt;= r) return; int x = q[(l + r) &amp;gt;&amp;gt; 1], i = l - 1, j = r + 1; while(i &amp;lt; j) { do i ++ ; while(q[i] &amp;lt; x); do j -- ; while(q[j] &amp;gt; x); if(i &amp;lt; j) swap(q[i],q[j]); } quick_sort(q,l, j); quick_sort(q,j+1,r); } 为什么最后是j与j+1呢?
因为范围确保的是左边是小于等于x，右边大于等于x。而循环判断结束的限制是i&amp;lt;j,则可能出现的情况是i=j或i = j + 1。如果是i=j+1那么左边为l到i不满足左边都小于等于x，因为q[i]&amp;gt;x。那为什么不是l到i-1呢？如果是l到i-1那么可能出现只有两个数的情况，然后划分的时候右边化为空集，左边为两个数的数组，此时陷入无尽循环。</description></item><item><title>数据结构</title><link>http://ivylet.github.io/docs/chapter02/acwing/base/datestruct/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://ivylet.github.io/docs/chapter02/acwing/base/datestruct/</guid><description>链表 # 拿数组模拟链表,其实也就是静态链表. 静态链表的优点是快,但是缺点是必须要提前分配足够空间,并且可能会出现假满状态,即idx到最后但是前边还有很多未使用的节点,
单链表 # #include&amp;lt;iostream&amp;gt; using namespace std; const int N = 100010; int e[N]; int ne[N]; int idx,head; void init(){ head = -1; idx = 0; } void add_to_head(int x){ e[idx] = x; ne[idx] = head; head = idx++; } //插入到下标为k的后面 void add(int k,int x){ e[idx] = x; ne[idx] = ne[k]; ne[k] = idx ++; } void del(int k){ if(k == -1) head = ne[head]; else ne[k] = ne[ne[k]]; } int main(){ int m; cin &amp;gt;&amp;gt; m; init(); while(m--){ char opt; cin &amp;gt;&amp;gt; opt; if(opt == &amp;#39;H&amp;#39;){ int x; cin &amp;gt;&amp;gt; x; add_to_head(x); }else if(opt == &amp;#39;D&amp;#39;){ int k; cin &amp;gt;&amp;gt; k; del(k-1); }else{ int k,x; cin &amp;gt;&amp;gt; k &amp;gt;&amp;gt;x; add(k - 1,x); } } int index = head; while(index !</description></item><item><title>搜索与图论</title><link>http://ivylet.github.io/docs/chapter02/acwing/base/search_and_graph/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://ivylet.github.io/docs/chapter02/acwing/base/search_and_graph/</guid><description> 图论 # Floyd算法 # 主要思想是: 循环邻接矩阵中查找每个点到另外一个点的最短距离，不仅是看直接距离，也还要通过计算中转点。比如计算A到B的距离，要比较A到C的距离与C到B的距离的和、A到B的直接距离的最小值来判断，中转点可以是其他节点，所以代码实现中出现了三重循环。
//n为顶点个数 //第一轮循环为 选取中间点的个数 //第二三轮循环为 void floyd(){ for(int k = 1 ; k &amp;lt;=n ; k++) for(int i = 1 ; i &amp;lt;= n ;i ++) for(int j = 1 ; j &amp;lt;=n ;j ++) dic[i][j] = min(dic[i][j],dic[i][k] + dic[k][j]); } 模板题代码：
#include&amp;lt;iostream&amp;gt; using namespace std; const int N = 210,INF = 1e9; int dic[N][N]; int n,m,Q; void floyd(){ for(int k = 1 ; k &amp;lt;=n ; k++) for(int i = 1 ; i &amp;lt;= n ;i ++) for(int j = 1 ; j &amp;lt;=n ;j ++) dic[i][j] = min(dic[i][j],dic[i][k] + dic[k][j]); } int main(){ scanf(&amp;#34;%d%d%d&amp;#34;,&amp;amp;n,&amp;amp;m,&amp;amp;Q); for(int i = 1 ; i &amp;lt;= n ;i ++) for(int j = 1 ; j&amp;lt;=n;j++) if(i == j) dic[i][j] = 0; else dic[i][j] = INF; while(m--) { int a,b,w; scanf(&amp;#34;%d%d%d&amp;#34;,&amp;amp;a,&amp;amp;b,&amp;amp;w); dic[a][b] = min(dic[a][b],w); } floyd(); while(Q--) { int a,b; scanf(&amp;#34;%d%d&amp;#34;,&amp;amp;a,&amp;amp;b); if(dic[a][b] &amp;lt; INF / 2) printf(&amp;#34;%d&amp;#34;,dic[a][b]); else printf(&amp;#34;impossible&amp;#34;); printf(&amp;#34;\n&amp;#34;); } return 0; }</description></item><item><title>贪心</title><link>http://ivylet.github.io/docs/chapter02/acwing/base/greedy/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://ivylet.github.io/docs/chapter02/acwing/base/greedy/</guid><description> 与区间有关的问题 #</description></item></channel></rss>