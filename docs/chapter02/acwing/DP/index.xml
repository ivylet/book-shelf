<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>QBook</title><link>http://ivylet.github.io/docs/chapter02/acwing/DP/</link><description>Recent content on QBook</description><generator>Hugo -- gohugo.io</generator><atom:link href="http://ivylet.github.io/docs/chapter02/acwing/DP/index.xml" rel="self" type="application/rss+xml"/><item><title>DP</title><link>http://ivylet.github.io/docs/chapter02/acwing/DP/DP/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://ivylet.github.io/docs/chapter02/acwing/DP/DP/</guid><description>背包DP # 01背包 # 每件物品最多只用一次。
有 N 件物品和一个容量是 V 的背包。每件物品只能使用一次。 第 i 件物品的体积是 vi，价值是 wi。 求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。
输出最大价值。 2. 01背包问题 - AcWing题库
#include&amp;lt;iostream&amp;gt; using namespace std; const int N = 1010; int v[N],w[N]; int m,n; int f[N][N]; int main(){ cin &amp;gt;&amp;gt; m &amp;gt;&amp;gt; n; for(int i = 1; i &amp;lt;= m;i++ ){ cin &amp;gt;&amp;gt; v[i] &amp;gt;&amp;gt; w[i]; } for(int i = 1; i &amp;lt;= m;i++){ for(int j = 0;j&amp;lt;= n;j++) { f[i][j] = f[i - 1][j]; if( j &amp;gt;= v[i]) //当可以装下的空间比第i个大才有可能存在装第i个物品的情况。 f[i][j] = max(f[i][j],f[i - 1][j - v[i]] + w[i]); } } cout &amp;lt;&amp;lt; f[m][n]; return 0; } 优化为二维</description></item><item><title>背包问题</title><link>http://ivylet.github.io/docs/chapter02/acwing/DP/package/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://ivylet.github.io/docs/chapter02/acwing/DP/package/</guid><description>01 背包问题 # 每件物品最多只用一次。
有 N 件物品和一个容量是 V 的背包。每件物品只能使用一次。 第 i 件物品的体积是 vi，价值是 wi。 求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。
输出最大价值。 2. 01背包问题 - AcWing题库
#include&amp;lt;iostream&amp;gt; using namespace std; const int N = 1010; int v[N],w[N]; int m,n; int f[N][N]; int main(){ cin &amp;gt;&amp;gt; m &amp;gt;&amp;gt; n; for(int i = 1; i &amp;lt;= m;i++ ){ cin &amp;gt;&amp;gt; v[i] &amp;gt;&amp;gt; w[i]; } for(int i = 1; i &amp;lt;= m;i++){ for(int j = 0;j&amp;lt;= n;j++) { f[i][j] = f[i - 1][j]; if( j &amp;gt;= v[i]) //当可以装下的空间比第i个大才有可能存在装第i个物品的情况。 f[i][j] = max(f[i][j],f[i - 1][j - v[i]] + w[i]); } } cout &amp;lt;&amp;lt; f[m][n]; return 0; } 优化为二维</description></item></channel></rss>